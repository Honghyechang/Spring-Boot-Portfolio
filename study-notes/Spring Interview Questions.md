
## Q1 :  스프링 프레임워크가 특징과 함께 설명해주세요.
### A : 스프링 프레임워크는 자바 백엔드 애플리케이션 개발을 위한 프레임워크입니다. 스프링의 핵심 특징은 객체의 생명 주기를 개발자가 아닌 프레임워크가 관리하는 IOC, IOC를 실현하기 위한 방법으로 객체 간의 의존 관계를 주입해주는 DI, 마지막으로 공통 관심사를 분리하여 어노테이션을 통해 수평적으로 확장하는 AOP가 있습니다.


## Q2 :  스프링부트와 스프링 프레임워크의 차이점은 무엇인가요?
### A : 스프링부트는 스프링 프레임워크를 더 쉽고 빠르게 사용할 수 있는 도구입니다. 복잡한 설정을 자동화하여 개발자는 설정보다 비즈니스 로직에 집중할 수 있습니다.

## Q3 :  스프링에서 IoC를 구현하는 방법은 무엇이 있나요?
### A : XML 설정 파일, @Autowired,@Component와 같은 어노테이션, @Configuration,@Bean를 사용하는 java config 클래스 방법이 있습니다.

## Q4 :  스프링 컨테이너가 무엇인가요?
### A : 스프링 컨테이너란, ApplicationContext를 구현한 객체로, 빈 생명주기 관리 및 의존성 주입 역할을 하는 객체입니다.

## Q5 :  빈(Bean)이 무엇인가요?
### A : 빈은 스프링 컨테이너가 관리하는 자바 객체입니다. 어노테이션과 xml 설정을 통해 빈으로 등록할 수 있으며, 기본적으로 싱글톤으로 관리가 됩니다.

## Q6 :  @Autowired는 어떻게 동작하나요?
### A : @Autowired는 스프링 컨테이너가 관리하는 빈 목록에서 같은 타입의 빈을 찾고, 같은 타입이 여러개라면 @Qulifier이나 @Primary를 사용하여 주입합니다.

## Q7 :  AOP와 OOP의 차이점이 무엇인가요?
### A : OOP(Object Oriented Programing)은 상속과 다형성을 통해 수직적으로 기능을 확장하는 것이고, AOP(Aspect Oriented Programing)은 공통으로 필요한 기능을 분리하여 어노테이션을 통해 수평적으로 확장하는 것입니다. 

## Q8 : JDK가 무엇인가요?
### A : JDK는 Java Development Kit의 약자로, JRE, JAVAC, JVM 등을 포함하고 있는 자바 애플리케이션을 개발하고 실행하는데 필요한 도구 모음입니다. 

## Q9 :  JDK 내부의 javac와 JVM의 역할은 무엇인가요?
### A : javac는 자바 컴파일러로, 개발자가 작성한 .java 파일을 바이트코드인 .class로 변환하는 역할을 합니다. JVM은 이렇게 컴파일된 .class파일을 실제로 실행하는 가상 머신입니다.

## Q10 : JAR과 WAR의 차이점은 무엇인가요  
### A : JAR은 TOMCAT 서버가 내장되어 있어 독립적으로 실행이 가능합니다. 반면 WAR은 외부 WAS가 필요하며 여러 애플리케이션을 하나의 WAS에서 운영할 때 사용합니다.

## Q11 : 전통적인 MVC 방식과 RESTful API 방식의 차이점은 무엇인가요?  
### A : 전통적인 MVC 방식은 SSR(Server Side Rendering)으로, 서버에서 html을 완전히 생성하여 클라이언트에게 전달하는 방식입니다. 반면 RESTful API 서버 방식은 JSON이나 XML 같은 데이터만 반환하여 화면 구성은 클라이언트가 담당합니다.

## Q12 :System.out.println 대신 Logger를 사용해야 하는 이유는 무엇인가요?  
### A : System.out.println은 모든 메시지가 다 출력되고, 출력 위치도 콘솔로 제한됩니다. 반면 Logger은 로그 레벨에 따라 출력을 제어할 수 있고, 콘솔뿐만 아니라 파일,데이터베이스 등 다양한 방식으로 출력이 가능합니다. 

## Q13 :로그 레벨의 종류와 순서를 설명해주세요.  
### A : 로그 레벨은 trace,debug,info,warn,error 순서입니다. 

## Q14 : 로그 레벨의 상속 구조는 어떻게 동작하나요?  
### A : 로그 레벨은 패키지 계층 구조를 따라 상속됩니다. 특정 패키지에 레벨을 지정하면 해당 패키지와 하위 패키지에 모두 적용되며, 더 구체적으로 하위 패키지에 별도 레벨을 지정하면 그것이 우선됩니다.

## Q 15: JDBC란 무엇이고, 왜 필요한가요?  
### A : JDBC는 Java Database Connectivity의 약자로 자바 애플리케이션에서 데이터베이스에 접근하기 위한 표준 API입니다. 데이터베이스마다 통신 방법과 사용 방법이 다른데 매번 데이터베이스에 맞춰 코드를 다르게 작성할 수 없기 때문에 통일된 인터페이스를 제공합니다. 개발자는 JDBC API만 사용하면 되고, 이 JDBC API를 구현한 객체인 JDBC Driver는 회사에서 제공해줍니다.   

## Q 16: JDBC Driver가 무엇인가요?
### A : JDBC Driver는 JDBC API를 실제로 구현한 구현체입니다. 이 드라이버는 각 데이터베이스 벤더(회사)에서 제공해주며 개발자는 이 드라이버를 드라이버 매니저에 등록하여 사용하면됩니다. 

## Q 17:JDBC를 사용하는 전체 과정을 설명해주세요.   
### A : 우선 DriverManager에 JDBC Driver을 등록합니다. DriverMagager에서 적절한 드라이버를 찾아 데이터베이스와의 Connection을 생성합니다. 이후 SQL쿼리를 실행하고, 결과를 순회하며 데이터를 추출합니다. 마지막으로 사용한 Connection을 닫아줍니다.

## Q 18: JDBC의 주요 단점은 무엇인가요?   
### A : 크게 두가지 단점이 있습니다. 매번 Connection을 생성하고 종료하는 반복적인 보일러플레이트 코드가 발생한다는 점과 데이터베이스에서 가져온 결과를 Java객체에 수동으로 매핑해야한다는 점이 있습니다.

## Q 19:Spring Data JDBC가 무엇이고 왜 등장했나요?   
### A : Spring Data JDBC는 JDBC의 단점을 보완하여 개발자가 비즈니스 로직에 집중할 수 있도록 도와주는 추상화 레이어입니다. 커넥션 풀을 통해 매번 Connection을 생성하는 대신 미리 만들어놓은 Connection을 재사용합니다. 또한 데이터베이스의 조회 결과를 객체로 자동 매핑해줍니다. 

## Q 20: 커넥션 풀이 뭔데요?  
### A : 커넥션 풀은 애플리케이션 시작 시 여러개의 Connection을 미리 생성해놓고, 필요할 때 빌려주고 사용이 끝나면 반납하는 방식으로, Connection을 재사용하여 연결 속도가 빠르고 자원 관리를 자동으로 처리할 수 있습니다. 

## Q 21: @Table 어노테이션이 무엇인가요?  
### A : @Table 어노테이션이 붙은 클래스가 데이터베이스의 테이블과 매핑되며, 데이터베이스에서 조회한 결과를 담는 그릇 역할을 한다는 것을 나타냅니다.  

## Q 22: Lombok의 @Data 어노테이션은 무엇인가요?  
### A : @Data 어노테이션은 @Getter,@Setter,@ToString..등등을 모두 포함하는 편리한 어노테이션입니다. 

## Q 23: @Builder 어노테이션의 역할은 무엇인가요?  
### A : 빌더 패턴을 자동으로 생성해주는 어노테이션으로, 메서드 체이닝 기법으로 객체를 생성하여 필요한 필드만 선택적으로 설정할 수 있어 객체 생성이 유연해집니다.  

## Q 24: 데이터베이스의 테이블명이나 컬럼명이 Java 클래스나 필드명과 다를 경우 어떻게 처리하나요? 
### A : @Table,@Column의 name속성을 사용하며 명시적으로 지정할 수 있습니다.

## Q 25: @Component, @Service, @Repository, @Controller는 어떤 차이가 있나요? 
### A : @Service, @Repository, @Controller 모두 @Component에 포함되자만 각 계층의 역할을 명확히 하기 위한 구분합니다. @Controller는 사용자의 요청을 받는 프레젠테이션 계층, @Service는 비즈니스를 담당하는 비즈니스 로직 계층, @Repository는 데이터베이스에 접근하는 데이터 엑세스 계층입니다.

## Q 26:  Repository 인터페이스에 @Repository를 붙이는데 인터페이스인데 어떻게 빈 객체가 생성되나요?
### A : Spring이 @Repository가 붙은 인터페이스를 발견하면 해당 인터페이스를 분석하여 프록시 객체를 자동으로 생성하고 빈으로 등록합니다. 이후 다른 곳에서 의존성 주입을 요청하면 이 프록시 객체가 주입됩니다.  

## Q 27: CrudRepository를 상속받으면 어떤 이점이 있나요?
### A : 기본적인 CRUD 기능을 사용할 수 있고, 메서드 이름 기반으로 쿼리를 자동생성 해주는 기능도 사용할 수 있습니다.

## Q 28:  ApplicationRunner 인터페이스는 왜 사용하나요?
### A : ApplicationRunner를 구현한 빈의 run 메서드는 애플리케이션 시작 직후 자동으로 실행되어 초기 데이터 삽입, 시스템 초기화 작업 등을 수행할 수 있습니다. 

## Q 29:  Optional은 무엇이고 왜 사용하나요?
### A : Optional은 값이 있을수도 있고 없을 수도 있는 객체입니다. null을 직접 다루지 않아서 NullPointerException을 방지할 수 있습니다.

## Q 30:  Spring Data JDBC의 한계와 단점은 무엇인가요? 
### A : 크게 두가지 한계가 있습니다. 첫째로 복잡한 엔터티 간의 연관관계를 표현하기 어렵습니다. 둘째로 DDL 자동 생성 기능이 없어서 엔터티에 필드를 추가해도 데이터베이스의 테이블 구조가 자동으로 변경되지는 않습니다.

## Q 31: MyBatis는 무엇이고 왜 등장했나요? 
### A : MyBatis는 SQL 중심으로 데이터베이스와 Java객체를 매핑하는 프레임워크입니다. Spring Data JDBC는 복잡한 동적 쿼리 작성이 어렵지만, Mybatis는 SQL문을 XML 파일로 분리하여 가독성과 재사용성을 높이고 동적 쿼리도 쉽게 작성할 수 있습니다.   

## Q 32:  H2 Database는 무엇이고 어떤 특징이 있나요?
### A : H2는 애플리케이션에 내장되는 메모리 기반 데이터베이스입니다. 애플리케이션이 실행되면 메모리에 생성되고 종료되면 초기화되기 때문에 테스트 환경에서 사용됩니다.

## Q 33: JPA와 ORM에 대해 설명해주세요. 
### A : JPA는 Java Persistence API의 약자로 ORM을 통해 자바 객체와 데이터베이스를 매핑하는 표준 인터페이스입니다. 기존에는 데이터베이스 테이블 중심이었다면 JPA는 자바 객체를 중심으로 설계하고 객체의 상태를 자동으로 관리해줍니다.

## Q 34:JPA, Hibernate, Spring Data JPA의 관계를 설명해주세요.  
### A :JPA는 ORM 표준 인터페이스이고, 이 JPA를 구현한 것이 Hibernate이며, Spring Data JPA는 Hibernate를 스프링 환경에서 더욱 쉽게 사용할 수 있는 프레임워크입니다.

## Q 35:spring.jpa.hibernate.ddl-auto의 주요 옵션을 설명해주세요.  
### A :create는 애플리케이션 시작 시 기존 데이터베이스 테이블을 모두 삭제하고 @Entity 클래스를 기반으로 새로 테이블을 생성합니다. update는 기존 테이블을 유지하면서변경된 부분만 반영합니다. none은 DDL 작업을 수행하지 않습니다.   

## Q 36:  @Entity 어노테이션은 무엇인가요?
### A : @Entity가 붙은 클래스가 데이터베이스 테이블과 매핑되는 언테티임을 선언하는 것이며, 이 클래스를 토대로 테이블을 생성해줍니다. 또  엔터티 객체 자체가 하나의 레코드를 의미하며, 이 객체의 상태을 자동으로 관리해줍니다.

## Q 37:   @Table과 @Entity의 차이점은 무엇인가요?
### A : @Table은 Spring data JDBC에서 사용되는 어노테이션으로 데이터를 담는 그릇 역할을 합니다. @Entity는 JPA에서 사용하는 어노테이션으로 그릇 역할을 하면서 동시에 엔터티 객체 자체가 레코드를 의미하고 생명을 가집니다. 엔터티의 상태가 변경되면 자동으로 감지해주고, 데이터베이스에 반영해주는 영속성 컨텍스트 관리 대상이 됩니다. 

## Q 38:  @Transient 어노테이션은 언제 사용하나요?
### A : @Transient 어노테이션은 해당 필드를 데이터베이스 매핑에서 제외시킬 때 사용되며, 단순히 메모리에서만 사용할 필드로 사용됩니다.

## Q 39:JPA Auditing이 무엇인가요?  
### A : JPA Auditing은 리스너 패턴으로, 엔터티 객체 특정 이벤트가 발생하며 미리 정의된 액션을 수행하는 매커니즘입니다. 저의 프로젝트에서는 게시글의 생성과 수정 이벤트가 발생하면 그 시간을 기록하도록 사용하였습니다.   

## Q 40:  Sort,Pageable,Example 객체를 각각 언제 사용하는지 설명해주세요.
### A :Sort 객체를 사용하며 쿼리 매서드의 매개변수로 넘겨 동적으로 정렬 조건을 설정할 수 있습니다. Pageable 객체를사용하여 페이지 단위로 데이터를 나누어 조회할 수 있습니다. Example 객체를 사용하여 검색 조건이 담긴 엔터티 객체를 사용하여 동적으로 검색 조건을 조합할 수 있습니다. 

## Q 41:  JPQL이 무엇인가요?
### A : JPQL은 Java Persistence Query Language로 SQL과 유사하지만 데이터베이스 테이블이 아닌 자바 엔터티 객체를 대상으로 작성하는 쿼리문입니다. @Entity가 붙은 클래스명을 사용해야하고, 별칭을 반드시 지정해줘야 합니다.

## Q 42: @Transactional 어노테이션이 무엇을 의미하나요?  
### A : @Transactional 어노테이션이 붙은 범위는 하나의 영속성 컨텍스트로 관리됩니다. 그래서 트랜잭션이 시작되면 영속성 컨텍스트가 생성되고, 트랜잭션이 종료되면 영속성 컨텍스트에 있는 엔터티 객체의 변경 사항을 감지하여 데이터베이스에 반영합니다.

## Q 43: 영속성 컨텍스트가 무엇이고 주요 특징을 설명해주세요.  
### A : 영속성 컨텍스트는 애플리케이션과 데이터베이스 사이에서 엔터티 객체를 관리하는 논리적인 영역입니다. 주요 특징으로는 엔터티를 조회할 때 1차 캐시 역할을 하여 데이터베이스의 접근을 줄입니다. 둘째 엔터티 객체의 상태 변화를 자동으로 감지하여, 쓰기 지연을 통해 트랜잭션이 끝날 때 데이터베이스에 한번에 반영합니다. 마지막으로 같은 트랜잭션 내에서 같은 id로 조회한 엔터티 객체는 동일한 인스턴스임을 보장합니다.

## Q 44:@Query (update ,delete)를 사용할 때 왜 @Modifying과 @Transactional을 함께 사용해야 하나요?  
### A : @Query를 사용한 벌크 연산은 영속성 컨텍스트를 거치지 않고 데이터베이스에 직접 쿼리를 수행하기 때문에 2가지문제가 발생합니다. 첫번째로 영속성 컨텍스트와 데이터베이스간의 데이터 불일치 문제입니다. 그래서 Modifying을 통해 쿼리 실행 전후로 영속성 컨텍스트를 관리하여 최신 상태를 보장합니다. 두번째로 데이터 변경으로 인한 데이터 무결성 문제입니다. 이는 Transactional를 통해 데이터 무결성을 보장해줍니다. 

## Q 45:@Modifying의 flushAutomatically와 clearAutomatically 옵션을 설명해주세요.  
### A : flushAutomatically는 쿼리 수행 전에 영속성 컨텍스트에 있는 변경 사항을 데이터베이스에 먼저 반영하여 데이터 누락을 방지하는 것이고, clearAutomatically는 쿼리 수행 후에 영속성 컨텍스트를 초기화하여 최신 데이터를 읽어오도록 하는 것입니다. 

## Q 46:JPA에서 연관관계 매핑 시 @ToString.Exclude와 @JsonIgnore를 사용하는 이유는 무엇인가요?  
### A : 연관 관계 필드로 부터 발생하는 무한 루프를 방지 하기 위함입니다. @ToString.Exclude을 통해 해당 필드를 출력 대상으로부터 제외시키고,  @JsonIgnore을 통해 해당 필드를 직렬화 대상으로부터 제외시킵니다.

## Q 47:@OneToMany, @ManyToOne 등의 기본 로딩 전략은 무엇인가요?  
### A :뒤에 Many로 끝나면 Lazy 지연 로딩 전략이고, One으로 끝나면 Eager 즉시 로딩 전략입니다. 

## Q 48:QueryDSL이 무엇이고 왜 등장했나요?  
### A : QueryDSL은 자바 코드를 기반으로 타입 안전한 쿼리를 작성할 수 있게 해주는 프레임워크입니다. JPA의 @Query 어노테이션을 사용하면 오타를 컴파일 시점에서 잡을 수 없지만, QueryDSL을 사용하면 매서드 체이닝 방식으로 쿼리를 작성하여 컴파일 시점에서 오류를 잡을 수 있습니다.

## Q 49:  Q클래스가 무엇인가요?
### A : Q클래스는 @Entity가 붙은 엔터티 클래스를 기반으로 자동 생성되는 쿼리 전용 클래스이며, 싱글톤 인스턴스를 제공합니다. 이 Q클래스를 통해 타입 안전하게 쿼리를 작성할 수 있습니다. 

## Q 50:  JPAQueryFactory가 무엇이고 왜 EntityManager를 매개변수로 받나요?
### A : JPAQueryFactory는 QueryDSL 쿼리를 JPQL쿼리로 변환하고 실행하는 엔진입니다. JPQL 쿼리를 실제 데이터베이스에 실행하려면 EntityManager 이 필요하므로, 매개변수로 받습니다.

## Q 51:학습 과정에서 단순히 최신 기술만 배운 것이 아니라, 기술의 발전 과정을 이해했다고 하셨는데 구체적으로 어떤 방식으로 학습하셨나요?  
### A : 저는 스프링부트를 학습할 때 최신 기술을 바로 학습하는 것이 아니라, 이 기술이 왜 등장했고 이전에는 어떤 불편함이 있는지를 파악하며 공부했습니다. 예를들어 스프링부트에서 데이터베이스를 연동할 때 JDBC를 직접 사용하여 반복되는 코드와 수동 매핑의 불편함을 경험한 후 Spring data JDBC로 이를 어떻게 해결하는지 학습하였고, 또 Spring data JDBC의 연관관계 표현의 어려움과 DDL 자동 생성 미지원 등의 문제를 겪어보고 JPA에서이를 어떻게 개선했는지를 이해했습니다.       

## Q 52:  Spring Bean의 생명주기(Life Cycle)에 대해 설명해주세요.
### A : 스프링 컨테이너가 생성되면 빈을 등록합니다. 그리고 빈들 간의 의존관계를 주입하고, 초기화 콜백 메서드를 호출하여 빈을 사용가능한 상태로 만듭니다. 이후 스프링 컨테이너가 종료되기직전 소멸 전 콜백 매서드를 호출하여 리소스 정리 등의 작업을 수행하여 빈이 소멸됩니다.  


## Q 53: N+1 문제가 무엇이고, 어떻게 해결하나요?  
### A :   N+1은 연관관계가 있는 언터티를 1번 조회할 때, 연관 테이블을 추가로 N번 조회하여 성능을 저하시키는 문제입니다. 이를 해결하기 위해서는 JPQL문에서 Fetch Join을 사용하여 하나의 쿼리로 연관된 엔터티를 한번에 조회합니다. 

## Q 54:Spring Boot 애플리케이션을 만드는 방법은 무엇인가요?  
### A : Spring Initializr 웹사이트를 통해 프로젝트 메타 정보와 필요한 의존성을 선택하여 만들 수 있습니다.  

## Q 55:CrudRepository와 JpaRepository의 차이점은 무엇인가요?  
### A : CrudRepository는 기본적은 CRUD기능을 제공하는 기본 인터페이스이며, JpaRepository는 CrudRepository를 상속받고추가로 JPA 관련 기능을 제공해줍니다. 

## Q 56:Spring Bean Scope란 무엇인가요?  
### A : 스프링 컨테이너 내에서 빈이 존재할 수 있는 범위를 말합니다. 기본값은 singleton이며, singleton은 스프링 컨테이너가 시작될 때 빈 객체를 미리 만들어놓고, 이후 주입 요청이 오면 미리 만들어 놓은 같은 빈 객체를 공유합니다. 반면 prototype은 컨테이너 시작 시점에서는 객체를 생성하지 않고, 주입 요청할 때마다 새로운 객체를 생성하여 반환해줍니다.   

## Q 57:Spring Boot Starter란 무엇인가요?  
### A : Spring Boot Starter는 특정 기능을 사용하기 위해 필요한 의존성들을 모아놓은 의존성 묶음입니다. 이를 사용함으로써 버전 충돌을 방지할 수 있고, 복잡한 의존성 설정을 간소화할 수 있습니다.  

## Q :  
### A :   
