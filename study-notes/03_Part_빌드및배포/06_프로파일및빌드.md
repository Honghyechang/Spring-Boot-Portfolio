# 06_프로파일및빌드

<!--
# 첫 작성 
docs: [Ch06] 프로파일및빌드 - 틀작성완료
-->

## 📌 학습 목표

애플리케이션의 실행 환경에 따라 설정 파일을 분리하는 방법을 학습하고, 개발(Development), 테스트(Test), 운영(Production) 환경에 맞는 구성을 적용해봅니다. 환경별 설정을 유연하고 효율적으로 관리하는 능력을 키우고, JAR 또는 WAR 파일로 애플리케이션을 패키징하는 과정을 통해 실전 배포를 위한 준비 역량을 강화합니다.

---

## 목차

- [6.1 애플리케이션 프로파일](#61-애플리케이션-프로파일)
- [6.2 애플리케이션 빌드](#62-애플리케이션-빌드)

---

## 6.1 애플리케이션 프로파일

### 6.1.1 프로파일이란?

애플리케이션은 **개발(Dev)**, **테스트(Test)**, **운영(Production)** 등 다양한 환경에서 실행됩니다. 각 환경마다 데이터베이스 URL, 서버 포트, 로깅 레벨 등 서로 다른 설정이 필요합니다. 

**프로파일(Profile)**은 이러한 환경별 설정을 선택적으로 적용할 수 있게 해주는 스프링 부트의 핵심 기능입니다. 프로파일을 사용하면:

- 환경이 바뀔 때마다 설정 파일을 수동으로 수정할 필요가 없습니다
- 이미 배포한 JAR/WAR 파일에서 **실행 시점에** 환경변수나 실행 옵션을 통해 설정 파일을 선택할 수 있습니다
- 하나의 빌드 결과물로 여러 환경에 유연하게 배포할 수 있습니다

### 6.1.2 프로파일 파일 구조

프로파일별 설정 파일은 `application-{프로파일이름}.properties` 형식으로 작성합니다.

#### 기본 구조

```
src/main/resources/
├── application.properties              # 공통 설정
├── application-dev.properties          # 개발 환경 설정
├── application-prod.properties         # 운영 환경 설정
├── schema-h2.sql                       # H2용 스키마
├── schema-mysql.sql                    # MySQL용 스키마
├── data-h2.sql                         # H2용 초기 데이터
└── data-mysql.sql                      # MySQL용 초기 데이터
```

#### application.properties (공통 설정)

```properties
spring.application.name=applicationProfileSample

# 기본 활성화 프로파일 (외부에서 지정하지 않을 경우 사용)
spring.profiles.active=dev

# SQL 초기화 설정
spring.sql.init.mode=always
spring.sql.init.encoding=utf-8
```

#### application-dev.properties (개발 환경)

```properties
# 개발 환경에서는 H2 인메모리 데이터베이스를 사용
spring.datasource.url=jdbc:h2:mem:demo
spring.h2.console.enabled=true

# H2용 SQL 스크립트 사용
spring.sql.init.platform=h2
```

#### application-prod.properties (운영 환경)

```properties
# 운영 환경에서는 외부 MySQL 데이터베이스를 사용
spring.datasource.url=jdbc:mysql://localhost:3306/demo
spring.datasource.username=user
spring.datasource.password=password

# MySQL용 SQL 스크립트 사용
spring.sql.init.platform=mysql
```

### 6.1.3 환경별 SQL 스크립트 분리

데이터베이스 종류가 환경별로 다른 경우, SQL 문법 차이로 인해 스크립트를 분리해야 합니다.

**`spring.sql.init.platform` 속성**을 사용하면 스프링 부트가 자동으로 해당 플랫폼에 맞는 스크립트를 찾아 실행합니다:

- `spring.sql.init.platform=h2` → `schema-h2.sql`, `data-h2.sql` 실행
- `spring.sql.init.platform=mysql` → `schema-mysql.sql`, `data-mysql.sql` 실행

> **참고**: 플랫폼 이름은 개발자가 자유롭게 정의할 수 있습니다. `h2`, `mysql`은 관례적으로 사용되는 이름일 뿐이며, `spring.sql.init.platform=custom`으로 지정하면 `schema-custom.sql` 파일을 찾습니다.

### 6.1.4 프로파일 활성화 방법

프로파일을 활성화하는 방법은 크게 두 가지이며, **우선순위**는 다음과 같습니다:

**프로그램 실행 옵션 > 운영체제 환경변수 > application.properties**

#### 1) 프로그램 실행 옵션 (최고 우선순위)

JAR 파일 실행 시 `--` 옵션으로 프로파일을 지정합니다:

```bash
# 기본 사용법
java -jar demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod

# 복수 프로파일 활성화
java -jar demo-0.0.1-SNAPSHOT.jar --spring.profiles.active=prod,health

# 변수를 통한 간접 지정
java -jar demo-0.0.1-SNAPSHOT.jar --profilesMode=prod
```

**변수를 통한 간접 지정** 방식은 `application.properties`에 다음과 같이 설정되어 있을 때 사용합니다:

```properties
profilesMode=dev
spring.profiles.active=${profilesMode}
```

**IntelliJ IDEA 설정:**
- `Run/Debug Configurations` → `Program Arguments`에 `--spring.profiles.active=prod` 입력
- 또는 `VM Options`에 `-Dspring.profiles.active=prod` 입력

#### 2) 운영체제 환경변수

**환경변수 명명 규칙**: 스프링 부트는 다음 규칙으로 속성과 환경변수를 매핑합니다:
- `.`와 `-`를 `_`로 변경
- 소문자를 대문자로 변경

| 프로퍼티 속성 | 환경변수 이름 |
|-------------|-------------|
| `spring.profiles.active` | `SPRING_PROFILES_ACTIVE` |
| `spring.jpa.hibernate.ddl-auto` | `SPRING_JPA_HIBERNATE_DDL_AUTO` |

**운영체제별 환경변수 설정:**

```bash
# Linux/macOS (Bash/Zsh)
export SPRING_PROFILES_ACTIVE=prod
java -jar demo-0.0.1-SNAPSHOT.jar

# Windows Command Prompt
set SPRING_PROFILES_ACTIVE=prod
java -jar demo-0.0.1-SNAPSHOT.jar

# Windows PowerShell
$Env:SPRING_PROFILES_ACTIVE='prod'
java -jar demo-0.0.1-SNAPSHOT.jar
```

### 6.1.5 고급 프로파일 활용

#### 복수 프로파일 활성화

여러 프로파일을 동시에 활성화하여 설정을 모듈화할 수 있습니다:

```properties
spring.profiles.active=prod,health
```

- `prod`: 데이터베이스 연결 등 기본 환경 설정
- `health`: 모니터링, 헬스체크 관련 설정

**충돌 시 우선순위**: 동일한 속성이 여러 프로파일에 정의된 경우, 나중에 명시된 프로파일의 값이 우선 적용됩니다.

#### 하나의 파일에서 복수 개의 프로파일 설정

`application.properties` 파일 하나에 여러 프로파일을 정의할 수 있습니다:

```properties
spring.application.name=applicationProfileSample

spring.profiles.active=dev
spring.sql.init.mode=always
spring.sql.init.encoding=utf-8

#---
spring.config.activate.on-profile=dev
spring.database.url=jdbc:h2:mem:demo
spring.h2.console.enabled=true
spring.sql.init.platform=h2

#---
spring.config.activate.on-profile=prod
spring.datasource.url=jdbc:mysql://localhost:3306/demo
spring.datasource.username=user
spring.datasource.password=password
spring.sql.init.platform=mysql
```

### 6.1.6 배포 플랫폼별 프로파일 설정

실제 배포 환경에서는 플랫폼의 특성에 맞게 환경변수를 주입합니다:

| 배포 플랫폼 | 설정 방법 | 예시 |
|-----------|---------|-----|
| **Linux 서버** | 셸 환경변수 | `export SPRING_PROFILES_ACTIVE=prod` |
| **Docker** | `-e` 옵션 | `docker run -e SPRING_PROFILES_ACTIVE=prod app:latest` |
| **Kubernetes** | Deployment YAML | `env: - name: SPRING_PROFILES_ACTIVE value: prod` |

**핵심**: 애플리케이션 코드나 빌드 결과물을 수정하지 않고, **외부 환경에서 설정을 제어**하는 것이 프로파일의 가장 큰 장점입니다.

---

## 6.2 애플리케이션 빌드

### 6.2.1 JAR vs WAR

스프링 부트 애플리케이션은 두 가지 형태로 패키징할 수 있습니다:

| 형식 | 특징 | 실행 방법 | 사용 목적 |
|-----|------|----------|---------|
| **JAR** | 내장 톰캣 포함, 독립 실행 | `java -jar app.jar` | 클라우드, 컨테이너 배포 |
| **WAR** | 내장 톰캣 제외, 서블릿 컨테이너 필요 | 외부 WAS에 배포 | 레거시 WAS 환경 |

### 6.2.2 Spring Initializr의 Packaging 옵션 의미

**중요**: Spring Initializr에서 선택하는 Packaging 옵션은 **최종 배포 방식의 주 목적**을 나타냅니다.

| 선택 옵션 | 빌드 결과 | 의미 |
|---------|---------|-----|
| **JAR 선택** | `bootJar`만 활성화 | **단독 실행만** 지원. WAR 배포를 원하면 추가 설정 필요 |
| **WAR 선택** | `bootJar`와 `war` 모두 활성화 | **WAR 배포를 주 목적**으로 하되, 개발 편의를 위해 JAR 실행도 가능 |

**결론**:
- **WAR 선택** = WAR 배포 가능 + JAR 배포 가능
- **JAR 선택** = JAR 배포만 가능 (WAR는 별도 설정 필요)

### 6.2.3 JAR에서 WAR로 전환 (실전)

#### 전환이 필요한 경우

- 회사의 기존 WAS(WebLogic, JBoss 등) 환경에 배포해야 하는 경우
- 보안 정책상 외부 WAS를 사용해야 하는 경우
- 여러 애플리케이션을 동일한 WAS에서 관리해야 하는 경우

#### 전환 과정 (Gradle 기준)

**1단계: `build.gradle`에 `war` 플러그인 추가**

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.7'
    id 'io.spring.dependency-management' version '1.1.7'
    id 'war'  // WAR 빌드 태스크 활성화
}
```

**2단계: 내장 톰캣을 `providedRuntime`으로 변경**

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6'
    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    runtimeOnly 'com.h2database:h2'
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
    
    // 내장 톰캣을 WAR에 포함하지 않음 (외부 WAS가 제공)
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
}
```

**`providedRuntime`의 역할**:
- **컴파일/개발 시**: 내장 톰캣을 사용하여 `bootRun` 실행 가능
- **WAR 패키징 시**: 내장 톰캣을 제외하여 외부 WAS와의 충돌 방지

**3단계: `ServletInitializer` 클래스 추가**

외부 WAS는 `main()` 메서드가 아닌 서블릿 표준에 따라 애플리케이션을 초기화합니다. 이를 위해 **진입점 클래스**가 필요합니다.

```java
package com.example.Spring.Board.Project;

import org.springframework.boot.builder.SpringApplicationBuilder;
import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;

public class ServletInitializer extends SpringBootServletInitializer {
    
    @Override
    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
        // 외부 WAS에게 스프링 부트 애플리케이션의 진입점을 알려줌
        return builder.sources(SpringBoardProjectApplication.class);
    }
}
```

**동작 원리**:
1. 외부 WAS가 WAR 파일을 로드
2. WAS가 `ServletInitializer`를 찾아 `configure()` 메서드 호출
3. 스프링 부트 애플리케이션 컨텍스트 초기화 및 실행

### 6.2.4 빌드 및 실행

#### Gradle 빌드 태스크

**JAR 파일 생성 (실행 가능)**:
```bash
./gradlew bootJar
```

**출력 결과**:
```
> Task :compileJava
> Task :processResources UP-TO-DATE
> Task :classes
> Task :resolveMainClassName
> Task :bootJar
BUILD SUCCESSFUL in 19s
```

**WAR 파일 생성 (외부 WAS 배포용)**:
```bash
./gradlew war
```

**출력 결과**:
```
> Task :compileJava UP-TO-DATE
> Task :processResources UP-TO-DATE
> Task :classes UP-TO-DATE
> Task :war
BUILD SUCCESSFUL in 9s
```

#### 빌드 결과 확인

```bash
C:\...\build\libs> dir

2025-11-12  오후 02:22    50,577,654 Spring-Board-Project-0.0.1-SNAPSHOT-plain.war
2025-11-12  오후 02:21    61,016,801 Spring-Board-Project-0.0.1-SNAPSHOT.jar
```

- **`.jar`**: 내장 톰캣 포함, 단독 실행 가능
- **`-plain.war`**: 내장 톰캣 제외, 외부 WAS 배포용

#### JAR 파일 실행

```bash
java -jar Spring-Board-Project-0.0.1-SNAPSHOT.jar
```

**실행 결과**:
```
  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v3.5.7)
```

애플리케이션이 정상적으로 실행됩니다. 이 JAR 파일을 다른 서버(가상 머신, 클라우드 등)에서 실행하면, 해당 서버에서 애플리케이션에 접근할 수 있습니다. **이것이 바로 배포의 핵심 개념입니다**.

### 6.2.5 Gradle 태스크 비교

| 태스크 | 파일 형식 | 실행 가능성 | 사용 목적 |
|-------|---------|----------|---------|
| `jar` | 표준 JAR | ❌ | 라이브러리 패키징 (실행 불가) |
| `bootJar` | 실행 가능 JAR | ✅ | 단독 실행형 애플리케이션 (내장 WAS 포함) |
| `war` | 표준 WAR | ❌ | 외부 WAS 배포 전용 (내장 WAS 제외) |
| `bootWar` | 실행 가능 WAR | ✅ | 단독 실행 + 외부 WAS 배포 모두 지원 |

**권장 사항**:
- **JAR 배포**: `bootJar` 사용
- **외부 WAS 배포**: `war` 사용
- `bootWar`는 특수한 경우에만 사용

### 6.2.6 개발 vs 배포 워크플로

**개발 환경 (빠른 테스트)**:
```bash
# 내장 톰캣으로 즉시 실행
./gradlew bootRun

# 또는 JAR 생성 후 실행
./gradlew bootJar
java -jar build/libs/app.jar
```

**배포 환경 (운영 WAS)**:
```bash
# WAR 파일 생성
./gradlew war

# 생성된 WAR를 외부 Tomcat/WAS에 배포
# - Tomcat: webapps 디렉터리에 복사
# - WebLogic/JBoss: 관리 콘솔에서 배포
```

**핵심**: `providedRuntime` 설정으로 개발 시에는 내장 톰캣을 사용하고, 배포 시에는 외부 WAS를 사용하는 **하이브리드 전략**을 구현할 수 있습니다.

---


