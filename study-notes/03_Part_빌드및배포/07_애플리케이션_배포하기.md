# 07_애플리케이션_배포하기
<!--
# 첫 작성 
docs: [Ch07] 애플리케이션 배포하기 - 틀작성완료
-->
## 📌 학습 목표
스프링 부트 애플리케이션을 다양한 환경에 배포하는 방법을 익히고, 톰캣을 활용한 전통적인 방식부터 AWS 엘라스틱 빈스토크를 이용한 클라우드 배포, 도커를 활용한 컨테이너 기반 배포, 그리고 GitHub Actions를 통한 CI/CD 자동화까지 모두 아우르는 실전 배포 전략을 체계적으로 학습합니다.

---

## 📚 배포 학습 로드맵

이 챕터는 배포 기술의 진화 과정을 따라가며, 각 단계에서 발생하는 문제점을 인식하고 이를 해결하는 더 나은 방법을 학습하는 방식으로 구성되어 있습니다.

### 🎯 단계별 학습 개요

| 단계 | 환경/도구 | 배포 대상 | 학습 목표 |
|------|-----------|-----------|-----------|
| **1단계** | EC2 (IaaS) | WAR 및 JAR | IaaS 환경에서의 수동 배포 경험. Java, Tomcat 수동 설치 및 설정을 통해 인프라 관리의 복잡성을 체감 |
| **2단계** | Elastic Beanstalk (PaaS) | WAR 및 JAR | PaaS의 편리함 체감. 인프라 자동 관리를 통해 개발자가 애플리케이션에 집중할 수 있는 환경 이해 |
| **3단계** | Docker + Beanstalk | JAR (컨테이너화) | 환경 표준화 및 이식성 확보. Docker를 통한 "어디서나 동일하게 실행되는" 애플리케이션 구축 |
| **4단계** | GitHub Actions + Docker + Beanstalk | JAR (컨테이너화) | CI/CD 파이프라인 자동화. 코드 push만으로 빌드-테스트-배포까지 자동 실행되는 실무 환경 구축 |

---

## 목차
- [7.1 톰캣 배포 (IaaS 환경 실습)](#71-톰캣-배포-iaas-환경-실습)
- [7.2 AWS 클라우드 배포 (PaaS 환경 실습)](#72-aws-클라우드-배포-paas-환경-실습)
- [7.3 도커 배포 (환경 표준화)](#73-도커-배포-환경-표준화)
- [7.4 CI/CD 자동화 (GitHub Actions)](#74-cicd-자동화-git-actions)
---

# 7.1 톰캣 배포 (IaaS 환경 실습)

## 📖 학습 개요

**핵심 주제**: IaaS(Infrastructure as a Service) 환경에서의 수동 배포  
**사용 기술**: Apache Tomcat, AWS EC2, WAR/JAR 파일  
**학습 목표**: 
- WAR와 JAR 파일의 차이점과 배포 방식 이해
- 서버 환경을 처음부터 수동으로 구축하고 관리하는 전 과정 체험
- IaaS 환경의 복잡성과 운영 부담 실감

---

## 7.1.1 Apache Tomcat 기본 개념

### 🔍 Tomcat이란?

Apache Tomcat은 Java 서블릿(Servlet)과 JSP(JavaServer Pages)를 실행할 수 있는 **WAS(Web Application Server)**이자 **서블릿 컨테이너**입니다.

### 📦 WAR vs JAR

| 구분 | WAR (Web Application Archive) | JAR (Java Archive) |
|------|-------------------------------|-------------------|
| **용도** | 외부 WAS(Tomcat 등)에 배포 | 독립 실행 가능한 애플리케이션 |
| **WAS** | 외부 Tomcat 필요 | Tomcat 내장 (Embedded) |
| **배포 방식** | WAS의 webapps 디렉터리에 복사 | `java -jar` 명령으로 직접 실행 |
| **컨텍스트 경로** | 파일명이 컨텍스트 경로가 됨 | 기본 루트(/) 경로 |

---

## 7.1.2 로컬 환경에서 Tomcat 실습

### 1단계: Tomcat 다운로드 및 설치

#### 다운로드

[Apache Tomcat 10 다운로드 페이지](https://tomcat.apache.org/download-10.cgi)에서 **Core: zip** 파일을 다운로드합니다.

```
다운로드 파일: apache-tomcat-10.1.49.zip
압축 해제 위치: C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\
```

#### 📂 Tomcat 디렉터리 구조

압축을 해제하면 다음과 같은 핵심 디렉터리 구조를 확인할 수 있습니다.

```
C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\apache-tomcat-10.1.49
├── bin/          ⚙️ 실행 및 종료 스크립트
├── conf/         📝 설정 파일 (server.xml, web.xml 등)
├── lib/          📚 라이브러리 파일
├── logs/         📜 로그 파일 저장소
├── temp/         🗂️ 임시 파일
├── webapps/      📦 웹 애플리케이션 배포 위치
└── work/         🔧 JSP 컴파일 결과물
```

**핵심 디렉터리 설명**

| 디렉터리 | 역할 | 주요 내용 |
|----------|------|-----------|
| **bin** | 실행 스크립트 모음 | `startup.sh/bat`, `shutdown.sh/bat`, `catalina.sh/bat` |
| **conf** | 톰캣 설정 | `server.xml` (포트, 호스트 설정), `web.xml` (서블릿 기본 설정) |
| **webapps** | 애플리케이션 배포 | WAR 파일을 이곳에 복사하면 자동 배포됨 |
| **logs** | 로그 기록 | `catalina.out` (서버 로그), `localhost_access_log.txt` (접근 로그) |

---

### 2단계: Tomcat 실행 준비

#### ✅ Java 환경 변수 설정

Tomcat은 Java로 만들어진 프로그램이므로 JVM이 필요합니다. 따라서 `JAVA_HOME` 환경 변수를 설정해야 합니다.

**Windows 명령 프롬프트에서 환경 변수 설정**

```cmd
C:\...\apache-tomcat-10.1.49> set JAVA_HOME=C:\Program Files\Eclipse Adoptium\jdk-21.0.8.9-hotspot
C:\...\apache-tomcat-10.1.49> set CATALINA_HOME=C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\apache-tomcat-10.1.49
```

**환경 변수 설명**

| 변수명 | 역할 | 설정 예시 |
|--------|------|-----------|
| `JAVA_HOME` | JDK 설치 경로 지정 | `C:\Program Files\Eclipse Adoptium\jdk-21.0.8.9-hotspot` |
| `CATALINA_HOME` | Tomcat 설치 루트 경로 지정 | `C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\apache-tomcat-10.1.49` |

#### 🌐 한글 깨짐 방지 설정

콘솔 로그에서 한글이 깨지지 않도록 UTF-8 인코딩을 설정합니다.

```cmd
C:\...\bin> chcp 65001
Active code page: 65001
```

---

### 3단계: Tomcat 실행 명령어

#### 🚀 서버 시작 및 종료 명령어

| 목적 | Windows | Linux/macOS | 실행 방식 | 용도 |
|------|---------|-------------|-----------|------|
| **서버 시작** | `startup.bat` | `startup.sh` | 백그라운드 | 일반 운영 환경 |
| **서버 시작** | `catalina.bat run` | `catalina.sh run` | 포그라운드 | 디버깅 및 테스트 (로그 실시간 확인) |
| **서버 종료** | `shutdown.bat` | `shutdown.sh` | - | 서버 정상 종료 |

**실행 예시**

```cmd
C:\...\bin> catalina run
```

이 명령을 실행하면 Tomcat 서버가 시작되고 콘솔에 실시간 로그가 출력됩니다.

---

### 4단계: WAR 파일 배포

#### 📦 WAR 파일 준비 및 배포

Spring Boot 프로젝트에서 빌드한 WAR 파일을 Tomcat의 `webapps` 디렉터리에 복사하기만 하면 자동으로 배포가 시작됩니다.

**중요: 파일명 = 컨텍스트 경로**

WAR 파일의 이름이 매우 중요합니다. 파일명이 **애플리케이션의 컨텍스트 경로**가 되기 때문입니다.

| 파일명 | 접속 URL | 설명 |
|--------|----------|------|
| `hyechang.war` | `http://localhost:8080/hyechang/` | `/hyechang` 컨텍스트로 접근 |
| `ROOT.war` | `http://localhost:8080/` | 루트(`/`) 경로로 접근 |

**배포 디렉터리 구조**

```
C:\...\apache-tomcat-10.1.49\webapps\
├── ROOT/                    (기본 홈페이지)
├── docs/                    (Tomcat 문서)
├── examples/                (예제 앱)
├── manager/                 (관리자 페이지)
├── hyechang.war            ✅ 복사한 WAR 파일
└── ROOT.war                ✅ 루트 경로 배포용
```

**배포 실행**

```cmd
C:\...\webapps> dir

2025-11-14  오전 11:50    <DIR>          .
2025-11-14  오전 11:07    <DIR>          ..
2025-11-14  오전 11:07    <DIR>          docs
2025-11-14  오전 11:07    <DIR>          examples
2025-11-12  오후 02:22        50,577,654 hyechang.war
2025-11-14  오전 11:07    <DIR>          manager
2025-11-14  오전 11:07    <DIR>          ROOT
2025-11-12  오후 02:22        50,577,654 ROOT.war
```

Tomcat 서버가 실행 중이라면 자동으로 WAR 파일의 압축을 풀고 애플리케이션을 배포합니다.

**접속 확인**

- `http://localhost:8080/hyechang/` → hyechang.war 애플리케이션 실행
- `http://localhost:8080/` → ROOT.war 애플리케이션 실행

---

### 💡 로컬 환경 실습 정리

로컬 PC에서 Tomcat을 설치하고 WAR 파일을 배포하는 과정을 통해:
- ✅ Tomcat의 디렉터리 구조와 역할 이해
- ✅ WAR 파일 배포의 기본 원리 학습
- ✅ 컨텍스트 경로의 개념 파악

**하지만 실제 웹 서비스 운영을 위해서는 외부에서 접속 가능한 서버가 필요합니다.**

다음 단계에서는 이 모든 과정을 **AWS EC2 인스턴스(클라우드 서버)**에서 직접 구현해봅니다.

---

## 7.1.3 EC2 인스턴스에 WAR 파일 배포

이제 AWS의 가상 서버 환경에서 처음부터 끝까지 수동으로 배포 환경을 구축해봅니다.

### 1단계: EC2 인스턴스 생성

#### AWS 콘솔에서 EC2 인스턴스 생성

| 설정 항목 | 선택 값 | 설명 |
|-----------|---------|------|
| **AMI** | Amazon Linux 2023 | 최신 리눅스 배포판 |
| **인스턴스 타입** | t3.micro | 무료 티어 사용 가능 |
| **키 페어** | springTomcatServer.pem | SSH 접속용 개인 키 (자동 다운로드) |
| **보안 그룹** | 22번 포트 (SSH), 8080번 포트 (Tomcat) 허용 | 외부 접속을 위한 포트 개방 |

**보안 그룹 인바운드 규칙**

| 타입 | 포트 | 소스 | 용도 |
|------|------|------|------|
| SSH | 22 | 0.0.0.0/0 | SSH 터미널 접속 |
| Custom TCP | 8080 | 0.0.0.0/0 | Tomcat 웹 서버 접근 |

인스턴스 생성 후 **퍼블릭 IP**를 확인합니다. (예: `3.38.106.137`)

---

### 2단계: SSH로 EC2 인스턴스 접속

#### 💻 PowerShell에서 SSH 접속

다운로드받은 `.pem` 키 파일을 사용하여 EC2 인스턴스에 원격 접속합니다.

```powershell
PS C:\Users\ghddm> ssh -i "C:\Users\ghddm\Downloads\springTomcatServer.pem" ec2-user@3.38.106.137
```

**접속 과정**

```
The authenticity of host '3.38.106.137 (3.38.106.137)' can't be established.
ED25519 key fingerprint is SHA256:ITRFzyYPw0fMC+tAnuUDDZ+3BxfPAKvaUOYLvgnkGdY.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
```

`yes` 입력 후 연결이 성공하면:

```
   ,     #_
   ~\_  ####_        Amazon Linux 2023
  ~~  \_#####\
  ~~     \###|
  ~~       \#/ ___   https://aws.amazon.com/linux/amazon-linux-2023
   ~~       V~' '->
    ~~~         /
      ~~._.   _/
         _/ _/
       _/m/'
[ec2-user@ip-172-31-0-60 ~]$
```

**✅ SSH 연결 성공!** 이제 EC2 리눅스 서버에서 명령어를 실행할 수 있습니다.

---

### 3단계: JDK 설치

Tomcat을 실행하기 위해서는 Java가 필수입니다.

#### ☕ Amazon Corretto JDK 21 설치

```bash
# 시스템 패키지 업데이트
[ec2-user@ip-172-31-0-60 ~]$ sudo dnf update -y

# JDK 21 설치
[ec2-user@ip-172-31-0-60 ~]$ sudo dnf install java-21-amazon-corretto-devel -y
```

#### 🔧 JAVA_HOME 환경 변수 설정

**JDK 설치 경로 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ readlink -f /usr/bin/java | sed "s:bin/java::"
/usr/lib/jvm/java-21-amazon-corretto.x86_64/
```

**환경 변수 영구 등록**

```bash
# 기존 설정 삭제 (있다면)
[ec2-user@ip-172-31-0-60 ~]$ sed -i '/JAVA_HOME/d' ~/.bashrc
[ec2-user@ip-172-31-0-60 ~]$ sed -i '/PATH=$PATH:$JAVA_HOME/d' ~/.bashrc

# 새로운 JAVA_HOME 설정 추가
[ec2-user@ip-172-31-0-60 ~]$ echo 'export JAVA_HOME="/usr/lib/jvm/java-21-amazon-corretto.x86_64"' >> ~/.bashrc
[ec2-user@ip-172-31-0-60 ~]$ echo 'export PATH=$PATH:$JAVA_HOME/bin' >> ~/.bashrc

# 설정 즉시 적용
[ec2-user@ip-172-31-0-60 ~]$ source ~/.bashrc
```

**설정 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ echo $JAVA_HOME
/usr/lib/jvm/java-21-amazon-corretto.x86_64

[ec2-user@ip-172-31-0-60 ~]$ java -version
openjdk version "21.0.9" 2024-10-15 LTS
OpenJDK Runtime Environment Corretto-21.0.9.10.1 (build 21.0.9+10-LTS)
OpenJDK 64-Bit Server VM Corretto-21.0.9.10.1 (build 21.0.9+10-LTS, mixed mode, sharing)
```

✅ **JDK 설치 및 환경 변수 설정 완료**

---

### 4단계: Tomcat 설치

#### 📥 Tomcat 10.1.49 다운로드 및 설치

```bash
# /opt 디렉터리로 이동 (소프트웨어 설치 표준 위치)
[ec2-user@ip-172-31-0-60 ~]$ cd /opt

# Tomcat 다운로드
[ec2-user@ip-172-31-0-60 opt]$ sudo wget https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.49/bin/apache-tomcat-10.1.49.tar.gz

# 압축 해제
[ec2-user@ip-172-31-0-60 opt]$ sudo tar -xzf apache-tomcat-10.1.49.tar.gz

# 디렉터리 이름 변경 (관리 편의성)
[ec2-user@ip-172-31-0-60 opt]$ sudo mv apache-tomcat-10.1.49 tomcat

# 소유권 변경 (ec2-user가 관리할 수 있도록)
[ec2-user@ip-172-31-0-60 opt]$ sudo chown -R ec2-user:ec2-user tomcat
```

#### 🔧 CATALINA_HOME 환경 변수 설정

```bash
# 홈 디렉터리로 이동
[ec2-user@ip-172-31-0-60 opt]$ cd ~

# CATALINA_HOME 설정 추가
[ec2-user@ip-172-31-0-60 ~]$ echo 'export CATALINA_HOME="/opt/tomcat"' >> ~/.bashrc
[ec2-user@ip-172-31-0-60 ~]$ echo 'export PATH=$PATH:$CATALINA_HOME/bin' >> ~/.bashrc

# 설정 즉시 적용
[ec2-user@ip-172-31-0-60 ~]$ source ~/.bashrc
```

**설정 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ echo $CATALINA_HOME
/opt/tomcat
```

✅ **Tomcat 설치 및 환경 변수 설정 완료**

---

### 5단계: WAR 파일 전송

이제 로컬 PC에서 빌드한 WAR 파일을 EC2 서버로 전송합니다.

#### 📤 SCP를 이용한 파일 전송

**로컬 PowerShell에서 실행** (SSH 터미널이 아님!)

```powershell
PS C:\Users\ghddm> scp -i "C:\Users\ghddm\Downloads\springTomcatServer.pem" "C:\Users\ghddm\Desktop\SpringBoot\Spring-Boot-Portfolio\spring-boot-project\Spring-Board-Project\build\libs\Spring-Board-Project-0.0.1-SNAPSHOT-plain.war" ec2-user@3.38.106.137:/tmp/hyechang.war
```

**전송 과정 확인**

```
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war   0%    0     0.0KB/s   --:--
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war   2% 1056KB   1.0MB/s   00:46
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war   4% 1984KB   1.0MB/s   00:46
...
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war 100%   48MB 873.6KB/s   00:56
```

✅ **파일 전송 완료**

---

### 6단계: WAR 파일 배포

#### 📦 webapps 디렉터리로 이동

**SSH 터미널로 돌아와서 실행**

```bash
# /tmp에 파일이 있는지 확인
[ec2-user@ip-172-31-0-60 ~]$ cd /tmp
[ec2-user@ip-172-31-0-60 tmp]$ ls
hyechang.war
hsperfdata_ec2-user
...

# WAR 파일을 Tomcat의 webapps 디렉터리로 이동
[ec2-user@ip-172-31-0-60 tmp]$ sudo mv /tmp/hyechang.war /opt/tomcat/webapps/

# 이동 확인
[ec2-user@ip-172-31-0-60 tmp]$ cd /opt/tomcat/webapps
[ec2-user@ip-172-31-0-60 webapps]$ ls
ROOT  docs  examples  host-manager  hyechang.war  manager
```

✅ **WAR 파일이 webapps 디렉터리에 정상 배치됨**

---

### 7단계: Tomcat 서버 실행

#### 🚀 서버 시작

```bash
[ec2-user@ip-172-31-0-60 webapps]$ startup.sh
Using CATALINA_BASE:   /opt/tomcat
Using CATALINA_HOME:   /opt/tomcat
Using CATALINA_TMPDIR: /opt/tomcat/temp
Using JRE_HOME:        /usr/lib/jvm/java-21-amazon-corretto.x86_64
Using CLASSPATH:       /opt/tomcat/bin/bootstrap.jar:/opt/tomcat/bin/tomcat-juli.jar
Using CATALINA_OPTS:
Tomcat started.
```

**서버 상태 확인**

```bash
[ec2-user@ip-172-31-0-60 webapps]$ ps -ef | grep tomcat
ec2-user  12345  ...  java -Djava.util.logging.config.file=/opt/tomcat/conf/logging.properties ...
```

✅ **Tomcat 서버 실행 성공!**

---

### 8단계: 외부 접속 확인

#### 🌐 웹 브라우저에서 접속

```
http://3.38.106.137:8080/hyechang/
```

애플리케이션이 정상적으로 표시되면 **배포 성공**입니다! 🎉

#### 🛑 서버 종료 방법

```bash
[ec2-user@ip-172-31-0-60 ~]$ shutdown.sh
Using CATALINA_BASE:   /opt/tomcat
Using CATALINA_HOME:   /opt/tomcat
Using CATALINA_TMPDIR: /opt/tomcat/temp
Using JRE_HOME:        /usr/lib/jvm/java-21-amazon-corretto.x86_64
Using CLASSPATH:       /opt/tomcat/bin/bootstrap.jar:/opt/tomcat/bin/tomcat-juli.jar
Using CATALINA_OPTS:
Tomcat stopped.
```

---

### 📊 EC2 WAR 배포 전체 흐름 요약

| 단계 | 실행 환경 | 주요 작업 | 명령어 |
|------|-----------|-----------|--------|
| 1 | AWS 콘솔 | EC2 인스턴스 생성 | 수동 설정 |
| 2 | PowerShell | SSH 접속 | `ssh -i [키] ec2-user@[IP]` |
| 3 | EC2 | JDK 설치 | `sudo dnf install java-21-amazon-corretto-devel -y` |
| 4 | EC2 | Tomcat 설치 | `wget ... && tar -xzf ... && mv ...` |
| 5 | EC2 | 환경 변수 설정 | `echo 'export JAVA_HOME=...' >> ~/.bashrc` |
| 6 | PowerShell | WAR 파일 전송 | `scp -i [키] [파일] ec2-user@[IP]:/tmp/` |
| 7 | EC2 | webapps 배치 | `sudo mv /tmp/hyechang.war /opt/tomcat/webapps/` |
| 8 | EC2 | 서버 실행 | `startup.sh` |
| 9 | 브라우저 | 접속 확인 | `http://[IP]:8080/hyechang/` |

---

## 7.1.4 EC2 인스턴스에 JAR 파일 배포

WAR는 외부 Tomcat이 필요했지만, JAR는 **내장 Tomcat**을 포함하고 있어 독립 실행이 가능합니다.

### 1단계: JAR 파일 전송

#### 📤 SCP로 JAR 파일 전송

**로컬 PowerShell에서 실행**

```powershell
PS C:\Users\ghddm> scp -i "C:\Users\ghddm\Downloads\springTomcatServer.pem" "C:\Users\ghddm\Desktop\SpringBoot\Spring-Boot-Portfolio\spring-boot-project\Spring-Board-Project\build\libs\Spring-Board-Project-0.0.1-SNAPSHOT.jar" ec2-user@3.38.106.137:~/hyechang.jar
```

**전송 결과**

```
Spring-Board-Project-0.0.1-SNAPSHOT.jar   100%   58MB   1.8MB/s   00:32
```

#### ✅ 전송 확인

**SSH 터미널에서 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ cd ~/
[ec2-user@ip-172-31-0-60 ~]$ ls
hyechang.jar
```

---

### 2단계: JAR 파일 실행

#### 🚀 백그라운드 실행 (서버 운영 방식)

```bash
[ec2-user@ip-172-31-0-60 ~]$ nohup java -jar hyechang.jar > application.log 2>&1 &
[1] 27717
```

**명령어 상세 설명**

| 부분 | 역할 | 설명 |
|------|------|------|
| `java -jar hyechang.jar` | 실행 명령 | JVM이 JAR 파일 (내장 Tomcat 포함)을 실행 |
| `nohup` | 영구 실행 | SSH 세션 종료 후에도 프로세스 유지 (No Hang Up) |
| `> application.log` | 로그 저장 | 표준 출력을 파일에 기록 |
| `2>&1` | 에러 리디렉션 | 표준 에러도 같은 파일에 기록 |
| `&` | 백그라운드 실행 | 터미널이 다른 명령어를 받을 수 있도록 백그라운드 실행 |

#### 📋 실행 프로세스 확인

```bash
[ec2-user@ip-172-31-0-60 ~]$ ps -ef | grep java | grep hyechang.jar
ec2-user   27717    2386  1 05:15 pts/1    00:00:25 java -jar hyechang.jar
```

**PID(Process ID) 27717**로 실행 중임을 확인할 수 있습니다.

---

### 3단계: 외부 접속 확인

#### 🌐 웹 브라우저에서 접속

```
http://3.38.106.137:8080/
```

**JAR 파일은 기본적으로 루트(`/`) 경로로 실행됩니다.**

애플리케이션이 정상 표시되면 **배포 성공**입니다! 🎉

---

### 4단계: 서버 종료 방법

#### 🛑 프로세스 종료

**1. 실행 중인 프로세스 찾기**

```bash
[ec2-user@ip-172-31-0-60 ~]$ ps -ef | grep java | grep hyechang.jar
ec2-user   27717    2386  1 05:15 pts/1    00:00:25 java -jar hyechang.jar
```

**2. PID를 사용하여 강제 종료**

```bash
[ec2-user@ip-172-31-0-60 ~]$ kill -9 27717
```

**3. 종료 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ ps -ef | grep java | grep hyechang.jar
(결과 없음)
```

✅ **프로세스 종료 완료**

---

### 📊 JAR vs WAR 배포 비교

| 비교 항목 | WAR 배포 | JAR 배포 |
|-----------|----------|----------|
| **WAS 필요** | ⭕ Tomcat 별도 설치 필요 | ❌ 내장 Tomcat 포함 |
| **배포 위치** | `/opt/tomcat/webapps/` | 아무 디렉터리나 가능 (`~/`) |
| **실행 명령** | `startup.sh` (Tomcat 구동) | `java -jar hyechang.jar` |
| **컨텍스트 경로** | 파일명에 따라 결정 (`/hyechang`) | 기본 루트 (`/`) |
| **로그 위치** | `/opt/tomcat/logs/` | `application.log` (지정한 위치) |
| **관리 복잡도** | 높음 (Tomcat 설정 관리 필요) | 낮음 (단순 실행) |
| **포트 변경** | `server.xml` 수정 | `application.properties` 또는 실행 옵션 |

---

## 7.1.5 IaaS 배포의 문제점과 한계

지금까지 EC2 인스턴스에서 수동으로 환경을 구축하고 애플리케이션을 배포하는 전 과정을 경험했습니다. 이 과정을 통해 **IaaS(Infrastructure as a Service) 환경의 본질적인 문제점**을 직접 체감할 수 있었습니다.

### 🚨 주요 문제점

#### 1. 수동 환경 구축의 번거로움

**매번 반복해야 하는 작업들**

```bash
# 서버마다 매번 반복
sudo dnf update -y
sudo dnf install java-21-amazon-corretto-devel -y
cd /opt
sudo wget https://dlcdn.apache.org/tomcat/...
sudo tar -xzf apache-tomcat-10.1.49.tar.gz
sudo mv apache-tomcat-10.1.49 tomcat
sudo chown -R ec2-user:ec2-user tomcat
echo 'export JAVA_HOME=...' >> ~/.bashrc
echo 'export CATALINA_HOME=...' >> ~/.bashrc
source ~/.bashrc
```

**문제점:**
- 서버를 새로 만들 때마다 동일한 설정을 반복해야 함
- 실수로 한 단계를 빠뜨리면 전체 배포 실패
- 설정 과정이 길고 복잡하여 시간 소모가 큼

---

#### 2. 환경 불일치 문제

**로컬 vs 서버 환경 차이**

| 환경 | OS | Java 버전 | Tomcat 버전 | 라이브러리 |
|------|----|-----------|-----------|-----------|
| **로컬 개발** | Windows | JDK 21.0.8 | 10.1.49 | 특정 버전 |
| **EC2 서버** | Amazon Linux | JDK 21.0.9 | 10.1.49 | 다른 버전? |
| **다른 서버** | Ubuntu | JDK 17? | 9.x? | 또 다른 버전? |

**발생 가능한 문제:**
- "내 컴퓨터에서는 잘 되는데 서버에서는 안 돼요" 현상
- Java 버전 차이로 인한 호환성 문제
- 라이브러리 의존성 충돌
- OS별 경로 및 명령어 차이

---

#### 3. 확장성의 어려움

**시나리오: 트래픽 증가로 서버 3대 추가 필요**

```
기존: EC2 1대
↓
필요: EC2 4대 (기존 1대 + 신규 3대)
```

**해야 할 작업:**
- 새로운 EC2 인스턴스 3대 생성
- 각 서버마다 JDK 설치 (3번 반복)
- 각 서버마다 Tomcat 설치 및 설정 (3번 반복)
- 각 서버마다 환경 변수 설정 (3번 반복)
- 각 서버마다 WAR/JAR 파일 전송 및 배포 (3번 반복)
- 로드 밸런서 설정 추가

---

#### 4. 운영 부담 증가

**지속적으로 관리해야 하는 항목들**

| 관리 항목 | 작업 내용 | 빈도 |
|----------|-----------|------|
| **OS 패치** | 보안 업데이트 및 버그 수정 | 월 1~2회 |
| **Java 업데이트** | 새 버전 설치 및 환경 변수 재설정 | 분기별 |
| **Tomcat 업데이트** | 보안 패치 및 버전 업그레이드 | 필요 시 |
| **디스크 관리** | 로그 파일 정리, 디스크 용량 모니터링 | 주간 |
| **프로세스 모니터링** | 서버 다운 여부 확인 및 재시작 | 24시간 |
| **백업** | 애플리케이션 및 데이터 백업 | 일간 |

**문제점:**
- 개발자가 인프라 관리에 많은 시간을 소비
- 애플리케이션 개발보다 서버 운영에 더 많은 리소스 투입
- 휴먼 에러 발생 가능성 높음

---

#### 5. 보안 관리의 복잡성

**직접 관리해야 하는 보안 요소**

```bash
# 방화벽 설정
sudo firewall-cmd --add-port=8080/tcp --permanent

# SSL 인증서 설치 및 갱신
sudo certbot renew

# 사용자 권한 관리
sudo useradd deploy
sudo usermod -aG wheel deploy

# 포트 변경
sudo vi /opt/tomcat/conf/server.xml
```

**문제점:**
- 보안 설정 누락 시 해킹 위험
- SSL 인증서 만료 관리
- 방화벽 규칙 실수로 서비스 중단 가능

---

#### 6. 배포 프로세스의 비효율성

**현재 배포 프로세스**

```
1. 로컬에서 빌드 (Gradle/Maven)
   ↓
2. WAR/JAR 파일 생성
   ↓
3. SCP로 EC2에 파일 전송 (PowerShell)
   ↓
4. SSH로 EC2 접속
   ↓
5. 기존 서버 종료
   ↓
6. 파일 이동/배치
   ↓
7. 서버 재시작
   ↓
8. 브라우저에서 테스트
```

**문제점:**
- 최소 8단계의 수동 작업 필요
- 각 단계에서 실수 가능성 존재
- 배포 시간 약 10~15분 소요
- 배포 중 서비스 중단 (다운타임 발생)

---

#### 7. 모니터링 및 로그 관리의 어려움

**로그 확인 방법**

```bash
# Tomcat WAR 배포 시
[ec2-user@ip-172-31-0-60 ~]$ tail -f /opt/tomcat/logs/catalina.out

# JAR 배포 시
[ec2-user@ip-172-31-0-60 ~]$ tail -f ~/application.log
```

**문제점:**
- 서버마다 SSH로 접속하여 로그 확인 필요
- 여러 서버의 로그를 통합 관리 불가
- 에러 발생 시 실시간 알림 없음
- 로그 파일이 계속 쌓여 디스크 용량 부족 가능

---

### 📊 IaaS 배포의 한계 종합

| 문제 영역 | 구체적 문제점 | 영향 |
|----------|--------------|------|
| **시간** | 초기 설정 시간 증가| 개발 생산성 저하 |
| **비용** | 서버 관리 인력 필요, 시간당 비용 증가 | 운영 비용 증가 |
| **안정성** | 수동 작업으로 인한 휴먼 에러 | 서비스 중단 위험 |
| **확장성** | 서버 추가 시 동일 작업 반복 | 빠른 확장 불가 |
| **일관성** | 환경 차이로 인한 예측 불가능한 문제 | 디버깅 어려움 |

---

### 🎯 다음 단계로: PaaS의 필요성

이러한 모든 문제점들을 해결하기 위해 등장한 것이 바로 **PaaS(Platform as a Service)**입니다.

#### PaaS가 해결하는 문제들

| IaaS의 문제 | PaaS의 해결책 |
|------------|-------------|
| 수동 환경 구축 | 플랫폼이 자동으로 Java, Tomcat 등 설치 |
| 환경 불일치 | 표준화된 실행 환경 제공 |
| 확장 어려움 | 자동 스케일링 (트래픽에 따라 서버 자동 증감) |
| 운영 부담 | OS 패치, 보안 업데이트 자동 처리 |
| 배포 복잡 | WAR/JAR 파일만 업로드하면 자동 배포 |
| 모니터링 부족 | 통합 모니터링 대시보드 제공 |

---

### 📝 실습을 통해 배운 핵심 교훈

#### ✅ 기술적 이해

- **WAR vs JAR의 차이**: 외부 WAS 필요 여부, 컨텍스트 경로, 실행 방식
- **Tomcat의 구조**: bin, conf, webapps, logs 디렉터리의 역할
- **리눅스 서버 관리**: SSH 접속, 패키지 설치, 환경 변수 설정
- **배포의 기본 원리**: 빌드 → 전송 → 배치 → 실행 → 확인

#### ✅ 운영의 현실

- **수동 작업의 한계**: 반복 작업은 자동화가 필수
- **환경 일관성의 중요성**: "내 컴퓨터에서는 되는데" 문제의 근본 원인
- **확장성 고려의 필요성**: 서버 1대 관리와 100대 관리는 완전히 다른 문제
- **개발자의 역할 범위**: 애플리케이션 개발에 집중할 수 있어야 함

---


## 📚 7.1 톰캣 배포 섹션 정리

### ✅ 완료한 학습 내용

| 번호 | 학습 주제 | 핵심 내용 |
|------|----------|-----------|
| 1 | **Tomcat 기본 개념** | WAS의 역할, WAR vs JAR의 차이 |
| 2 | **로컬 Tomcat 실습** | Windows 환경에서 설치, 설정, WAR 배포 |
| 3 | **EC2 환경 구축** | 인스턴스 생성, SSH 접속, 보안 그룹 설정 |
| 4 | **EC2에 WAR 배포** | JDK/Tomcat 수동 설치, WAR 전송 및 배포 |
| 5 | **EC2에 JAR 배포** | 내장 WAS 활용, 백그라운드 실행 |
| 6 | **IaaS 한계 분석** | 수동 관리의 문제점, PaaS 필요성 인식 |

### 🎯 획득한 역량

- ✅ **기본 배포 원리 이해**: 빌드부터 실행까지 전체 흐름 파악
- ✅ **리눅스 서버 관리 경험**: SSH, 패키지 관리, 환경 변수 설정
- ✅ **IaaS 한계 체감**: 자동화와 표준화의 필요성 인식
- ✅ **실전 배포 경험**: 실제 클라우드 환경에서 애플리케이션 서비스


---

# 7.2 AWS 클라우드 배포 (PaaS 환경 실습)

## 📖 학습 개요

**핵심 주제**: PaaS(Platform as a Service) 환경에서의 자동화된 배포  
**사용 기술**: AWS Elastic Beanstalk, Amazon RDS, 환경 변수 기반 프로파일 관리  
**학습 목표**: 
- IaaS 환경의 수동 관리 부담을 해소하는 PaaS의 핵심 가치 체험
- 하나의 JAR 파일로 개발/테스트/운영 환경에 유연하게 배포하는 방법 습득
- 환경 변수와 스프링 프로파일을 결합한 실전 배포 전략 이해

---

## 7.2.1 Elastic Beanstalk란?

### 🔍 PaaS의 등장 배경

7.1장에서 경험한 EC2(IaaS) 배포의 문제점들을 다시 떠올려봅시다:

**IaaS의 근본적인 문제점**
- 서버를 새로 만들 때마다 JDK, Tomcat 설치 반복
- 환경 변수 설정, 포트 구성 등 수동 작업 필수
- 로드 밸런서, 오토 스케일링 등 인프라 직접 구축 및 관리
- 서버 추가 시 동일한 설정을 반복해야 하는 비효율성

이러한 문제를 근본적으로 해결하기 위해 등장한 것이 바로 **PaaS(Platform as a Service)**입니다.

### 🚀 Elastic Beanstalk의 핵심 가치

**AWS Elastic Beanstalk(EB)**는 개발자가 애플리케이션 코드에만 집중할 수 있도록, 복잡한 인프라 관리를 AWS가 대신 처리해주는 PaaS 서비스입니다.

| 항목 | EC2 (IaaS) | Elastic Beanstalk (PaaS) |
|------|------------|--------------------------|
| **환경 구성** | JDK, Tomcat 수동 설치 및 설정 | 플랫폼 선택만으로 자동 설치 |
| **배포** | SCP로 파일 전송, 수동 배치 | JAR/WAR 업로드만으로 자동 배포 |
| **확장** | 서버 추가 시 모든 설정 반복 | 로드 밸런서, 오토 스케일링 자동 구성 |
| **관리** | OS 패치, 보안 업데이트 직접 관리 | AWS가 자동으로 관리 |
| **모니터링** | 별도 도구 설치 및 설정 필요 | CloudWatch 통합 모니터링 제공 |

**비유로 이해하기**
- **IaaS (EC2)**: 빈 땅을 받아 직접 집을 짓고, 전기/수도를 연결하고, 가구를 배치하는 것
- **PaaS (EB)**: 원하는 옵션(플랫폼)을 선택하면 이미 모든 것이 갖춰진 아파트에 입주하는 것

---

## 7.2.2 EB와 Docker의 역할 차이 이해

다음 장에서 배울 Docker와 EB는 서로 다른 문제를 해결합니다. 이 차이를 명확히 이해하는 것이 중요합니다.

### 📦 해결하는 문제의 차이

| 구분 | AWS Elastic Beanstalk (EB) | Docker (컨테이너) |
|------|---------------------------|-------------------|
| **핵심 개념** | PaaS (Platform as a Service) | 환경 패키징 및 표준화 |
| **해결 문제** | 인프라/플랫폼 관리 자동화 및 운영 부담 해소 | 환경 불일치 및 이식성(Portability) 확보 |
| **해결 방식** | 플랫폼 선택 시 AWS가 대신 설치/설정 및 로드 밸런서/오토 스케일링 등 인프라 자동 관리 | 애플리케이션과 실행 환경을 하나의 이미지로 묶어 어디서든 동일하게 실행 |
| **개발자 역할** | 애플리케이션 코드(WAR/JAR)만 제공 | 실행 환경이 담긴 Docker Image/Dockerfile 제공 |

### 🎯 비유로 이해하기

| 기술 | 비유 | 설명 |
|------|------|------|
| **EB (PaaS)** | 🏨 풀옵션 임대 아파트 | 원하는 플랫폼(가구/옵션)을 선택하면 집주인(AWS)이 모든 환경을 준비해 줌 |
| **Docker** | 📦 여행용 캐리어 | 실행 환경(옷, 생필품)을 모두 캐리어(이미지)에 담아, 어느 나라(서버)를 가도 그대로 사용 가능 |

### 🔧 버전 관리의 차이

**EB의 버전 관리 (편리하지만 제한적)**
- **설치 주체**: AWS (EB 서비스 내부 로직)
- **버전 선택**: 플랫폼 선택 시 EB가 제공하는 최신 안정 버전 또는 지정 가능한 범위 내에서 선택
- **예시**: "Java 21 with Amazon Linux 2023" 플랫폼 선택 → EB가 특정 Corretto JDK 21 버전 자동 설치
- **한계**: 특정 마이너 버전(예: `JDK 21.0.8`)까지 세밀하게 지정 불가

**Docker의 버전 관리 (완벽한 통제)**
- **설치 주체**: 개발자 (Dockerfile 내 정의)
- **버전 선택**: Dockerfile에서 `FROM` 명령어로 OS, JDK, Tomcat의 특정 버전을 픽스
- **예시**: 
  ```dockerfile
  FROM openjdk:21-jdk-slim
  FROM tomcat:10.1.20-jre21-temurin-jammy
  ```
- **장점**: 모든 구성 요소의 버전을 개발자가 명시적으로 지정하고 통제 가능

### 🤝 실무에서의 혼합 사용

| 배포 방식 | 설명 | 특징 |
|-----------|------|------|
| **EB + WAR/JAR** | 개발자는 WAR/JAR만 업로드, EB가 JDK/Tomcat 자동 설치 | 간편하지만 버전 통제 약함 |
| **EB + Docker** | Dockerfile 또는 Docker 이미지를 EB에 제공, EB는 Docker 런타임만 설치하고 컨테이너 실행 | 편리함 + 완벽한 버전 통제 |

**결론**: 
- **EB**는 "서버를 개설할 때마다 JDK, Tomcat, 환경변수 설정 등을 자동으로 작성"
- **Docker**는 "구체적인 JDK, Tomcat 버전을 포함한 환경을 컨테이너화"
- **혼합 사용**이 실무에서 가장 권장되는 배포 전략

---

## 7.2.3 EB 환경 구축 사전 준비

EB를 사용하기 전에 두 가지 핵심 인프라를 먼저 구축해야 합니다.

### 1️⃣ VPC (Virtual Private Cloud) 생성

#### 📌 VPC란 무엇인가?

**VPC (Virtual Private Cloud)**는 AWS 클라우드에서 사용자만을 위한 독립적이고 격리된 가상 네트워크 환경입니다.

| 개념 | 설명 |
|------|------|
| **가상 사설 네트워크** | 전통적인 데이터센터의 네트워크 환경(라우터, 스위치, IP 대역)을 AWS 클라우드 위에 소프트웨어적으로 구현 |
| **IP 주소 체계 정의** | VPC에 속한 모든 리소스(EC2, RDS 등)가 사용할 사설 IP 주소 범위를 직접 지정 (예: `10.0.0.0/16`) |
| **네트워크 격리** | 사용자의 리소스를 다른 AWS 사용자의 리소스와 논리적으로 분리하여 보안 강화 |
| **서브넷 분할** | Public(인터넷 연결 허용)과 Private(인터넷 연결 차단) 구역으로 나눠서 보안 수준이 다른 리소스 분리 배치 |

#### 🎯 EB 사용 전 VPC를 설정하는 이유

| 이유 | 설명 |
|------|------|
| **보안 강화** | DB 서버(RDS)는 외부 인터넷 접속이 차단된 Private Subnet에 배치하여 보호 |
| **네트워크 일관성** | 개발, 테스트, 운영 등 모든 환경에서 동일하고 표준화된 VPC 구조 재사용 |
| **IP 충돌 방지** | 원하는 IP 대역을 명시적으로 지정하여, 나중에 다른 AWS 환경과 연결 시 충돌 방지 |

> **참고**: 기본 VPC를 사용해도 되지만, 실제 운영 환경에서는 보안과 제어를 위해 사용자 지정 VPC를 설정하는 것이 필수적입니다.

#### 🛠️ VPC 생성 방법

**1단계: VPC 콘솔 접속**
- AWS 콘솔에서 `VPC` 검색 → VPC 대시보드 → `VPC 생성` 클릭

**2단계: 생성할 리소스 선택**
```
생성할 리소스: VPC 및 기타 네트워킹 리소스
```

이 옵션을 선택하면 VPC와 함께 필요한 서브넷, 라우팅 테이블, 인터넷 게이트웨이 등이 한 번에 생성됩니다.

**3단계: 이름 태그 자동 생성 설정**
```
이름 태그 자동 생성: 활성화
값: hyechangSpring
```

이름 태그를 설정하면 VPC뿐만 아니라 함께 생성되는 모든 리소스의 이름에 태그가 자동으로 추가되어 나중에 VPC 관련 리소스를 쉽게 구분할 수 있습니다.

**4단계: 생성 완료**
- 나머지 설정은 기본값 유지
- `VPC 생성` 버튼 클릭

#### 📂 생성된 VPC 구조

```
hyechangSpring-vpc
├── Public Subnet 1 (ap-northeast-2a)   # 웹 서버(EC2) 배치
├── Public Subnet 2 (ap-northeast-2c)   # 로드 밸런서, 고가용성 확보
├── Private Subnet 1 (ap-northeast-2a)  # 데이터베이스(RDS) 배치
└── Private Subnet 2 (ap-northeast-2c)  # RDS 이중화
```

**서브넷 활용 원칙**
| 서브넷 타입 | 배치 리소스 | 특징 |
|------------|------------|------|
| **Public Subnet** | 웹 서버(EC2), 로드 밸런서 | 인터넷과 연결, 퍼블릭 IP 할당 가능 |
| **Private Subnet** | 데이터베이스(RDS) | 인터넷 접속 차단, 내부 통신만 허용 |

**고가용성을 위한 2개의 서브넷**
- 각 타입(Public/Private)마다 2개씩 생성되는 이유는 **가용 영역(Availability Zone, AZ)**에 따른 분산 때문입니다
- 하나의 AZ에 문제가 생겨도 다른 AZ에서 서비스를 계속할 수 있도록 설계

---

### 2️⃣ IAM 역할 생성

#### 🔑 IAM이란?

**IAM (Identity and Access Management)**은 AWS 자원에 접근하고 사용할 수 있는 권한을 관리하는 AWS의 핵심 보안 서비스입니다.

**핵심 개념**: IAM은 **"누가(사용자, 서비스, 리소스), 무엇을(EC2, S3, RDS), 어떻게(읽기, 쓰기, 생성) 할 수 있는지"**를 정의하고 통제합니다.

#### 🎯 EB에 필요한 두 가지 IAM 역할

EB 환경을 생성하려면 두 가지 역할이 필요합니다:

| 역할 | 주체 (권한을 받는 대상) | 역할 (무엇을 하는가?) | 생성 시기 |
|------|----------------------|-------------------|----------|
| **1. EB 서비스 롤** | Elastic Beanstalk 서비스 | 환경 구축 및 관리 (EC2 생성, JDK 설치, 로드 밸런서 설정 등) | EB 생성 시 함께 만들 수 있음 |
| **2. EC2 인스턴스 프로파일** | EB가 생성한 EC2 인스턴스 | 애플리케이션 실행 중 AWS 리소스 접근 (S3 파일 읽기, CloudWatch에 로그 쓰기 등) | **사전 생성 필수** |

#### 🔧 EB 서비스 롤

**역할 설명**
```
"EB야, 네가 이 환경을 자동으로 설정하고 관리할 수 있는 권한을 내가 줄게!"
```

- **권한 부여 대상**: Elastic Beanstalk 서비스 자체
- **역할**: EB가 사용자 대신 AWS 환경에서 복잡한 리소스 관리 작업 수행
- **예시**: EB가 EC2 인스턴스를 만들고, JDK를 설치하고, 로드 밸런서를 생성하고, 보안 그룹을 설정
- **필요성**: 이 롤이 없으면 EB는 AWS 인프라 리소스를 건드릴 권한이 없어 환경을 만들 수 없음

#### 🔑 EC2 인스턴스 프로파일

**역할 설명**
```
"EB가 만든 그 EC2 인스턴스에서 애플리케이션을 돌릴 때, 필요한 AWS 리소스에 접근할 권한을 줄게!"
```

- **권한 부여 대상**: EB가 생성한 EC2 인스턴스 자체
- **역할**: EC2 인스턴스 위에서 실행되는 애플리케이션(JAR/WAR)이 다른 AWS 서비스와 상호작용
- **예시**: EC2 인스턴스가 로그를 CloudWatch에 올리고, S3에서 이미지 파일을 읽어오고, RDS 데이터베이스에 접속

**JAR 실행 권한은 왜 별도로?**
- JAR 파일을 실행하는 것 자체는 EC2 인스턴스의 OS 권한으로 충분
- 하지만 실행된 애플리케이션이 AWS 클라우드 환경 내의 다른 서비스(S3, RDS, CloudWatch 등)를 이용하려면 AWS IAM 권한이 필요
- 이 권한은 EC2 인스턴스 프로파일을 통해 부여되고, 애플리케이션이 실행될 때 상속받아 사용

#### 🛠️ EC2 인스턴스 프로파일 생성 방법

**중요**: EC2 인스턴스 프로파일은 EB 환경 생성 시 함께 만들 수 없으므로 반드시 사전에 생성해야 합니다.

**1단계: IAM 콘솔 접속**
- AWS 콘솔에서 `IAM` 검색 → IAM 대시보드 → `액세스 관리` → `역할` → `역할 생성`

**2단계: 신뢰할 수 있는 엔터티 유형 선택**
```
신뢰할 수 있는 엔터티 유형: AWS 서비스
사용 사례: EC2
```

**3단계: 권한 정책 연결**

스프링 부트 애플리케이션 배포를 위해 필요한 권한:
```
AWSElasticBeanstalkWebTier
```

이 정책은 EB의 웹 계층(EC2 인스턴스)에서 실행되는 애플리케이션이 필요로 하는 기본 권한들을 포함합니다.

**4단계: 역할 이름 지정**
```
역할 이름: aws-elasticbeanstalk-instance-profile
```

**5단계: 역할 생성 완료**

#### 🛠️ EB 서비스 롤 생성 방법

**참고**: 실제로는 EB 서비스 롤도 사전에 생성하도록 변경되었지만, 역할 생성 버튼을 클릭하면 자동으로 세팅되어서 쉽게 생성할 수 있습니다.

**자동 생성 과정**
1. EB 환경 생성 마법사의 "서비스 액세스" 단계에서 `역할 생성` 버튼 클릭
2. AWS가 자동으로 필요한 정책이 포함된 역할을 생성
3. 최종 역할 이름: `aws-elasticbeanstalk-service-role`

---

## 7.2.4 개발 환경 (Dev) 배포

### 📋 환경 개요

| 항목 | 설정값 |
|------|--------|
| **환경 이름** | `Spring-demo-dev` |
| **인스턴스 구성** | 단일 인스턴스 (고가용성 불필요) |
| **데이터베이스** | H2 내장 DB (프로파일: `dev`) |
| **서브넷** | Public Subnet (외부 접근 필요) |
| **목적** | 기능 구현, 간편 테스트 |

### 🚀 1단계: 애플리케이션 생성

**애플리케이션은 EB의 최상위 컨테이너**로, 여러 환경(Dev, Test, Prod)을 그룹핑하는 역할을 합니다.

#### 애플리케이션 생성
```
AWS 콘솔 → Elastic Beanstalk → 애플리케이션 생성
애플리케이션 이름: spring-demo
```

### 🛠️ 2단계: 환경 생성 - 기본 구성

#### 환경 티어 선택
```
환경 티어: 웹 서버 환경
```

**환경 티어란?**
| 티어 타입 | 용도 | 특징 |
|----------|------|------|
| **웹 서버 환경** | HTTP 요청을 처리하는 웹 애플리케이션 | 로드 밸런서, 오토 스케일링 지원 |
| **작업자 환경** | 백그라운드 작업 처리 (SQS 메시지 처리 등) | 로드 밸런서 없음 |

#### 환경 정보
```
환경 이름: Spring-demo-dev
```

#### 플랫폼 설정

**핵심 개념**: Spring Boot 애플리케이션은 JVM 위에서 실행되므로 **Java 플랫폼**을 선택해야 합니다.

```
플랫폼: Java
플랫폼 브랜치: Corretto 25 running on 64bit Amazon Linux 2023
플랫폼 버전: 최신 버전 (권장)
```

**플랫폼 선택 기준**
- Spring Boot 프로젝트의 JDK 버전과 동일하거나 호환성에 문제가 없는 버전 선택
- 최신 버전을 선택하면 AWS가 보안 패치를 자동으로 적용

#### 애플리케이션 코드

**코드 업로드 옵션 비교**

| 옵션 | 설명 | 사용 시기 |
|------|------|----------|
| **샘플 애플리케이션** | EB가 제공하는 임시 애플리케이션 | 환경 테스트용 |
| **기존 버전** | 이미 EB에 배포된 애플리케이션 버전 | 재배포 또는 롤백 시 |
| **코드 업로드** | 로컬 PC의 JAR/WAR 파일 업로드 | **실제 애플리케이션 배포 (선택)** |

**코드 업로드 설정**
```
소스 코드 원본: 로컬 파일
파일: Spring-Board-Project-0.0.1-SNAPSHOT.jar
버전 레이블: 1.0.0
```

**JAR vs WAR 파일 업로드 시 EB의 동작**

| 파일 형식 | WAS 사용 방식 | EB의 자동 처리 과정 |
|----------|-------------|------------------|
| **`.jar`** | 내장 WAS (Embedded Tomcat/Jetty 등) | EB는 EC2에 JDK만 설치하고, `java -jar [파일 이름]` 명령을 실행하여 JAR 파일 안에 포함된 WAS를 구동 |
| **`.war`** | 외부 WAS (Standalone Tomcat) | EB는 EC2에 JDK와 별도의 외부 Tomcat 서버를 자동으로 설치하고, WAR 파일을 Tomcat의 `/webapps` 디렉터리에 배치한 후 Tomcat 실행 |

**중요**: "Java" 플랫폼 선택 시, EB는 WAR 파일에 대해 자동으로 Apache Tomcat을 사용하도록 내부적으로 구성되어 있습니다. 사용자가 별도로 WAS를 지정할 필요가 없습니다.

#### 사전 설정

```
환경 유형: 단일 인스턴스
```

**환경 유형 비교**

| 환경 유형 | 인스턴스 수 | 로드 밸런서 | 용도 |
|----------|-----------|-----------|------|
| **단일 인스턴스** | 1대 (고정) | 없음 | 개발/테스트 환경 (비용 절감) |
| **고가용성 (로드 밸런싱)** | 최소 2대 이상 (자동 확장) | 있음 (ELB) | 운영 환경 (안정성 확보) |

---

### 🔐 3단계: 서비스 액세스 구성

이 단계에서는 사전에 생성한 IAM 역할을 등록합니다.

```
서비스 역할: aws-elasticbeanstalk-service-role
EC2 인스턴스 프로파일: aws-elasticbeanstalk-instance-profile
```

**역할 등록의 의미**
- **EB 서비스 롤**: EB가 환경을 자동으로 구축하고 관리할 수 있는 권한 부여
- **EC2 인스턴스 프로파일**: 애플리케이션이 실행될 때 AWS 리소스에 접근할 수 있는 권한 부여

---

### 🌐 4단계: 네트워킹, 데이터베이스 및 태그 설정

#### VPC 설정
```
VPC: hyechangSpring-vpc (사전에 생성한 VPC 선택)
퍼블릭 IP 주소: 활성화 ✅
```

**퍼블릭 IP 활성화 이유**: 단일 인스턴스 환경에서는 로드 밸런서가 없으므로, EC2 인스턴스가 직접 외부 인터넷과 통신하기 위해 퍼블릭 IP가 필요합니다.

#### 인스턴스 서브넷 선택

**단일 인스턴스에서 Public Subnet을 선택하는 이유**

현재는 로드 밸런서가 없는 단일 인스턴스 구성이므로, 외부에서 애플리케이션에 직접 접근하기 위해 EC2 인스턴스를 Public Subnet에 배치해야 합니다.

```
인스턴스 서브넷: 
  - hyechangSpring-subnet-public1-ap-northeast-2a ✅
  - hyechangSpring-subnet-public2-ap-northeast-2c ✅
```

**Public Subnet이 2개인 이유**

현재는 단일 인스턴스만 사용하지만, VPC는 나중에 운영 환경으로 확장할 때를 대비하여 고가용성 구조로 설계됩니다.

| 시나리오 | 서브넷 사용 | 이유 |
|---------|-----------|------|
| **현재 (단일 인스턴스)** | Public Subnet 1개만 사용 | 비용 절감 |
| **미래 (운영 환경)** | Public Subnet 2개 모두 사용 | 로드 밸런서를 2개의 가용 영역(AZ)에 분산 배치하여 한 AZ에 문제가 생겨도 서비스 지속 |

#### 데이터베이스 설정

개발 환경에서는 스프링 부트 애플리케이션이 H2 내장 데이터베이스를 사용하므로 RDS를 활성화하지 않습니다.

```
데이터베이스 가용성: 비활성화
```

---

### ⚙️ 5단계: 인스턴스 트래픽 및 크기 조정 구성

단일 인스턴스를 사용하기로 했으므로 이 단계에서는 별도로 선택할 항목이 없습니다.

```
(기본값유지)
```

---

### 📊 6단계: 업데이트, 모니터링 및 로깅 구성

이 단계는 **EB 환경 설정의 핵심**입니다. 여기서 Nginx의 역할과 환경 변수를 통한 프로파일 관리를 이해하는 것이 매우 중요합니다.

#### 🌐 Nginx의 역할 및 포트 포워딩 원리

EB가 생성한 EC2 인스턴스에는 **리버스 프록시(Reverse Proxy)** 역할을 하는 Nginx가 기본으로 탑재되어 있습니다.

**포트 포워딩 흐름**

| 주체 | 역할 | 포트 |
|------|------|------|
| **외부 사용자** | 웹 요청 | 80 포트 (표준 HTTP 포트) |
| **Nginx (EC2 내부)** | 리버스 프록시 | 80 포트 요청을 받아 → 내부 5000 포트로 포워딩 |
| **Spring Boot App (EC2 내부)** | 애플리케이션 실행 | 5000 포트 (Nginx가 요청을 던져주는 포트) |

**Nginx를 사용하는 이유**

1. **포트 단순화**: 외부 사용자는 `http://EC2-IP:8080` 대신 표준 웹 포트인 `http://EC2-IP:80`으로만 접근
2. **WAS 포트 은닉**: 내부적으로 Spring Boot 앱이 몇 번 포트를 사용하는지 외부에 노출할 필요 없음
3. **포트 충돌 방지**: EB는 내부적으로 5000번 포트를 애플리케이션 포트의 표준으로 정하고 Nginx를 설정

#### 🔑 환경 변수를 통한 설정 덮어쓰기

EB 환경 변수를 통해 `application.properties`의 설정을 런타임에 덮어쓸 수 있습니다. 이것이 바로 **프로파일 기반 환경 관리의 핵심**입니다.

**환경 속성 설정**

```
환경 속성:
  GRADLE_HOME: /usr/local/gradle
  M2: /usr/local/apache-maven/bin
  M2_HOME: /usr/local/apache-maven
  PROFILES: dev
  SERVER_PORT: 5000
```

**핵심 환경 변수 설명**

| 환경 변수 | 설정값 | 매핑되는 Spring 속성 | 역할 |
|----------|--------|---------------------|------|
| **`SERVER_PORT`** | `5000` | `server.port` | Nginx의 포워딩 규칙(80→5000)에 맞추기 위해 애플리케이션의 실행 포트를 5000으로 강제 |
| **`PROFILES`** | `dev` | `spring.profiles.active` (via `${profiles}`) | 개발 환경 설정 파일(`application-dev.properties`) 활성화 |

**환경 변수 매핑 원리**

Spring Boot는 환경 변수의 **대문자_언더바 규칙**을 자동으로 인식하여 `application.properties`의 설정을 덮어씁니다.

| 환경 변수 | Spring 속성 | 변환 규칙 |
|----------|------------|----------|
| `SERVER_PORT` | `server.port` | 대문자 → 소문자, `_` → `.` |
| `SPRING_PROFILES_ACTIVE` | `spring.profiles.active` | 대문자 → 소문자, `_` → `.` |

#### 📝 애플리케이션 코드와의 연동

**`application.properties`**

```properties
spring.application.name=Spring-Board-Project
profiles=dev
spring.profiles.active=${profiles}

spring.sql.init.mode=always
spring.sql.init.encoding=utf-8
spring.jpa.hibernate.ddl-auto=none
```

**동작 원리**
1. EB 환경 변수 `PROFILES=dev`가 설정됨
2. Spring Boot 실행 시 `profiles` 변수에 `dev` 값이 주입됨
3. `spring.profiles.active=${profiles}`가 `spring.profiles.active=dev`로 해석됨
4. `application-dev.properties` 파일이 활성화됨

**`application-dev.properties`**

```properties
spring.datasource.url=jdbc:h2:mem:demo
spring.h2.console.enabled=true
```

**결과**: 개발 환경에서는 H2 내장 데이터베이스를 사용하고, H2 콘솔도 활성화됩니다.

#### 🎯 환경 변수 적용의 중요성

이러한 방식은 **"프로그램 실행 옵션 > 운영체제 환경변수 > application.properties"**라는 스프링 부트 설정 우선순위를 활용하는 것이며, 다음과 같은 장점을 제공합니다:

**핵심 장점**
- ✅ **코드 수정 없이 환경 전환**: 동일한 JAR 파일로 Dev, Test, Prod 환경에 배포 가능
- ✅ **유연한 설정 관리**: 환경 변수만 변경하여 데이터베이스, 포트, 로깅 레벨 등 조정
- ✅ **보안 강화**: 민감한 정보(DB 비밀번호 등)를 코드에 하드코딩하지 않고 환경 변수로 관리

---

### ✅ 7단계: 환경 생성 완료 및 확인

모든 설정을 마친 후 `제출` 버튼을 클릭하면 EB가 자동으로 환경을 구축합니다.

**EB의 자동 작업 내역**
1. ✅ EC2 인스턴스 생성
2. ✅ Amazon Corretto JDK 21 설치
3. ✅ Nginx 설치 및 포트 포워딩 설정 (80 → 5000)
4. ✅ 보안 그룹 구성 (80번 포트 개방)
5. ✅ JAR 파일 배포 및 실행 (`java -jar`)
6. ✅ CloudWatch 모니터링 설정

**환경 생성 완료 화면**

```
환경 개요
  상태: Ok ✅
  도메인: Spring-demo-dev.eba-2w2jyb3b.ap-northeast-2.elasticbeanstalk.com
  환경 ID: e-np3hyizgmj
  애플리케이션 이름: spring-demo
```

#### 🌐 애플리케이션 접속

브라우저에서 다음 URL로 접속하여 애플리케이션이 정상 작동하는지 확인합니다:

```
http://Spring-demo-dev.eba-2w2jyb3b.ap-northeast-2.elasticbeanstalk.com
```

**접속 성공 시**: 스프링 부트 애플리케이션의 메인 페이지가 표시됩니다. 🎉

---

### 📊 개발 환경 최종 정리

**6단계 환경 구성 요약**

| 단계 | 설정 항목 | 설정 값 |
|------|----------|---------|
| **1단계** | 환경 이름 | `Spring-demo-dev` |
| | 플랫폼 | `Corretto 25 running on 64bit Amazon Linux 2023` |
| | 애플리케이션 코드 | `Spring-Board-Project-0.0.1-SNAPSHOT.jar` (버전: 1.0.0) |
| **2단계** | 서비스 역할 | `aws-elasticbeanstalk-service-role` |
| | EC2 인스턴스 프로파일 | `aws-elasticbeanstalk-instance-profile` |
| **3단계** | VPC | `hyechangSpring-vpc` |
| | 퍼블릭 IP 주소 | 활성화 |
| | 인스턴스 서브넷 | Public Subnet 2개 |
| | 데이터베이스 | 비활성화 (H2 사용) |
| **4단계** | 환경 유형 | 단일 인스턴스 |
| **5단계** | 환경 속성 | `PROFILES=dev`, `SERVER_PORT=5000` |

---

## 7.2.5 테스트 환경 (Test) 배포

### 📋 환경 개요

| 항목 | 설정값 |
|------|--------|
| **환경 이름** | `Spring-demo-test` |
| **인스턴스 구성** | 단일 인스턴스 |
| **데이터베이스** | RDS MySQL (프로파일: `aws`) |
| **서브넷** | EC2: Public, RDS: Private |
| **목적** | 통합 테스트, 검증 (데이터 영속성 확보) |

### 🔄 개발 환경과의 차이점

테스트 환경은 개발 환경과 대부분 동일하지만, **데이터베이스**가 핵심 차이점입니다.

| 항목 | 개발 환경 (Dev) | 테스트 환경 (Test) |
|------|----------------|-------------------|
| **데이터베이스** | H2 내장 DB (휘발성) | RDS MySQL (영구 저장) |
| **프로파일** | `dev` | `aws` |
| **데이터 유지** | 재시작 시 초기화 | 재시작 후에도 데이터 유지 |

### 🗄️ RDS (Relational Database Service) 이해

#### RDS란?

**RDS (Relational Database Service)**는 MySQL, PostgreSQL과 같은 관계형 데이터베이스를 쉽게 설치, 운영, 관리할 수 있도록 해주는 AWS 서비스입니다.

**RDS의 핵심 역할**

| 항목 | 설명 |
|------|------|
| **컴퓨팅 자원** | RDS도 내부적으로 EC2 인스턴스를 사용하지만, 데이터베이스 서버 역할만 수행하며 AWS가 완전히 관리 |
| **관리 자동화** | OS 패치, 보안 업데이트, 디스크 관리를 AWS가 자동으로 처리 |
| **고가용성** | 멀티-AZ 배포 시 자동으로 이중화 및 장애 조치(Failover) |
| **백업/복구** | 자동 백업 및 특정 시점 복구(Point-in-time recovery) 기능 제공 |

#### 🔗 EB와 RDS의 관계

**중요**: 애플리케이션 서버(EC2)와 데이터베이스 서버(RDS)는 분리되어 독립적으로 운영됩니다.

```
┌─────────────────────┐
│  Elastic Beanstalk  │
│  (애플리케이션 계층)   │
│                     │
│  ┌───────────────┐  │
│  │  EC2 인스턴스  │  │ ← Spring Boot JAR 실행
│  │  (Web Server) │  │
│  └───────┬───────┘  │
└──────────┼──────────┘
           │ 네트워크 연결
           │ (VPC 내부)
           ▼
    ┌─────────────┐
    │     RDS     │
    │ (DB 계층)    │
    │             │
    │ ┌─────────┐ │
    │ │  MySQL  │ │ ← 데이터베이스 서버
    │ └─────────┘ │
    └─────────────┘
```

**분리 원칙**
- ❌ 하나의 EC2 인스턴스에 JAR 애플리케이션과 MySQL 서버를 모두 실행하는 구조는 사용하지 않음
- ✅ 안정성과 확장성을 위해 두 서버는 항상 분리됨

### 🛠️ 테스트 환경 생성 (차이점 중심)

개발 환경과 동일한 부분은 생략하고, **차이점만** 설명합니다.

#### 1단계: 기본 구성

```
환경 이름: Spring-demo-test
```

**애플리케이션 코드 선택**

```
옵션 1 (기존 버전 사용): 기존 버전 → 1.0.0 선택
옵션 2 (새 버전 업로드): 코드 업로드 → 수정된 JAR 파일 업로드 → 버전 레이블: 2.0.0
```

**JAR 파일 수정 이유**: `application-aws.properties` 파일 추가 등 RDS 연동을 위한 설정 포함

#### 2단계: 서비스 액세스 (동일)

```
서비스 역할: aws-elasticbeanstalk-service-role
EC2 인스턴스 프로파일: aws-elasticbeanstalk-instance-profile
```

#### 3단계: 네트워킹, 데이터베이스 및 태그 설정 (핵심 차이점)

**VPC 및 인스턴스 서브넷 (동일)**

```
VPC: hyechangSpring-vpc
퍼블릭 IP 주소: 활성화
인스턴스 서브넷: Public Subnet 2개 선택
```

**데이터베이스 설정 (핵심 차이점) 🔑**

```
데이터베이스 가용성: 활성화 ✅
```

데이터베이스를 활성화하면 EB가 자동으로 RDS 인스턴스를 생성하고 연결합니다.

**데이터베이스 서브넷 선택**

```
데이터베이스 서브넷: 
  - hyechangSpring-subnet-private1-ap-northeast-2a ✅
  - hyechangSpring-subnet-private2-ap-northeast-2c ✅
```

**Private Subnet을 선택하는 이유**
- 데이터베이스는 외부 인터넷에서 직접 접속할 필요가 없음
- 보안을 위해 인터넷 접속이 완전히 차단된 Private Subnet에 배치
- 애플리케이션(EC2)은 VPC 내부 네트워크를 통해서만 RDS에 접근

**데이터베이스 자격 증명 설정**

```
데이터베이스 엔진: MySQL 8.0.43
데이터베이스 인스턴스 클래스: db.t3.small
데이터베이스 사용자 이름: myuser
데이터베이스 암호: [강력한 암호 입력]
데이터베이스 스토리지: 20 GB
```

**중요**: 이 사용자 이름과 암호는 AWS 콘솔 로그인 정보나 EC2 인스턴스 접속 정보가 **아닙니다**. RDS MySQL 서버의 **마스터 사용자(Master User)** 계정을 생성하는 것입니다.

#### 🔑 RDS 마스터 사용자 계정의 역할

**1. 계정 생성 및 권한 부여**

- **생성 행위**: 입력한 자격 증명으로 RDS 서비스가 MySQL 서버를 초기화하면서 **마스터 사용자(Master User)**를 생성
- **권한**: 이 마스터 사용자는 해당 RDS 인스턴스 내에서 **최고 권한(슈퍼 유저)**을 가짐
- **가능한 작업**: 데이터베이스 생성, 테이블 조작(CRUD), 사용자 관리 등 모든 관리 작업

**2. 환경 변수 전달 및 사용**

EB는 이 마스터 사용자의 자격 증명을 **환경 변수**로 변환하여 애플리케이션이 실행되는 EC2 인스턴스에 전달합니다.

| RDS 정보 | 환경 변수 이름 | 설명 |
|---------|--------------|------|
| **Hostname** | `RDS_HOSTNAME` | RDS 서버 주소 |
| **Port** | `RDS_PORT` | MySQL 포트 (기본: 3306) |
| **DB Name** | `RDS_DB_NAME` | 데이터베이스 이름 |
| **Username** | `RDS_USERNAME` | 마스터 사용자 이름 |
| **Password** | `RDS_PASSWORD` | 마스터 사용자 암호 |

**3. Spring Boot 애플리케이션의 RDS 접속**

Spring Boot 애플리케이션은 이 환경 변수를 읽어 MySQL 서버에 접속합니다.

**`application-aws.properties`**

```properties
spring.datasource.url=jdbc:mysql://${rds.hostname}:${rds.port}/${rds.db.name}
spring.datasource.username=${rds.username}
spring.datasource.password=${rds.password}

spring.session.jdbc.initialize-schema=always
```

**환경 변수 바인딩 원리**

Spring Boot는 EB가 주입한 환경 변수를 자동으로 소문자 속성명으로 매핑합니다:

| 환경 변수 | Spring 속성 |
|----------|------------|
| `RDS_HOSTNAME` | `rds.hostname` |
| `RDS_PORT` | `rds.port` |
| `RDS_DB_NAME` | `rds.db.name` |
| `RDS_USERNAME` | `rds.username` |
| `RDS_PASSWORD` | `rds.password` |

**최종 연결 과정**

1. **RDS 생성**: AWS RDS가 MySQL 서버를 생성하고 마스터 사용자 계정 생성
2. **정보 전달**: EB가 RDS 접속 정보를 환경 변수로 EC2 인스턴스에 주입
3. **변수 바인딩**: `application-aws.properties`의 플레이스홀더(`${rds.hostname}` 등)에 환경 변수 값 대입
4. **DB 접속**: Spring Boot가 완성된 URL과 인증 정보로 RDS MySQL 서버에 접속
5. **세션 관리**: `spring.session.jdbc.initialize-schema=always` 설정으로 세션 저장용 테이블 자동 생성

```
최종 연결 URL 예시:
jdbc:mysql://mydb.abc123.ap-northeast-2.rds.amazonaws.com:3306/ebdb
```

#### 4단계: 인스턴스 트래픽 및 크기 조정 (동일)

```
(기본값 유지)
```

#### 5단계: 업데이트, 모니터링 및 로깅 구성 (환경 변수 차이)

**환경 속성 설정**

```
환경 속성:
  GRADLE_HOME: /usr/local/gradle
  M2: /usr/local/apache-maven/bin
  M2_HOME: /usr/local/apache-maven
  PROFILES: aws  ← 개발 환경과 다름!
  SERVER_PORT: 5000
```

**`PROFILES=aws` 설정의 의미**

1. `application.properties`의 `spring.profiles.active=${profiles}`가 `spring.profiles.active=aws`로 해석됨
2. `application-aws.properties` 파일이 활성화됨
3. RDS MySQL 연결 설정이 적용됨

#### 6단계: 환경 생성 및 확인

`제출` 버튼을 클릭하면 EB가 다음 작업을 자동으로 수행합니다:

**EB의 자동 작업 (테스트 환경)**
1. ✅ EC2 인스턴스 생성 (Public Subnet)
2. ✅ RDS MySQL 인스턴스 생성 (Private Subnet, 2개 AZ에 걸쳐 배치)
3. ✅ JDK, Nginx 설치 및 설정
4. ✅ RDS 접속 정보를 환경 변수로 EC2에 주입
5. ✅ JAR 파일 배포 및 실행
6. ✅ 보안 그룹 구성 (EC2 ↔ RDS 통신 허용)

**환경 생성 완료**

```
환경 개요
  상태: Ok ✅
  도메인: Spring-demo-test.eba-xxxxxxx.ap-northeast-2.elasticbeanstalk.com
```

---

### ⚠️ SQL 초기화 충돌 문제 및 해결

테스트 환경 배포 후 애플리케이션 접속 시 다음과 같은 오류가 발생할 수 있습니다:

```
HTTP Status 500 - Internal Server Error
Caused by: Table 'member' already exists
```

#### 🔍 문제 원인 분석

| 원인 요소 | 설명 |
|----------|------|
| **`spring.sql.init.mode=always`** | `application.properties`에 설정되어 있어, Spring Boot가 시작 시마다 `schema.sql` 스크립트를 실행하여 테이블 생성을 강제 |
| **RDS의 데이터 영속성** | RDS는 영구 데이터베이스이므로, 이전 배포 시 생성된 테이블을 그대로 유지 |
| **충돌 발생** | 애플리케이션이 다시 시작할 때 이미 존재하는 테이블을 또 만들려 하니 충돌 발생 |

**개발 vs 운영 환경의 차이**

| 환경 | 데이터베이스 | SQL 초기화 필요성 | 문제 발생 여부 |
|------|------------|----------------|--------------|
| **개발 (H2)** | 휘발성 (재시작 시 초기화) | `always` 필수 | 문제 없음 ✅ |
| **테스트/운영 (RDS)** | 영구 저장 (데이터 유지) | `never` 필요 | 충돌 발생 ❌ |

#### ✅ 해결 방법: 환경 변수로 설정 덮어쓰기

**1. EB 콘솔 접속**

```
Elastic Beanstalk → 환경 → Spring-demo-test → 구성 → 소프트웨어 → 편집
```

**2. 환경 속성 추가**

```
환경 속성:
  SPRING_SQL_INIT_MODE: never  ← 추가!
  PROFILES: aws
  SERVER_PORT: 5000
```

**3. 적용 및 재배포**

`적용` 버튼 클릭 → EB가 자동으로 환경을 업데이트하고 애플리케이션 재시작

**해결 원리**

1. 환경 변수 `SPRING_SQL_INIT_MODE=never` 설정
2. Spring Boot가 `application.properties`의 `spring.sql.init.mode=always`를 `never`로 덮어씀
3. 애플리케이션은 테이블 초기화를 시도하지 않고 정상 구동

**중요**: 
- ✅ 애플리케이션 코드(JAR 파일)는 수정하지 않음
- ✅ 환경 변수만 변경하여 문제 해결
- ✅ RDS의 기존 테이블과 데이터는 그대로 유지

---

### 📊 테스트 환경 최종 정리

**테스트 환경의 핵심 특징**

| 항목 | 설정 |
|------|------|
| **환경 이름** | `Spring-demo-test` |
| **인스턴스** | 단일 인스턴스 (Public Subnet) |
| **데이터베이스** | RDS MySQL (Private Subnet, 2개 AZ) |
| **프로파일** | `aws` |
| **환경 변수** | `PROFILES=aws`, `SERVER_PORT=5000`, `SPRING_SQL_INIT_MODE=never` |
| **데이터 영속성** | ✅ 재배포 후에도 데이터 유지 |

**배포 후 검증 사항**
- ✅ 애플리케이션 정상 접속
- ✅ 데이터베이스 연결 확인 (회원 가입, 게시글 작성 등)
- ✅ 재배포 후에도 기존 데이터 유지 확인

---

## 7.2.6 운영 환경 (Production) 배포

### 📋 환경 개요

| 항목 | 설정값 |
|------|--------|
| **환경 이름** | `Spring-demo-prod` |
| **인스턴스 구성** | 고가용성 (로드 밸런싱) |
| **인스턴스 수** | 최소 2대, 최대 4대 (오토 스케일링) |
| **데이터베이스** | RDS MySQL (프로파일: `aws,health`) |
| **서브넷** | EC2: Private, ELB: Public, RDS: Private |
| **목적** | 실서비스, 무중단 운영, 고가용성 확보 |

### 🎯 운영 환경의 핵심 차이점

테스트 환경과의 가장 큰 차이는 **고가용성 아키텍처**입니다.

| 항목 | 테스트 환경 | 운영 환경 |
|------|------------|----------|
| **환경 유형** | 단일 인스턴스 | 로드 밸런싱 |
| **EC2 인스턴스 수** | 1대 고정 | 2~4대 (자동 확장/축소) |
| **로드 밸런서** | 없음 | ELB (Application Load Balancer) |
| **EC2 서브넷** | Public | Private (보안 강화) |
| **외부 접근** | EC2에 직접 접근 | ELB를 통해서만 접근 |
| **장애 대응** | 인스턴스 다운 시 서비스 중단 | 다른 인스턴스가 즉시 트래픽 처리 |

### 🛠️ 운영 환경 생성 (차이점 중심)

#### 1단계: 기본 구성

```
환경 이름: Spring-demo-prod
```

**애플리케이션 코드**

```
기존 버전 사용: 2.0.0 선택
```

**이미 검증된 버전을 사용하는 것이 운영 환경의 원칙입니다.**

**사전 설정 (핵심 차이점)**

```
환경 유형: 고가용성 ✅
```

이 설정만으로 EB는 완전히 다른 아키텍처를 구축합니다.

#### 2단계: 서비스 액세스 (동일)

```
서비스 역할: aws-elasticbeanstalk-service-role
EC2 인스턴스 프로파일: aws-elasticbeanstalk-instance-profile
```

#### 3단계: 네트워킹, 데이터베이스 및 태그 설정

**VPC 설정**

```
VPC: hyechangSpring-vpc
퍼블릭 IP 주소: 비활성화 ❌
```

**퍼블릭 IP 비활성화 이유**: 운영 환경에서는 EC2 인스턴스를 Private Subnet에 배치하여 외부 인터넷으로부터 격리하고, 로드 밸런서를 통해서만 접근하도록 강제합니다.

**인스턴스 서브넷 선택 (핵심 차이점)**

```
인스턴스 서브넷: 
  - hyechangSpring-subnet-private1-ap-northeast-2a ✅
  - hyechangSpring-subnet-private2-ap-northeast-2c ✅
```

**Private Subnet을 선택하는 이유**
- 애플리케이션 서버를 외부 인터넷으로부터 격리
- 로드 밸런서를 통해서만 접근하도록 강제
- 최고 수준의 보안 확보

**로드 밸런서 서브넷 (자동 설정)**

```
로드 밸런서 서브넷: 
  - hyechangSpring-subnet-public1-ap-northeast-2a ✅
  - hyechangSpring-subnet-public2-ap-northeast-2c ✅
```

EB가 자동으로 Public Subnet을 로드 밸런서 배치 위치로 선택합니다.

**데이터베이스 설정**

```
데이터베이스 가용성: 활성화 ✅
데이터베이스 엔진: MySQL 8.0.43
데이터베이스 인스턴스 클래스: db.t3.small
데이터베이스 사용자 이름: produser
데이터베이스 암호: [강력한 암호 입력]
데이터베이스 서브넷: Private Subnet 2개 선택
```

**보안 원칙**: 운영 환경에서는 테스트 환경과 다른 데이터베이스 자격 증명을 사용하는 것이 권장됩니다.

---

#### 4단계: 인스턴스 트래픽 및 크기 조정 구성 (핵심 설정)

이 단계가 운영 환경의 핵심입니다. 여기서 **오토 스케일링**과 **헬스 체크**를 설정합니다.

**용량 설정**

```
환경 유형: 로드 밸런싱된 환경
인스턴스:
  최소: 2
  최대: 4
```

**오토 스케일링 동작 원리**

| 상황 | 인스턴스 수 | ASG의 동작 |
|------|-----------|----------|
| **평상시** | 2대 (최소값) | 항상 최소 2개의 EC2 인스턴스를 유지하며, 로드 밸런서(ELB)를 통해 트래픽 분산 |
| **트래픽 증가 시** | 2 → 3 → 4대 (Scale-Out) | CPU 사용률 등 설정된 지표가 높아지면, 최대 4개까지 새로운 EC2 인스턴스를 자동으로 생성하고 ELB에 연결 |
| **트래픽 감소 시** | 4 → 3 → 2대 (Scale-In) | 트래픽이 줄어들어 지표가 낮아지면, 최소 2개가 될 때까지 불필요한 인스턴스를 자동으로 종료하여 비용 절감 |

**오토 스케일링의 장점**
- ✅ **탄력성**: 트래픽 패턴에 따라 자동으로 용량 조정
- ✅ **비용 최적화**: 필요한 만큼만 리소스 사용
- ✅ **고가용성**: 항상 최소 2대 이상 운영으로 장애 대응

---

**프로세스 설정 (헬스 체크 구성) 🔑**

```
프로세스 추가 버튼 클릭

프로세스 설정:
  이름: default
  포트: 80
  프로토콜: HTTP
  상태 확인 경로: /health  ← 핵심!
  HTTP 코드: 200
  고정성: Disabled
```

**설정 항목 상세 설명**

| 항목 | 설정값 | 역할 |
|------|--------|------|
| **포트** | `80` | ELB가 외부 트래픽을 받는 포트 (HTTP 표준) |
| **프로토콜** | `HTTP` | 통신 프로토콜 |
| **상태 확인 경로** | `/health` | ELB가 인스턴스의 상태를 확인할 때 접속할 경로 |
| **HTTP 코드** | `200` | `/health` 경로로 접속했을 때, 200 OK 응답을 받아야만 인스턴스를 정상(Healthy)으로 판단 |

#### 🏥 `/health` 헬스 체크의 역할

**헬스 체크(Health Check)**는 ELB가 애플리케이션의 '건강 상태'를 자동으로, 그리고 주기적으로 확인하는 핵심 기능입니다.

**1. `/health` 엔드포인트의 역할**

`/health`는 일반적으로 Spring Boot의 **Actuator 모듈**이 제공하는 상태 확인 엔드포인트입니다.

```
요청: GET http://인스턴스-IP:5000/health

응답 (정상):
{
  "status": "UP",
  "components": {
    "db": { "status": "UP" },
    "diskSpace": { "status": "UP" }
  }
}
```

**상태 검사 항목**
- ✅ 데이터베이스 연결 상태
- ✅ 디스크 공간
- ✅ 메모리 사용량
- ✅ 커스텀 비즈니스 로직 상태

**2. 누가 `/health`를 요청하는가? (주체: ELB)**

| 주체 | 요청 빈도 | 목적 |
|------|----------|------|
| **로드 밸런서(ELB)** | 30초마다 (설정 가능) | 각 EC2 인스턴스가 정상적으로 작동하는지 자동 확인 |

**ELB의 자동 요청 과정**

```
매 30초마다:
  ELB → EC2 인스턴스 1: GET /health
  ELB → EC2 인스턴스 2: GET /health
  ELB → EC2 인스턴스 3: GET /health (확장된 경우)
```

**상태 판별 로직**

| 응답 결과 | ELB의 판단 | 트래픽 라우팅 |
|----------|-----------|-------------|
| **200 OK 수신** | 정상(Healthy) | 계속 트래픽 전송 ✅ |
| **오류 코드 또는 시간 초과** | 비정상(Unhealthy) | 트래픽 전송 중단, 오토 스케일링 그룹에 보고 ❌ |

**3. 헬스 체크를 하는 이유**

**시나리오: DB 연결 끊김**

```
인스턴스 상태:
  - 웹 서버(Nginx, Tomcat): 정상 실행 중
  - 애플리케이션(Spring Boot): 실행 중이지만 DB 연결 끊김
  - 실제 비즈니스 로직: 작동 불가 (좀비 상태)
```

| 상태 확인 경로 | 판단 결과 | 문제점 |
|-------------|----------|--------|
| **`/` (루트)** | 인스턴스 살아있음 → 정상 | DB 연결 끊김을 감지 못함 ❌ |
| **`/health`** | DB 연결 끊김 → 비정상 | 좀비 인스턴스 즉시 격리 ✅ |

**헬스 체크의 자동 복구 흐름**

```
1. ELB가 /health 요청 → 인스턴스 A가 503 Service Unavailable 응답
   ↓
2. ELB가 인스턴스 A를 비정상으로 표시
   ↓
3. ELB는 인스턴스 A로 트래픽 전송 중단 (사용자는 정상 인스턴스로만 연결됨)
   ↓
4. 오토 스케일링 그룹(ASG)이 비정상 인스턴스 A를 종료
   ↓
5. ASG가 새로운 정상 인스턴스를 자동으로 생성하여 교체
   ↓
6. 사용자는 서비스 중단을 전혀 느끼지 못함 (무중단 운영)
```

**4. 단일 인스턴스 vs 로드 밸런싱 환경에서의 차이**

| 환경 유형 | 헬스 체크 작동 여부 | 누가 확인하는가? | 주요 목적 |
|----------|------------------|---------------|----------|
| **로드 밸런싱 환경** | 매우 활발하게 작동 | 로드 밸런서(ELB) | 트래픽을 비정상 인스턴스에 보내지 않고, 장애 발생 시 자동으로 인스턴스를 격리/교체 (핵심!) |
| **단일 인스턴스 환경** | 제한적으로 작동 | Elastic Beanstalk 서비스 자체 | 인스턴스가 다운되었는지 여부만 확인. `/health` 경로를 이용한 정교한 애플리케이션 상태 확인의 필요성 및 활용도가 낮음 |

**결론**: `/health` 헬스 체크는 로드 밸런싱 환경에서 무중단 서비스를 보장하기 위한 자동화된 자가진단 시스템입니다.

---

**`application-health.properties` 파일 추가**

헬스 체크를 제대로 활용하려면 Actuator 설정이 필요합니다.

```properties
# application-health.properties

# 1. 모든 Actuator 엔드포인트를 웹을 통해 노출
management.endpoints.web.exposure.include=*

# 2. 헬스 체크 결과에 상세 정보를 항상 포함
management.endpoint.health.show-details=always

# 3. 데이터베이스 헬스 체크를 항상 활성화
management.health.db.enabled=true
```

**설정 효과**
- ✅ `/health` 엔드포인트가 DB 연결 상태 등 내부 상태를 포함하여 응답
- ✅ ELB가 애플리케이션의 실제 건강 상태를 정확히 판단 가능
- ✅ DB 연결 끊김 등의 문제 발생 시 즉시 감지

---

#### 5단계: 업데이트, 모니터링 및 로깅 구성

**환경 속성 설정**

```
환경 속성:
  GRADLE_HOME: /usr/local/gradle
  M2: /usr/local/apache-maven/bin
  M2_HOME: /usr/local/apache-maven
  PROFILES: aws,health  ← 복수 프로파일 활성화!
  SERVER_PORT: 5000
  SPRING_SQL_INIT_MODE: never
```

**`PROFILES=aws,health` 설정의 의미**

복수 프로파일을 활성화하여 설정을 모듈화합니다:

| 프로파일 | 활성화되는 파일 | 역할 |
|---------|--------------|------|
| **`aws`** | `application-aws.properties` | RDS 연결 설정 |
| **`health`** | `application-health.properties` | Actuator 헬스 체크 설정 |

**동작 원리**

```
1. EB 환경 변수: PROFILES=aws,health
   ↓
2. application.properties: spring.profiles.active=${profiles}
   ↓
3. 최종 해석: spring.profiles.active=aws,health
   ↓
4. 활성화: application-aws.properties + application-health.properties
```

**충돌 시 우선순위**: 동일한 속성이 여러 프로파일에 정의된 경우, 나중에 명시된 프로파일(`health`)의 값이 우선 적용됩니다.

---

#### 6단계: 환경 생성 및 확인

`제출` 버튼을 클릭하면 EB가 운영 환경의 복잡한 인프라를 자동으로 구축합니다.

**EB의 자동 작업 (운영 환경)**

1. ✅ **로드 밸런서(ELB) 생성** (Public Subnet에 배치, 2개 AZ에 걸쳐 분산)
2. ✅ **EC2 인스턴스 2대 생성** (Private Subnet에 배치)
3. ✅ **오토 스케일링 그룹(ASG) 구성** (최소 2, 최대 4)
4. ✅ **RDS MySQL 인스턴스 생성** (Private Subnet, 멀티-AZ 가능)
5. ✅ **보안 그룹 구성**:
   - ELB: 인터넷(0.0.0.0/0) → ELB(80번 포트) 허용
   - EC2: ELB → EC2(5000번 포트) 허용
   - RDS: EC2 → RDS(3306번 포트) 허용
6. ✅ **헬스 체크 설정** (ELB가 30초마다 `/health` 요청)
7. ✅ **CloudWatch 모니터링 통합**

**환경 생성 완료**

```
환경 개요
  상태: Ok ✅
  도메인: Spring-demo-prod.eba-xxxxxxx.ap-northeast-2.elasticbeanstalk.com
  로드 밸런서: 활성화 ✅
  인스턴스: 2대 실행 중
```

---

### 🏗️ 운영 환경 아키텍처 최종 구조

```
                    ┌─────────────┐
                    │   Internet  │
                    └──────┬──────┘
                           │ HTTP 요청
                           │
            ┌──────────────▼──────────────┐
            │  Public Subnet (2개 AZ)      │
            │                              │
            │  ┌────────────────────────┐  │
            │  │  Load Balancer (ELB)   │  │ ← 외부 진입점
            │  │  포트 80                │  │
            │  └─────────┬──────────────┘  │
            └────────────┼─────────────────┘
                         │ 트래픽 분산
         ┌───────────────┼───────────────┐
         │               │               │
         ▼               ▼               ▼
┌────────────────┐ ┌────────────────┐ ┌────────────────┐
│ Private Subnet │ │ Private Subnet │ │ Private Subnet │
│                │ │                │ │ (확장 시)      │
│ ┌────────────┐ │ │ ┌────────────┐ │ │ ┌────────────┐ │
│ │ EC2 #1     │ │ │ │ EC2 #2     │ │ │ │ EC2 #3     │ │
│ │ (Spring)   │ │ │ │ (Spring)   │ │ │ │ (Spring)   │ │
│ │ 포트 5000  │ │ │ │ 포트 5000  │ │ │ │ 포트 5000  │ │
│ └─────┬──────┘ │ │ └─────┬──────┘ │ │ └─────┬──────┘ │
└───────┼────────┘ └───────┼────────┘ └───────┼────────┘
        │                  │                  │
        └──────────────────┼──────────────────┘
                           │ DB 접속
                           ▼
                ┌──────────────────┐
                │  Private Subnet  │
                │                  │
                │  ┌────────────┐  │
                │  │    RDS     │  │
                │  │   MySQL    │  │
                │  │  포트 3306 │  │
                │  └────────────┘  │
                └──────────────────┘
```

**보안 레이어**

| 레이어 | 위치 | 외부 접근 | 역할 |
|--------|------|----------|------|
| **1. 로드 밸런서** | Public Subnet | 허용 (80번 포트) | 외부 요청을 받아 정상 인스턴스로만 분산 |
| **2. 애플리케이션** | Private Subnet | 차단 (ELB를 통해서만) | 비즈니스 로직 처리 |
| **3. 데이터베이스** | Private Subnet | 차단 (EC2에서만) | 데이터 저장 및 관리 |

---

### 📊 운영 환경 최종 정리

**환경 구성 요약**

| 항목 | 설정 |
|------|------|
| **환경 이름** | `Spring-demo-prod` |
| **환경 유형** | 로드 밸런싱 |
| **인스턴스 수** | 최소 2, 최대 4 (오토 스케일링) |
| **EC2 서브넷** | Private Subnet 2개 |
| **로드 밸런서** | Public Subnet 2개 |
| **데이터베이스** | RDS MySQL (Private Subnet) |
| **프로파일** | `aws,health` |
| **헬스 체크** | `/health` 경로, 30초마다 확인 |
| **보안** | 3계층 분리 (ELB → EC2 → RDS) |

**운영 환경의 핵심 특징**

| 특징 | 설명 | 효과 |
|------|------|------|
| **고가용성** | 최소 2대의 인스턴스가 항상 실행 | 한 인스턴스 다운 시에도 서비스 지속 |
| **자동 확장** | 트래픽에 따라 2~4대 자동 조정 | 부하 분산 및 비용 최적화 |
| **무중단 헬스 체크** | ELB가 `/health`로 30초마다 확인 | 비정상 인스턴스 자동 격리 및 교체 |
| **보안 강화** | EC2와 RDS를 Private Subnet에 배치 | 외부 공격으로부터 보호 |
| **자동 복구** | ASG가 비정상 인스턴스를 자동 교체 | 운영자 개입 없이 자동 복구 |

---

## 7.2.7 환경별 배포 전략 종합 비교

### 📊 개발/테스트/운영 환경 비교표

| 항목 | 개발 (Dev) | 테스트 (Test) | 운영 (Production) |
|------|-----------|--------------|------------------|
| **환경 이름** | `Spring-demo-dev` | `Spring-demo-test` | `Spring-demo-prod` |
| **인스턴스 구성** | 단일 인스턴스 | 단일 인스턴스 | 로드 밸런싱 (2~4대) |
| **EC2 서브넷** | Public | Public | Private |
| **로드 밸런서** | 없음 | 없음 | 있음 (ELB) |
| **데이터베이스** | H2 (내장) | RDS MySQL | RDS MySQL |
| **데이터 영속성** | 없음 (휘발성) | 있음 (영구 저장) | 있음 (영구 저장) |
| **프로파일** | `dev` | `aws` | `aws,health` |
| **SQL 초기화** | `always` | `never` | `never` |
| **헬스 체크** | 없음 | 제한적 | 활발 (`/health`) |
| **비용** | 최소 | 중간 | 최대 |
| **목적** | 기능 구현, 간편 테스트 | 통합 테스트, 검증 | 실서비스, 무중단 운영 |

---

## 7.2.8 Elastic Beanstalk 사용 후기 및 핵심 교훈

### 💡 EB 사용을 통해 얻은 핵심 가치

#### 1. ⚙️ 환경 구성의 자동화 및 인프라 관리 부담 해소

**IaaS (EC2)와의 비교**

| 작업 | EC2 (IaaS) | Elastic Beanstalk (PaaS) |
|------|------------|--------------------------|
| **JDK 설치** | 매번 수동 설치 및 버전 관리 | 플랫폼 선택만으로 자동 설치 |
| **Tomcat 설치** | 다운로드, 압축 해제, 환경 변수 설정 | WAR 파일 업로드 시 자동 설치 |
| **Nginx 설정** | 포트 포워딩 수동 설정 | 자동 구성 (80 → 5000) |
| **로드 밸런서** | 별도로 생성 및 연결 | 환경 유형 선택만으로 자동 생성 |
| **오토 스케일링** | ASG 수동 구성 | 최소/최대 인스턴스만 지정 |
| **보안 그룹** | 수동으로 규칙 설정 | 자동으로 안전하게 구성 |

**결과**: 개발자는 순수한 JAR/WAR 파일만 준비하여 업로드하면 됩니다.

---

#### 2. 🔄 코드와 환경 설정의 완벽한 분리

**하나의 JAR 파일, 여러 환경**

```
동일한 JAR 파일: Spring-Board-Project-0.0.1-SNAPSHOT.jar

├─ Dev 환경   (PROFILES=dev)        → H2 사용, 포트 5000
├─ Test 환경  (PROFILES=aws)        → RDS MySQL 사용, 포트 5000
└─ Prod 환경  (PROFILES=aws,health) → RDS MySQL + Actuator, 포트 5000
```

**환경 변수를 통한 동적 제어**

| 환경 | 환경 변수 | 활성화되는 설정 | 결과 |
|------|----------|--------------|------|
| **Dev** | `PROFILES=dev` | `application-dev.properties` | H2 내장 DB 사용 |
| **Test** | `PROFILES=aws`, `SPRING_SQL_INIT_MODE=never` | `application-aws.properties` | RDS MySQL 사용, SQL 초기화 안 함 |
| **Prod** | `PROFILES=aws,health`, `SPRING_SQL_INIT_MODE=never` | `application-aws.properties` + `application-health.properties` | RDS MySQL + Actuator 헬스 체크 |

**핵심 장점**
- ✅ 애플리케이션 코드(JAR 파일) 수정 없이 환경 전환
- ✅ 하나의 빌드 결과물로 모든 환경에 배포 가능
- ✅ 관리 효율성 극대화

---

#### 3. 🛡️ 환경별 아키텍처의 손쉬운 분리와 확장성 확보

**환경별 최적화된 인프라**

| 환경 | 인프라 | 구축 방법 | 시간 |
|------|--------|----------|------|
| **Dev/Test** | 단일 EC2 (Public Subnet) | EB 콘솔에서 클릭 몇 번 | 5분 |
| **Prod** | ELB + 2~4대 EC2 (Private Subnet) + 멀티-AZ RDS | EB 콘솔에서 클릭 몇 번 | 10분 |

만약 EC2(IaaS)에서 직접 구축한다면:
- 로드 밸런서 생성 및 리스너 규칙 설정
- 오토 스케일링 그룹 생성 및 정책 설정
- 시작 템플릿 작성
- 보안 그룹 규칙 정의
- CloudWatch 알람 설정
- **예상 소요 시간: 수 시간 ~ 수일**

---

### 🗄️ RDS 사용의 추가적인 이점

#### 데이터베이스 서버 직접 구동 및 관리 부담 해소

| 관리 항목 | EC2에 MySQL 직접 설치 (IaaS) | RDS 사용 (PaaS) |
|----------|----------------------------|----------------|
| **초기 설치** | MySQL 엔진 설치, `my.cnf` 구성, 환경 변수 설정 | AWS가 자동으로 설치 및 구성 |
| **OS 관리** | DB 서버의 OS 패치, 보안 업데이트, 디스크 관리 | AWS가 모든 OS 레벨 관리 및 보안 업데이트 자동 처리 |
| **고가용성** | DB 복제(Replication) 및 장애 조치(Failover)를 수동으로 구축 | 멀티-AZ 배포 시, 자동으로 이중화 및 장애 감지/복구 |
| **백업/복구** | 백업 스크립트 작성, 스토리지 관리, 복구 테스트 | 자동 백업 및 특정 시점 복구(Point-in-time recovery) 기능 자동 제공 |

**결과**: 개발자는 DB 서버의 설치, 보안, 백업, 복구에 신경 쓸 필요 없이, 오직 애플리케이션에 필요한 SQL 스키마와 쿼리에만 집중할 수 있습니다.

---

### 🎯 PaaS를 통한 배포 자동화 완성

**EB + RDS 결합의 시너지**

```
Elastic Beanstalk (EB)
  ↓
애플리케이션의 실행과 확장을 자동화
  +
Amazon RDS
  ↓
데이터베이스의 관리와 안정성을 자동화
  =
진정한 PaaS 경험
```

**개발자의 역할 변화**

| 항목 | IaaS (EC2+ 직접 MySQL) | PaaS (EB + RDS) |
|------|-------------------|-----------------|
| **인프라 관리** | 서버 생성, OS 패치, 보안 업데이트, 미들웨어 설치 | 플랫폼 선택만 |
| **배포** | SCP 전송, 수동 배치, 서버 재시작 | JAR 파일 업로드만 |
| **스케일링** | 수동으로 서버 추가, 로드 밸런서 설정 | 최소/최대 값만 지정 |
| **모니터링** | 별도 도구 설치 및 설정 | CloudWatch 자동 통합 |
| **DB 관리** | 설치, 백업, 복구 스크립트 작성 | RDS가 자동 처리 |
| **집중 영역** | 인프라 + 애플리케이션 | 애플리케이션만 |

---

## 7.2.9 실무 배포 프로세스

### 🔄 일반적인 배포 워크플로

**1. 코드 작성 및 로컬 테스트**

```bash
# 로컬에서 개발 및 테스트
./gradlew bootRun
```

**2. JAR 파일 빌드**

```bash
# 프로젝트 루트 디렉터리에서
./gradlew clean bootJar

# 빌드 결과 확인
ls build/libs/
# Spring-Board-Project-0.0.1-SNAPSHOT.jar
```

**3. EB 콘솔에서 새 버전 업로드**

```
Elastic Beanstalk → 애플리케이션 → spring-demo → 애플리케이션 버전

업로드 버튼 클릭:
  버전 레이블: 2.1.0
  소스: Spring-Board-Project-0.0.1-SNAPSHOT.jar
```

**4. 원하는 환경에 배포**

```
옵션 1: 기존 환경 업데이트 (무중단 배포)
  환경 선택 → Spring-demo-prod → 배포
  새 버전 선택 → 2.1.0
  배포 방법: Rolling (점진적 배포)

옵션 2: 새 환경 생성 (블루-그린 배포)
  새 환경 생성 → Spring-demo-prod-v2
  안정화 후 DNS 전환
```

**5. 배포 확인**

```
환경 상태: Ok ✅
인스턴스: 2대 모두 Healthy
헬스 체크: 통과

브라우저 접속:
http://Spring-demo-prod.eba-xxxxxxx.ap-northeast-2.elasticbeanstalk.com
```

---

### 🚀 고급 배포 전략

#### Rolling 배포 (점진적 배포)

**동작 방식**

```
시작: 4대의 인스턴스 모두 v1.0 실행

1. ELB가 인스턴스 1, 2를 트래픽에서 제외
2. 인스턴스 1, 2에 v2.0 배포 및 시작
3. 헬스 체크 통과 확인
4. ELB가 인스턴스 1, 2를 다시 트래픽에 포함
5. ELB가 인스턴스 3, 4를 트래픽에서 제외
6. 인스턴스 3, 4에 v2.0 배포 및 시작
7. 헬스 체크 통과 확인
8. ELB가 인스턴스 3, 4를 다시 트래픽에 포함

완료: 4대의 인스턴스 모두 v2.0 실행
```

**장점**
- ✅ 서비스 중단 없음 (항상 최소 2대는 실행 중)
- ✅ 추가 비용 없음 (기존 인스턴스만 사용)

**단점**
- ⚠️ 배포 중 용량 감소 (일시적으로 절반만 서비스)

---

#### Blue-Green 배포

**동작 방식**

```
Blue 환경 (현재 운영):
  Spring-demo-prod (v1.0)
  인스턴스 4대
  
Green 환경 (새 버전):
  Spring-demo-prod-v2 (v2.0)
  인스턴스 4대 (새로 생성)

1. Green 환경 완전히 구축 및 테스트
2. DNS를 Blue → Green으로 전환
3. 문제 없으면 Blue 환경 종료
4. 문제 발생 시 DNS를 Blue로 즉시 롤백
```

**장점**
- ✅ 완전한 롤백 가능 (Blue 환경 유지)
- ✅ 배포 중 용량 유지 (두 환경 모두 전체 용량)

**단점**
- 💰 배포 중 비용 2배 (두 환경 동시 운영)

---

### 🚀 7.3장 예고: Docker 배포 (환경 표준화)

7.2장에서 EB(PaaS)의 장점을 충분히 경험했습니다. 하지만 EB도 한계가 있습니다:

**EB의 한계**
- ⚠️ 구체적인 JDK/Tomcat 버전 지정 불가 (AWS가 선택한 버전 사용)
- ⚠️ 플랫폼 브랜치가 업데이트되면 버전이 바뀔 수 있음
- ⚠️ 로컬 개발 환경과 EB 환경의 미묘한 차이 가능성
- ⚠️ 단일 JAR 파일(단일 애플리케이션)만 배포 가능.



## 7.3 도커 배포 (환경 표준화)
---

## 7.4 CI/CD 자동화 (GitHub Actions)
---


