# 07_애플리케이션_배포하기
<!--
# 첫 작성 
docs: [Ch07] 애플리케이션 배포하기 - 틀작성완료
-->
## 📌 학습 목표
스프링 부트 애플리케이션을 다양한 환경에 배포하는 방법을 익히고, 톰캣을 활용한 전통적인 방식부터 AWS 엘라스틱 빈스토크를 이용한 클라우드 배포, 도커를 활용한 컨테이너 기반 배포, 그리고 GitHub Actions를 통한 CI/CD 자동화까지 모두 아우르는 실전 배포 전략을 체계적으로 학습합니다.

---

## 📚 배포 학습 로드맵

이 챕터는 배포 기술의 진화 과정을 따라가며, 각 단계에서 발생하는 문제점을 인식하고 이를 해결하는 더 나은 방법을 학습하는 방식으로 구성되어 있습니다.

### 🎯 단계별 학습 개요

| 단계 | 환경/도구 | 배포 대상 | 학습 목표 |
|------|-----------|-----------|-----------|
| **1단계** | EC2 (IaaS) | WAR 및 JAR | IaaS 환경에서의 수동 배포 경험. Java, Tomcat 수동 설치 및 설정을 통해 인프라 관리의 복잡성을 체감 |
| **2단계** | Elastic Beanstalk (PaaS) | WAR 및 JAR | PaaS의 편리함 체감. 인프라 자동 관리를 통해 개발자가 애플리케이션에 집중할 수 있는 환경 이해 |
| **3단계** | Docker + Beanstalk | JAR (컨테이너화) | 환경 표준화 및 이식성 확보. Docker를 통한 "어디서나 동일하게 실행되는" 애플리케이션 구축 |
| **4단계** | GitHub Actions + Docker + Beanstalk | JAR (컨테이너화) | CI/CD 파이프라인 자동화. 코드 push만으로 빌드-테스트-배포까지 자동 실행되는 실무 환경 구축 |

---

## 목차
- [7.1 톰캣 배포 (IaaS 환경 실습)](#71-톰캣-배포-iaas-환경-실습)
- [7.2 AWS 클라우드 배포 (PaaS 환경 실습)](#72-aws-클라우드-배포)
- [7.3 도커 배포 (환경 표준화)](#73-도커-배포)
- [7.4 CI/CD 자동화 (GitHub Actions)](#74-cicd-자동화)
---

# 7.1 톰캣 배포 (IaaS 환경 실습)

## 📖 학습 개요

**핵심 주제**: IaaS(Infrastructure as a Service) 환경에서의 수동 배포  
**사용 기술**: Apache Tomcat, AWS EC2, WAR/JAR 파일  
**학습 목표**: 
- WAR와 JAR 파일의 차이점과 배포 방식 이해
- 서버 환경을 처음부터 수동으로 구축하고 관리하는 전 과정 체험
- IaaS 환경의 복잡성과 운영 부담 실감

---

## 7.1.1 Apache Tomcat 기본 개념

### 🔍 Tomcat이란?

Apache Tomcat은 Java 서블릿(Servlet)과 JSP(JavaServer Pages)를 실행할 수 있는 **WAS(Web Application Server)**이자 **서블릿 컨테이너**입니다.

### 📦 WAR vs JAR

| 구분 | WAR (Web Application Archive) | JAR (Java Archive) |
|------|-------------------------------|-------------------|
| **용도** | 외부 WAS(Tomcat 등)에 배포 | 독립 실행 가능한 애플리케이션 |
| **WAS** | 외부 Tomcat 필요 | Tomcat 내장 (Embedded) |
| **배포 방식** | WAS의 webapps 디렉터리에 복사 | `java -jar` 명령으로 직접 실행 |
| **컨텍스트 경로** | 파일명이 컨텍스트 경로가 됨 | 기본 루트(/) 경로 |

---

## 7.1.2 로컬 환경에서 Tomcat 실습

### 1단계: Tomcat 다운로드 및 설치

#### 다운로드

[Apache Tomcat 10 다운로드 페이지](https://tomcat.apache.org/download-10.cgi)에서 **Core: zip** 파일을 다운로드합니다.

```
다운로드 파일: apache-tomcat-10.1.49.zip
압축 해제 위치: C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\
```

#### 📂 Tomcat 디렉터리 구조

압축을 해제하면 다음과 같은 핵심 디렉터리 구조를 확인할 수 있습니다.

```
C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\apache-tomcat-10.1.49
├── bin/          ⚙️ 실행 및 종료 스크립트
├── conf/         📝 설정 파일 (server.xml, web.xml 등)
├── lib/          📚 라이브러리 파일
├── logs/         📜 로그 파일 저장소
├── temp/         🗂️ 임시 파일
├── webapps/      📦 웹 애플리케이션 배포 위치
└── work/         🔧 JSP 컴파일 결과물
```

**핵심 디렉터리 설명**

| 디렉터리 | 역할 | 주요 내용 |
|----------|------|-----------|
| **bin** | 실행 스크립트 모음 | `startup.sh/bat`, `shutdown.sh/bat`, `catalina.sh/bat` |
| **conf** | 톰캣 설정 | `server.xml` (포트, 호스트 설정), `web.xml` (서블릿 기본 설정) |
| **webapps** | 애플리케이션 배포 | WAR 파일을 이곳에 복사하면 자동 배포됨 |
| **logs** | 로그 기록 | `catalina.out` (서버 로그), `localhost_access_log.txt` (접근 로그) |

---

### 2단계: Tomcat 실행 준비

#### ✅ Java 환경 변수 설정

Tomcat은 Java로 만들어진 프로그램이므로 JVM이 필요합니다. 따라서 `JAVA_HOME` 환경 변수를 설정해야 합니다.

**Windows 명령 프롬프트에서 환경 변수 설정**

```cmd
C:\...\apache-tomcat-10.1.49> set JAVA_HOME=C:\Program Files\Eclipse Adoptium\jdk-21.0.8.9-hotspot
C:\...\apache-tomcat-10.1.49> set CATALINA_HOME=C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\apache-tomcat-10.1.49
```

**환경 변수 설명**

| 변수명 | 역할 | 설정 예시 |
|--------|------|-----------|
| `JAVA_HOME` | JDK 설치 경로 지정 | `C:\Program Files\Eclipse Adoptium\jdk-21.0.8.9-hotspot` |
| `CATALINA_HOME` | Tomcat 설치 루트 경로 지정 | `C:\Users\ghddm\Downloads\apache-tomcat-10.1.49\apache-tomcat-10.1.49` |

#### 🌐 한글 깨짐 방지 설정

콘솔 로그에서 한글이 깨지지 않도록 UTF-8 인코딩을 설정합니다.

```cmd
C:\...\bin> chcp 65001
Active code page: 65001
```

---

### 3단계: Tomcat 실행 명령어

#### 🚀 서버 시작 및 종료 명령어

| 목적 | Windows | Linux/macOS | 실행 방식 | 용도 |
|------|---------|-------------|-----------|------|
| **서버 시작** | `startup.bat` | `startup.sh` | 백그라운드 | 일반 운영 환경 |
| **서버 시작** | `catalina.bat run` | `catalina.sh run` | 포그라운드 | 디버깅 및 테스트 (로그 실시간 확인) |
| **서버 종료** | `shutdown.bat` | `shutdown.sh` | - | 서버 정상 종료 |

**실행 예시**

```cmd
C:\...\bin> catalina run
```

이 명령을 실행하면 Tomcat 서버가 시작되고 콘솔에 실시간 로그가 출력됩니다.

---

### 4단계: WAR 파일 배포

#### 📦 WAR 파일 준비 및 배포

Spring Boot 프로젝트에서 빌드한 WAR 파일을 Tomcat의 `webapps` 디렉터리에 복사하기만 하면 자동으로 배포가 시작됩니다.

**중요: 파일명 = 컨텍스트 경로**

WAR 파일의 이름이 매우 중요합니다. 파일명이 **애플리케이션의 컨텍스트 경로**가 되기 때문입니다.

| 파일명 | 접속 URL | 설명 |
|--------|----------|------|
| `hyechang.war` | `http://localhost:8080/hyechang/` | `/hyechang` 컨텍스트로 접근 |
| `ROOT.war` | `http://localhost:8080/` | 루트(`/`) 경로로 접근 |

**배포 디렉터리 구조**

```
C:\...\apache-tomcat-10.1.49\webapps\
├── ROOT/                    (기본 홈페이지)
├── docs/                    (Tomcat 문서)
├── examples/                (예제 앱)
├── manager/                 (관리자 페이지)
├── hyechang.war            ✅ 복사한 WAR 파일
└── ROOT.war                ✅ 루트 경로 배포용
```

**배포 실행**

```cmd
C:\...\webapps> dir

2025-11-14  오전 11:50    <DIR>          .
2025-11-14  오전 11:07    <DIR>          ..
2025-11-14  오전 11:07    <DIR>          docs
2025-11-14  오전 11:07    <DIR>          examples
2025-11-12  오후 02:22        50,577,654 hyechang.war
2025-11-14  오전 11:07    <DIR>          manager
2025-11-14  오전 11:07    <DIR>          ROOT
2025-11-12  오후 02:22        50,577,654 ROOT.war
```

Tomcat 서버가 실행 중이라면 자동으로 WAR 파일의 압축을 풀고 애플리케이션을 배포합니다.

**접속 확인**

- `http://localhost:8080/hyechang/` → hyechang.war 애플리케이션 실행
- `http://localhost:8080/` → ROOT.war 애플리케이션 실행

---

### 💡 로컬 환경 실습 정리

로컬 PC에서 Tomcat을 설치하고 WAR 파일을 배포하는 과정을 통해:
- ✅ Tomcat의 디렉터리 구조와 역할 이해
- ✅ WAR 파일 배포의 기본 원리 학습
- ✅ 컨텍스트 경로의 개념 파악

**하지만 실제 웹 서비스 운영을 위해서는 외부에서 접속 가능한 서버가 필요합니다.**

다음 단계에서는 이 모든 과정을 **AWS EC2 인스턴스(클라우드 서버)**에서 직접 구현해봅니다.

---

## 7.1.3 EC2 인스턴스에 WAR 파일 배포

이제 AWS의 가상 서버 환경에서 처음부터 끝까지 수동으로 배포 환경을 구축해봅니다.

### 1단계: EC2 인스턴스 생성

#### AWS 콘솔에서 EC2 인스턴스 생성

| 설정 항목 | 선택 값 | 설명 |
|-----------|---------|------|
| **AMI** | Amazon Linux 2023 | 최신 리눅스 배포판 |
| **인스턴스 타입** | t3.micro | 무료 티어 사용 가능 |
| **키 페어** | springTomcatServer.pem | SSH 접속용 개인 키 (자동 다운로드) |
| **보안 그룹** | 22번 포트 (SSH), 8080번 포트 (Tomcat) 허용 | 외부 접속을 위한 포트 개방 |

**보안 그룹 인바운드 규칙**

| 타입 | 포트 | 소스 | 용도 |
|------|------|------|------|
| SSH | 22 | 0.0.0.0/0 | SSH 터미널 접속 |
| Custom TCP | 8080 | 0.0.0.0/0 | Tomcat 웹 서버 접근 |

인스턴스 생성 후 **퍼블릭 IP**를 확인합니다. (예: `3.38.106.137`)

---

### 2단계: SSH로 EC2 인스턴스 접속

#### 💻 PowerShell에서 SSH 접속

다운로드받은 `.pem` 키 파일을 사용하여 EC2 인스턴스에 원격 접속합니다.

```powershell
PS C:\Users\ghddm> ssh -i "C:\Users\ghddm\Downloads\springTomcatServer.pem" ec2-user@3.38.106.137
```

**접속 과정**

```
The authenticity of host '3.38.106.137 (3.38.106.137)' can't be established.
ED25519 key fingerprint is SHA256:ITRFzyYPw0fMC+tAnuUDDZ+3BxfPAKvaUOYLvgnkGdY.
Are you sure you want to continue connecting (yes/no/[fingerprint])? yes
```

`yes` 입력 후 연결이 성공하면:

```
   ,     #_
   ~\_  ####_        Amazon Linux 2023
  ~~  \_#####\
  ~~     \###|
  ~~       \#/ ___   https://aws.amazon.com/linux/amazon-linux-2023
   ~~       V~' '->
    ~~~         /
      ~~._.   _/
         _/ _/
       _/m/'
[ec2-user@ip-172-31-0-60 ~]$
```

**✅ SSH 연결 성공!** 이제 EC2 리눅스 서버에서 명령어를 실행할 수 있습니다.

---

### 3단계: JDK 설치

Tomcat을 실행하기 위해서는 Java가 필수입니다.

#### ☕ Amazon Corretto JDK 21 설치

```bash
# 시스템 패키지 업데이트
[ec2-user@ip-172-31-0-60 ~]$ sudo dnf update -y

# JDK 21 설치
[ec2-user@ip-172-31-0-60 ~]$ sudo dnf install java-21-amazon-corretto-devel -y
```

#### 🔧 JAVA_HOME 환경 변수 설정

**JDK 설치 경로 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ readlink -f /usr/bin/java | sed "s:bin/java::"
/usr/lib/jvm/java-21-amazon-corretto.x86_64/
```

**환경 변수 영구 등록**

```bash
# 기존 설정 삭제 (있다면)
[ec2-user@ip-172-31-0-60 ~]$ sed -i '/JAVA_HOME/d' ~/.bashrc
[ec2-user@ip-172-31-0-60 ~]$ sed -i '/PATH=$PATH:$JAVA_HOME/d' ~/.bashrc

# 새로운 JAVA_HOME 설정 추가
[ec2-user@ip-172-31-0-60 ~]$ echo 'export JAVA_HOME="/usr/lib/jvm/java-21-amazon-corretto.x86_64"' >> ~/.bashrc
[ec2-user@ip-172-31-0-60 ~]$ echo 'export PATH=$PATH:$JAVA_HOME/bin' >> ~/.bashrc

# 설정 즉시 적용
[ec2-user@ip-172-31-0-60 ~]$ source ~/.bashrc
```

**설정 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ echo $JAVA_HOME
/usr/lib/jvm/java-21-amazon-corretto.x86_64

[ec2-user@ip-172-31-0-60 ~]$ java -version
openjdk version "21.0.9" 2024-10-15 LTS
OpenJDK Runtime Environment Corretto-21.0.9.10.1 (build 21.0.9+10-LTS)
OpenJDK 64-Bit Server VM Corretto-21.0.9.10.1 (build 21.0.9+10-LTS, mixed mode, sharing)
```

✅ **JDK 설치 및 환경 변수 설정 완료**

---

### 4단계: Tomcat 설치

#### 📥 Tomcat 10.1.49 다운로드 및 설치

```bash
# /opt 디렉터리로 이동 (소프트웨어 설치 표준 위치)
[ec2-user@ip-172-31-0-60 ~]$ cd /opt

# Tomcat 다운로드
[ec2-user@ip-172-31-0-60 opt]$ sudo wget https://dlcdn.apache.org/tomcat/tomcat-10/v10.1.49/bin/apache-tomcat-10.1.49.tar.gz

# 압축 해제
[ec2-user@ip-172-31-0-60 opt]$ sudo tar -xzf apache-tomcat-10.1.49.tar.gz

# 디렉터리 이름 변경 (관리 편의성)
[ec2-user@ip-172-31-0-60 opt]$ sudo mv apache-tomcat-10.1.49 tomcat

# 소유권 변경 (ec2-user가 관리할 수 있도록)
[ec2-user@ip-172-31-0-60 opt]$ sudo chown -R ec2-user:ec2-user tomcat
```

#### 🔧 CATALINA_HOME 환경 변수 설정

```bash
# 홈 디렉터리로 이동
[ec2-user@ip-172-31-0-60 opt]$ cd ~

# CATALINA_HOME 설정 추가
[ec2-user@ip-172-31-0-60 ~]$ echo 'export CATALINA_HOME="/opt/tomcat"' >> ~/.bashrc
[ec2-user@ip-172-31-0-60 ~]$ echo 'export PATH=$PATH:$CATALINA_HOME/bin' >> ~/.bashrc

# 설정 즉시 적용
[ec2-user@ip-172-31-0-60 ~]$ source ~/.bashrc
```

**설정 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ echo $CATALINA_HOME
/opt/tomcat
```

✅ **Tomcat 설치 및 환경 변수 설정 완료**

---

### 5단계: WAR 파일 전송

이제 로컬 PC에서 빌드한 WAR 파일을 EC2 서버로 전송합니다.

#### 📤 SCP를 이용한 파일 전송

**로컬 PowerShell에서 실행** (SSH 터미널이 아님!)

```powershell
PS C:\Users\ghddm> scp -i "C:\Users\ghddm\Downloads\springTomcatServer.pem" "C:\Users\ghddm\Desktop\SpringBoot\Spring-Boot-Portfolio\spring-boot-project\Spring-Board-Project\build\libs\Spring-Board-Project-0.0.1-SNAPSHOT-plain.war" ec2-user@3.38.106.137:/tmp/hyechang.war
```

**전송 과정 확인**

```
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war   0%    0     0.0KB/s   --:--
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war   2% 1056KB   1.0MB/s   00:46
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war   4% 1984KB   1.0MB/s   00:46
...
Spring-Board-Project-0.0.1-SNAPSHOT-plain.war 100%   48MB 873.6KB/s   00:56
```

✅ **파일 전송 완료**

---

### 6단계: WAR 파일 배포

#### 📦 webapps 디렉터리로 이동

**SSH 터미널로 돌아와서 실행**

```bash
# /tmp에 파일이 있는지 확인
[ec2-user@ip-172-31-0-60 ~]$ cd /tmp
[ec2-user@ip-172-31-0-60 tmp]$ ls
hyechang.war
hsperfdata_ec2-user
...

# WAR 파일을 Tomcat의 webapps 디렉터리로 이동
[ec2-user@ip-172-31-0-60 tmp]$ sudo mv /tmp/hyechang.war /opt/tomcat/webapps/

# 이동 확인
[ec2-user@ip-172-31-0-60 tmp]$ cd /opt/tomcat/webapps
[ec2-user@ip-172-31-0-60 webapps]$ ls
ROOT  docs  examples  host-manager  hyechang.war  manager
```

✅ **WAR 파일이 webapps 디렉터리에 정상 배치됨**

---

### 7단계: Tomcat 서버 실행

#### 🚀 서버 시작

```bash
[ec2-user@ip-172-31-0-60 webapps]$ startup.sh
Using CATALINA_BASE:   /opt/tomcat
Using CATALINA_HOME:   /opt/tomcat
Using CATALINA_TMPDIR: /opt/tomcat/temp
Using JRE_HOME:        /usr/lib/jvm/java-21-amazon-corretto.x86_64
Using CLASSPATH:       /opt/tomcat/bin/bootstrap.jar:/opt/tomcat/bin/tomcat-juli.jar
Using CATALINA_OPTS:
Tomcat started.
```

**서버 상태 확인**

```bash
[ec2-user@ip-172-31-0-60 webapps]$ ps -ef | grep tomcat
ec2-user  12345  ...  java -Djava.util.logging.config.file=/opt/tomcat/conf/logging.properties ...
```

✅ **Tomcat 서버 실행 성공!**

---

### 8단계: 외부 접속 확인

#### 🌐 웹 브라우저에서 접속

```
http://3.38.106.137:8080/hyechang/
```

애플리케이션이 정상적으로 표시되면 **배포 성공**입니다! 🎉

#### 🛑 서버 종료 방법

```bash
[ec2-user@ip-172-31-0-60 ~]$ shutdown.sh
Using CATALINA_BASE:   /opt/tomcat
Using CATALINA_HOME:   /opt/tomcat
Using CATALINA_TMPDIR: /opt/tomcat/temp
Using JRE_HOME:        /usr/lib/jvm/java-21-amazon-corretto.x86_64
Using CLASSPATH:       /opt/tomcat/bin/bootstrap.jar:/opt/tomcat/bin/tomcat-juli.jar
Using CATALINA_OPTS:
Tomcat stopped.
```

---

### 📊 EC2 WAR 배포 전체 흐름 요약

| 단계 | 실행 환경 | 주요 작업 | 명령어 |
|------|-----------|-----------|--------|
| 1 | AWS 콘솔 | EC2 인스턴스 생성 | 수동 설정 |
| 2 | PowerShell | SSH 접속 | `ssh -i [키] ec2-user@[IP]` |
| 3 | EC2 | JDK 설치 | `sudo dnf install java-21-amazon-corretto-devel -y` |
| 4 | EC2 | Tomcat 설치 | `wget ... && tar -xzf ... && mv ...` |
| 5 | EC2 | 환경 변수 설정 | `echo 'export JAVA_HOME=...' >> ~/.bashrc` |
| 6 | PowerShell | WAR 파일 전송 | `scp -i [키] [파일] ec2-user@[IP]:/tmp/` |
| 7 | EC2 | webapps 배치 | `sudo mv /tmp/hyechang.war /opt/tomcat/webapps/` |
| 8 | EC2 | 서버 실행 | `startup.sh` |
| 9 | 브라우저 | 접속 확인 | `http://[IP]:8080/hyechang/` |

---

## 7.1.4 EC2 인스턴스에 JAR 파일 배포

WAR는 외부 Tomcat이 필요했지만, JAR는 **내장 Tomcat**을 포함하고 있어 독립 실행이 가능합니다.

### 1단계: JAR 파일 전송

#### 📤 SCP로 JAR 파일 전송

**로컬 PowerShell에서 실행**

```powershell
PS C:\Users\ghddm> scp -i "C:\Users\ghddm\Downloads\springTomcatServer.pem" "C:\Users\ghddm\Desktop\SpringBoot\Spring-Boot-Portfolio\spring-boot-project\Spring-Board-Project\build\libs\Spring-Board-Project-0.0.1-SNAPSHOT.jar" ec2-user@3.38.106.137:~/hyechang.jar
```

**전송 결과**

```
Spring-Board-Project-0.0.1-SNAPSHOT.jar   100%   58MB   1.8MB/s   00:32
```

#### ✅ 전송 확인

**SSH 터미널에서 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ cd ~/
[ec2-user@ip-172-31-0-60 ~]$ ls
hyechang.jar
```

---

### 2단계: JAR 파일 실행

#### 🚀 백그라운드 실행 (서버 운영 방식)

```bash
[ec2-user@ip-172-31-0-60 ~]$ nohup java -jar hyechang.jar > application.log 2>&1 &
[1] 27717
```

**명령어 상세 설명**

| 부분 | 역할 | 설명 |
|------|------|------|
| `java -jar hyechang.jar` | 실행 명령 | JVM이 JAR 파일 (내장 Tomcat 포함)을 실행 |
| `nohup` | 영구 실행 | SSH 세션 종료 후에도 프로세스 유지 (No Hang Up) |
| `> application.log` | 로그 저장 | 표준 출력을 파일에 기록 |
| `2>&1` | 에러 리디렉션 | 표준 에러도 같은 파일에 기록 |
| `&` | 백그라운드 실행 | 터미널이 다른 명령어를 받을 수 있도록 백그라운드 실행 |

#### 📋 실행 프로세스 확인

```bash
[ec2-user@ip-172-31-0-60 ~]$ ps -ef | grep java | grep hyechang.jar
ec2-user   27717    2386  1 05:15 pts/1    00:00:25 java -jar hyechang.jar
```

**PID(Process ID) 27717**로 실행 중임을 확인할 수 있습니다.

---

### 3단계: 외부 접속 확인

#### 🌐 웹 브라우저에서 접속

```
http://3.38.106.137:8080/
```

**JAR 파일은 기본적으로 루트(`/`) 경로로 실행됩니다.**

애플리케이션이 정상 표시되면 **배포 성공**입니다! 🎉

---

### 4단계: 서버 종료 방법

#### 🛑 프로세스 종료

**1. 실행 중인 프로세스 찾기**

```bash
[ec2-user@ip-172-31-0-60 ~]$ ps -ef | grep java | grep hyechang.jar
ec2-user   27717    2386  1 05:15 pts/1    00:00:25 java -jar hyechang.jar
```

**2. PID를 사용하여 강제 종료**

```bash
[ec2-user@ip-172-31-0-60 ~]$ kill -9 27717
```

**3. 종료 확인**

```bash
[ec2-user@ip-172-31-0-60 ~]$ ps -ef | grep java | grep hyechang.jar
(결과 없음)
```

✅ **프로세스 종료 완료**

---

### 📊 JAR vs WAR 배포 비교

| 비교 항목 | WAR 배포 | JAR 배포 |
|-----------|----------|----------|
| **WAS 필요** | ⭕ Tomcat 별도 설치 필요 | ❌ 내장 Tomcat 포함 |
| **배포 위치** | `/opt/tomcat/webapps/` | 아무 디렉터리나 가능 (`~/`) |
| **실행 명령** | `startup.sh` (Tomcat 구동) | `java -jar hyechang.jar` |
| **컨텍스트 경로** | 파일명에 따라 결정 (`/hyechang`) | 기본 루트 (`/`) |
| **로그 위치** | `/opt/tomcat/logs/` | `application.log` (지정한 위치) |
| **관리 복잡도** | 높음 (Tomcat 설정 관리 필요) | 낮음 (단순 실행) |
| **포트 변경** | `server.xml` 수정 | `application.properties` 또는 실행 옵션 |

---

## 7.1.5 IaaS 배포의 문제점과 한계

지금까지 EC2 인스턴스에서 수동으로 환경을 구축하고 애플리케이션을 배포하는 전 과정을 경험했습니다. 이 과정을 통해 **IaaS(Infrastructure as a Service) 환경의 본질적인 문제점**을 직접 체감할 수 있었습니다.

### 🚨 주요 문제점

#### 1. 수동 환경 구축의 번거로움

**매번 반복해야 하는 작업들**

```bash
# 서버마다 매번 반복
sudo dnf update -y
sudo dnf install java-21-amazon-corretto-devel -y
cd /opt
sudo wget https://dlcdn.apache.org/tomcat/...
sudo tar -xzf apache-tomcat-10.1.49.tar.gz
sudo mv apache-tomcat-10.1.49 tomcat
sudo chown -R ec2-user:ec2-user tomcat
echo 'export JAVA_HOME=...' >> ~/.bashrc
echo 'export CATALINA_HOME=...' >> ~/.bashrc
source ~/.bashrc
```

**문제점:**
- 서버를 새로 만들 때마다 동일한 설정을 반복해야 함
- 실수로 한 단계를 빠뜨리면 전체 배포 실패
- 설정 과정이 길고 복잡하여 시간 소모가 큼

---

#### 2. 환경 불일치 문제

**로컬 vs 서버 환경 차이**

| 환경 | OS | Java 버전 | Tomcat 버전 | 라이브러리 |
|------|----|-----------|-----------|-----------|
| **로컬 개발** | Windows | JDK 21.0.8 | 10.1.49 | 특정 버전 |
| **EC2 서버** | Amazon Linux | JDK 21.0.9 | 10.1.49 | 다른 버전? |
| **다른 서버** | Ubuntu | JDK 17? | 9.x? | 또 다른 버전? |

**발생 가능한 문제:**
- "내 컴퓨터에서는 잘 되는데 서버에서는 안 돼요" 현상
- Java 버전 차이로 인한 호환성 문제
- 라이브러리 의존성 충돌
- OS별 경로 및 명령어 차이

---

#### 3. 확장성의 어려움

**시나리오: 트래픽 증가로 서버 3대 추가 필요**

```
기존: EC2 1대
↓
필요: EC2 4대 (기존 1대 + 신규 3대)
```

**해야 할 작업:**
- 새로운 EC2 인스턴스 3대 생성
- 각 서버마다 JDK 설치 (3번 반복)
- 각 서버마다 Tomcat 설치 및 설정 (3번 반복)
- 각 서버마다 환경 변수 설정 (3번 반복)
- 각 서버마다 WAR/JAR 파일 전송 및 배포 (3번 반복)
- 로드 밸런서 설정 추가

---

#### 4. 운영 부담 증가

**지속적으로 관리해야 하는 항목들**

| 관리 항목 | 작업 내용 | 빈도 |
|----------|-----------|------|
| **OS 패치** | 보안 업데이트 및 버그 수정 | 월 1~2회 |
| **Java 업데이트** | 새 버전 설치 및 환경 변수 재설정 | 분기별 |
| **Tomcat 업데이트** | 보안 패치 및 버전 업그레이드 | 필요 시 |
| **디스크 관리** | 로그 파일 정리, 디스크 용량 모니터링 | 주간 |
| **프로세스 모니터링** | 서버 다운 여부 확인 및 재시작 | 24시간 |
| **백업** | 애플리케이션 및 데이터 백업 | 일간 |

**문제점:**
- 개발자가 인프라 관리에 많은 시간을 소비
- 애플리케이션 개발보다 서버 운영에 더 많은 리소스 투입
- 휴먼 에러 발생 가능성 높음

---

#### 5. 보안 관리의 복잡성

**직접 관리해야 하는 보안 요소**

```bash
# 방화벽 설정
sudo firewall-cmd --add-port=8080/tcp --permanent

# SSL 인증서 설치 및 갱신
sudo certbot renew

# 사용자 권한 관리
sudo useradd deploy
sudo usermod -aG wheel deploy

# 포트 변경
sudo vi /opt/tomcat/conf/server.xml
```

**문제점:**
- 보안 설정 누락 시 해킹 위험
- SSL 인증서 만료 관리
- 방화벽 규칙 실수로 서비스 중단 가능

---

#### 6. 배포 프로세스의 비효율성

**현재 배포 프로세스**

```
1. 로컬에서 빌드 (Gradle/Maven)
   ↓
2. WAR/JAR 파일 생성
   ↓
3. SCP로 EC2에 파일 전송 (PowerShell)
   ↓
4. SSH로 EC2 접속
   ↓
5. 기존 서버 종료
   ↓
6. 파일 이동/배치
   ↓
7. 서버 재시작
   ↓
8. 브라우저에서 테스트
```

**문제점:**
- 최소 8단계의 수동 작업 필요
- 각 단계에서 실수 가능성 존재
- 배포 시간 약 10~15분 소요
- 배포 중 서비스 중단 (다운타임 발생)

---

#### 7. 모니터링 및 로그 관리의 어려움

**로그 확인 방법**

```bash
# Tomcat WAR 배포 시
[ec2-user@ip-172-31-0-60 ~]$ tail -f /opt/tomcat/logs/catalina.out

# JAR 배포 시
[ec2-user@ip-172-31-0-60 ~]$ tail -f ~/application.log
```

**문제점:**
- 서버마다 SSH로 접속하여 로그 확인 필요
- 여러 서버의 로그를 통합 관리 불가
- 에러 발생 시 실시간 알림 없음
- 로그 파일이 계속 쌓여 디스크 용량 부족 가능

---

### 📊 IaaS 배포의 한계 종합

| 문제 영역 | 구체적 문제점 | 영향 |
|----------|--------------|------|
| **시간** | 초기 설정 시간 증가| 개발 생산성 저하 |
| **비용** | 서버 관리 인력 필요, 시간당 비용 증가 | 운영 비용 증가 |
| **안정성** | 수동 작업으로 인한 휴먼 에러 | 서비스 중단 위험 |
| **확장성** | 서버 추가 시 동일 작업 반복 | 빠른 확장 불가 |
| **일관성** | 환경 차이로 인한 예측 불가능한 문제 | 디버깅 어려움 |

---

### 🎯 다음 단계로: PaaS의 필요성

이러한 모든 문제점들을 해결하기 위해 등장한 것이 바로 **PaaS(Platform as a Service)**입니다.

#### PaaS가 해결하는 문제들

| IaaS의 문제 | PaaS의 해결책 |
|------------|-------------|
| 수동 환경 구축 | 플랫폼이 자동으로 Java, Tomcat 등 설치 |
| 환경 불일치 | 표준화된 실행 환경 제공 |
| 확장 어려움 | 자동 스케일링 (트래픽에 따라 서버 자동 증감) |
| 운영 부담 | OS 패치, 보안 업데이트 자동 처리 |
| 배포 복잡 | WAR/JAR 파일만 업로드하면 자동 배포 |
| 모니터링 부족 | 통합 모니터링 대시보드 제공 |

---

### 📝 실습을 통해 배운 핵심 교훈

#### ✅ 기술적 이해

- **WAR vs JAR의 차이**: 외부 WAS 필요 여부, 컨텍스트 경로, 실행 방식
- **Tomcat의 구조**: bin, conf, webapps, logs 디렉터리의 역할
- **리눅스 서버 관리**: SSH 접속, 패키지 설치, 환경 변수 설정
- **배포의 기본 원리**: 빌드 → 전송 → 배치 → 실행 → 확인

#### ✅ 운영의 현실

- **수동 작업의 한계**: 반복 작업은 자동화가 필수
- **환경 일관성의 중요성**: "내 컴퓨터에서는 되는데" 문제의 근본 원인
- **확장성 고려의 필요성**: 서버 1대 관리와 100대 관리는 완전히 다른 문제
- **개발자의 역할 범위**: 애플리케이션 개발에 집중할 수 있어야 함

---


## 📚 7.1 톰캣 배포 섹션 정리

### ✅ 완료한 학습 내용

| 번호 | 학습 주제 | 핵심 내용 |
|------|----------|-----------|
| 1 | **Tomcat 기본 개념** | WAS의 역할, WAR vs JAR의 차이 |
| 2 | **로컬 Tomcat 실습** | Windows 환경에서 설치, 설정, WAR 배포 |
| 3 | **EC2 환경 구축** | 인스턴스 생성, SSH 접속, 보안 그룹 설정 |
| 4 | **EC2에 WAR 배포** | JDK/Tomcat 수동 설치, WAR 전송 및 배포 |
| 5 | **EC2에 JAR 배포** | 내장 WAS 활용, 백그라운드 실행 |
| 6 | **IaaS 한계 분석** | 수동 관리의 문제점, PaaS 필요성 인식 |

### 🎯 획득한 역량

- ✅ **기본 배포 원리 이해**: 빌드부터 실행까지 전체 흐름 파악
- ✅ **리눅스 서버 관리 경험**: SSH, 패키지 관리, 환경 변수 설정
- ✅ **IaaS 한계 체감**: 자동화와 표준화의 필요성 인식
- ✅ **실전 배포 경험**: 실제 클라우드 환경에서 애플리케이션 서비스


---

## 7.2 AWS 클라우드 배포

---

## 7.3 도커 배포
---

## 7.4 CI/CD 자동화
---

