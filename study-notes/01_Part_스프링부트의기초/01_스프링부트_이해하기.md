# 01_스프링부트_이해하기

## 📌 학습 목표
스프링부트를 시작하기 전에 알아야 할 기본 개념들을 정리하고, 스프링 프레임워크와 스프링부트의 관계를 이해한다.

---

## 1. 스프링 프레임워크란?

### 1.1 정의
**스프링 프레임워크(Spring Framework)** 는 자바 백엔드 애플리케이션 개발을 위한 프레임워크입니다.

- **프레임워크의 의미**: 애플리케이션 개발을 위한 "틀"을 제공
- 개발자가 모든 것을 처음부터 구현하지 않고, 제공된 틀 위에서 개발
- **목적**: 개발 시간 단축 및 유지보수 편의성 향상
- 자바 백엔드 프레임워크 중 가장 인기 있는 프레임워크

### 1.2 스프링 프레임워크의 특징

스프링 프레임워크는 다음 4가지 핵심 특징을 가지고 있습니다:

1. **IoC (Inversion of Control)** - 제어의 역전
2. **DI (Dependency Injection)** - 의존성 주입
3. **AOP (Aspect Oriented Programming)** - 관점 지향 프로그래밍
4. **MVC 구조 지원** - Model-View-Controller 패턴을 사용한 웹 개발

### 1.3 스프링 프레임워크의 단점

편리한 기능을 제공하지만, 다음과 같은 단점이 있습니다:

- ❌ **복잡한 설정**: XML, 애노테이션 등 설정할 부분이 많음
- ❌ **높은 학습 곡선**: 초기 학습 난이도가 높음
- ❌ **의존성 관리 문제**: 라이브러리 버전 관리가 복잡함
- ❌ **배포 서버 구성**: 별도의 WAS(Tomcat 등) 설정이 번거로움

---

## 2. 스프링부트란?

### 2.1 정의
**스프링부트(Spring Boot)** 는 스프링 프레임워크를 더 쉽고 빠르게 사용할 수 있도록 만든 도구입니다.

### 2.2 스프링부트의 장점

스프링 프레임워크의 단점을 해결합니다:

- ✅ **자동 설정(Auto Configuration)**: 복잡한 설정을 자동화
- ✅ **내장 서버 제공**: Tomcat이 내장되어 별도 WAS 불필요
- ✅ **의존성 관리 간소화**: Starter 의존성으로 버전 관리 자동화
- ✅ **빠른 개발 시작**: Spring Initializr로 프로젝트 즉시 생성 가능

> **핵심**: 스프링부트 = 스프링 프레임워크를 더 편하게 사용하는 도구

---

## 3. 스프링 프레임워크 핵심 개념

### 3.1 의존성 주입 (Dependency Injection, DI)

#### 3.1.1 의존성이란?

```java
public class A {
    public void doSomething() {
        B b = new B();  // A 클래스가 B 클래스를 의존
        b.execute();
    }
}
```

- **의존성**: A 클래스가 B 클래스의 기능을 사용하면, "A가 B에 의존한다"라고 표현
- **문제점**: B 클래스를 C 클래스로 변경하려면 A 클래스의 코드를 직접 수정해야 함 → **강한 결합**

#### 3.1.2 느슨한 결합을 위한 해결 방법

```java
// 인터페이스 정의
public interface CoffeeMachine {
    String brew();
}

// 구현체 1
public class DripCoffeeMachine implements CoffeeMachine {
    @Override
    public String brew() {
        return "Brewing coffee with Drip Coffee Machine";
    }
}

// 구현체 2
public class EspressoMachine implements CoffeeMachine {
    @Override
    public String brew() {
        return "Brewing coffee with Espresso Machine";
    }
}

// 사용하는 클래스
public class CoffeeMaker {
    private CoffeeMachine coffeeMachine;

    // Setter를 통한 의존성 주입
    public void setCoffeeMachine(CoffeeMachine coffeeMachine) {
        this.coffeeMachine = coffeeMachine;
    }

    public void makeCoffee() {
        System.out.println(coffeeMachine.brew());
    }
}

// 메인에서 주입
public static void main(String[] args) {
    CoffeeMaker maker = new CoffeeMaker();
    maker.setCoffeeMachine(new EspressoMachine());  // 주입
    maker.makeCoffee();
    
    maker.setCoffeeMachine(new DripCoffeeMachine()); // 교체
    maker.makeCoffee();
}
```

- **장점**: CoffeeMaker 코드 수정 없이 구현체만 교체 가능 → **느슨한 결합**
- 이것이 바로 **의존성 주입(DI)** 의 기본 원리!

---

### 3.2 제어의 역전 (Inversion of Control, IoC)

#### 3.2.1 제어의 주체

**현재 문제점**:
```java
// 개발자가 직접 제어
CoffeeMaker maker = new CoffeeMaker();
maker.setCoffeeMachine(new EspressoMachine());
```

- 객체 생성과 의존성 주입을 **개발자가 직접** 해야 함
- 클래스가 많아지면 관리가 복잡해짐

**해결책**: 제어권을 프레임워크에 넘기자! → **제어의 역전(IoC)**

#### 3.2.2 IoC 구현 방법

스프링에서는 3가지 방법으로 IoC를 구현할 수 있습니다:

1. ✅ **XML 설정 파일**
2. ✅ **애노테이션 (실무에서 주로 사용)**
3. Java Config 클래스 (부수적)

---

### 3.3 방법 1: XML 설정 파일을 통한 IoC

#### 3.3.1 XML 설정 파일 작성

**beans.xml**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans 
       https://www.springframework.org/schema/beans/spring-beans.xsd">

    <!-- 빈 객체 정의 -->
    <bean id="dripCoffeeMachine" class="com.example.demo.DripCoffeeMachine"></bean>
    <bean id="espressoMachine" class="com.example.demo.EspressoMachine"></bean>

    <!-- 의존성 주입 및 초기화 -->
    <bean id="coffeeMaker" class="com.example.demo.CoffeeMaker" init-method="makeCoffee">
        <property name="coffeeMachine" ref="espressoMachine"></property>
    </bean>
</beans>
```

#### 3.3.2 XML 태그 설명

| 태그/속성 | 설명 | 예시 |
|---------|------|------|
| `<bean>` | 스프링 컨테이너에 등록할 객체(빈) 정의 | `<bean id="..." class="...">` |
| `id` | 빈의 고유 식별자 | `id="espressoMachine"` |
| `class` | 생성할 클래스의 전체 경로(패키지명 포함) | `class="com.example.demo.EspressoMachine"` |
| `init-method` | 빈 생성 직후 자동 호출될 메서드 지정 | `init-method="makeCoffee"` |
| `<property>` | Setter 메서드를 통한 의존성 주입 | `<property name="coffeeMachine" ref="...">` |
| `name` | 주입할 필드명 (Setter 메서드의 이름과 매칭) | `name="coffeeMachine"` → `setCoffeeMachine()` |
| `ref` | 참조할 다른 빈의 id | `ref="espressoMachine"` |

> **중요**: `init-method`로 지정된 메서드는 빈 생성과 동시에 자동 실행됩니다!

#### 3.3.3 애플리케이션에 XML 적용

```java
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.annotation.ImportResource;

@SpringBootApplication
@ImportResource("classpath:beans.xml")  // XML 설정 파일 로드
public class DemoApplication {
    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }
}
```

**실행 결과**:
```
Brewing coffee with Espresso Machine
```

- 개발자가 `new` 키워드를 사용하지 않았지만 객체가 생성되고 실행됨!
- 이것이 바로 **제어의 역전(IoC)**

#### 3.3.4 XML 방식의 단점

- ❌ 복잡한 XML 문법을 익혀야 함
- ❌ 코드가 길어지면 XML도 같이 길어짐
- ❌ 타입 안정성이 부족함 (컴파일 시점에 오류 확인 불가)

---

### 3.4 방법 2: 애노테이션을 통한 IoC (⭐ 실무에서 사용)

#### 3.4.1 스프링 컨테이너란?

**스프링 컨테이너**는 빈 객체들을 관리하는 가상의 공간입니다.

**주요 역할**:
1. 빈 객체 생성 및 초기화
2. 의존성 자동 주입
3. 빈의 생명주기 관리 (생성 → 사용 → 소멸)
4. 싱글톤 패턴 관리 (기본적으로 빈은 1개만 생성)

> XML로 만든 빈도, 애노테이션으로 만든 빈도 모두 스프링 컨테이너에서 관리됩니다!

#### 3.4.2 핵심 애노테이션

##### @Component

```java
@Component
public class EspressoMachine implements CoffeeMachine {
    @Override
    public String brew() {
        return "Brewing coffee with Espresso Machine";
    }
}
```

- **역할**: 이 클래스를 빈으로 등록해달라는 선언
- **동작**: 스프링부트가 자동으로 객체 생성 → 스프링 컨테이너에 등록
- XML의 `<bean>` 태그와 동일한 역할

> **중요**: `@Component`가 붙은 클래스는 기본적으로 **싱글톤**으로 생성됩니다. 즉, 애플리케이션 전체에서 1개의 인스턴스만 존재합니다.

##### @Autowired

```java
@Component
public class CoffeeMaker {
    @Autowired
    private CoffeeMachine coffeeMachine;  // 자동 주입

    public void makeCoffee() {
        System.out.println(coffeeMachine.brew());
    }
}
```

- **역할**: 스프링 컨테이너에서 타입이 일치하는 빈을 자동으로 주입
- Setter 메서드 없이도 의존성 주입 가능!
- XML의 `<property>` 태그와 동일한 역할

##### @PostConstruct

```java
@Component
public class CoffeeMaker {
    @Autowired
    private CoffeeMachine coffeeMachine;

    @PostConstruct  // 초기화 메서드
    public void makeCoffee() {
        System.out.println(coffeeMachine.brew());
    }
}
```

- **역할**: 빈 생성과 의존성 주입이 완료된 후 자동 실행될 메서드 지정
- XML의 `init-method` 속성과 동일한 역할

#### 3.4.3 빈 생성 및 초기화 순서

```
1. @SpringBootApplication 실행
   ↓
2. @Component 스캔 (모든 @Component 클래스 찾기)
   ↓
3. 빈 객체 생성 (new 연산자로 인스턴스 생성)
   ↓
4. @Autowired 의존성 주입
   ↓
5. @PostConstruct 초기화 메서드 실행
```

**핵심**: `SpringApplication.run()` 실행 시 위 과정이 자동으로 이루어집니다!

#### 3.4.4 같은 타입의 빈이 여러 개일 때

**문제 상황**:
```java
@Component
public class DripCoffeeMachine implements CoffeeMachine { ... }

@Component
public class EspressoMachine implements CoffeeMachine { ... }

@Component
public class CoffeeMaker {
    @Autowired
    private CoffeeMachine coffeeMachine;  // 어떤 빈을 주입해야 할까? ❌
}
```

**해결 방법 1: @Primary 사용**

```java
@Component
@Primary  // 우선순위 지정
public class DripCoffeeMachine implements CoffeeMachine {
    @Override
    public String brew() {
        return "Brewing coffee with Drip Coffee Machine";
    }
}
```

- 여러 빈 중 `@Primary`가 붙은 빈이 우선적으로 주입됨

**해결 방법 2: @Qualifier 사용**

```java
// 빈 이름 지정
@Component("drip")
public class DripCoffeeMachine implements CoffeeMachine { ... }

@Component("espresso")
public class EspressoMachine implements CoffeeMachine { ... }

// 주입할 빈 이름 명시
@Component
public class CoffeeMaker {
    @Autowired
    @Qualifier("drip")  // "drip" 빈을 주입
    private CoffeeMachine coffeeMachine;
}
```

**해결 방법 3: List로 모두 주입**

```java
@Component
public class CoffeeMaker {
    @Autowired
    private List<CoffeeMachine> coffeeMachines;  // 모든 CoffeeMachine 빈이 리스트로 주입됨

    public void makeCoffee() {
        coffeeMachines.forEach(machine -> 
            System.out.println(machine.brew())
        );
    }
}
```

---

### 3.5 관점 지향 프로그래밍 (Aspect Oriented Programming, AOP)

#### 3.5.1 AOP란?

**객체 지향 프로그래밍(OOP)** vs **관점 지향 프로그래밍(AOP)**

- **OOP**: 상속을 통한 수직적 확장
- **AOP**: 공통 관심사를 수평적으로 적용

**핵심 개념**:
- 여러 클래스/메서드에서 **공통으로 필요한 기능**(로깅, 시간 측정, 트랜잭션 등)을 분리
- 애노테이션을 통해 필요한 곳에 자유롭게 적용
- 코드 중복 제거 및 유지보수성 향상

**예시**: A 클래스의 method1()과 B 클래스의 method2() 모두 실행 시간을 측정하고 싶다면?

```java
// AOP 사용 전 - 중복 코드 발생
class A {
    void method1() {
        long start = System.currentTimeMillis();
        // 실제 로직
        long end = System.currentTimeMillis();
        System.out.println("실행 시간: " + (end - start));
    }
}

class B {
    void method2() {
        long start = System.currentTimeMillis();
        // 실제 로직
        long end = System.currentTimeMillis();
        System.out.println("실행 시간: " + (end - start));  // 중복!
    }
}
```

```java
// AOP 사용 후 - 애노테이션만 추가
class A {
    @MeasureExecutionTime  // 공통 관심사를 애노테이션으로 적용
    void method1() {
        // 실제 로직만 작성
    }
}

class B {
    @MeasureExecutionTime  // 같은 애노테이션을 자유롭게 사용
    void method2() {
        // 실제 로직만 작성
    }
}
```

#### 3.5.2 AOP 구현하기

##### 1단계: 의존성 추가

**build.gradle**
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-aop'
}
```

> ⚠️ 의존성 추가 후 반드시 **Gradle 동기화** 필요!

##### 2단계: 커스텀 애노테이션 생성

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.METHOD)          // 메서드에만 사용 가능
@Retention(RetentionPolicy.RUNTIME)  // 런타임에 적용
public @interface HelloAnnotation {
}
```

**애노테이션 메타 애노테이션 설명**:

| 애노테이션 | 설명 |
|----------|------|
| `@interface` | 이것이 애노테이션임을 선언 |
| `@Target(ElementType.METHOD)` | 이 애노테이션을 메서드에만 적용 가능하도록 제한 |
| `@Target(ElementType.TYPE)` | 클래스/인터페이스에 적용 |
| `@Retention(RetentionPolicy.RUNTIME)` | 런타임에 애노테이션 정보 유지 (리플렉션 사용 가능) |
| `@Retention(RetentionPolicy.CLASS)` | 컴파일 시점까지만 유지 |

##### 3단계: Aspect 클래스 작성 (⭐ 가장 중요)

```java
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.springframework.stereotype.Component;

@Component  // 스프링 빈으로 등록
@Aspect     // 이 클래스가 Aspect(관점)임을 선언
public class HelloAnnotationAspect {

    @Around("@annotation(HelloAnnotation)")  // HelloAnnotation이 붙은 메서드를 감싼다
    public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
        
        // 실제 메서드 실행 전 수행할 로직
        System.out.println("HelloAnnotationAspect start");
        
        // 실제 메서드 실행 (애노테이션이 붙은 메서드)
        var object = joinPoint.proceed();
        
        // 실제 메서드 실행 후 수행할 로직
        System.out.println("HelloAnnotationAspect end");
        
        return object;
    }
}
```

**핵심 개념**:

| 요소 | 설명 |
|-----|------|
| `@Aspect` | 이 클래스가 횡단 관심사를 처리하는 Aspect 클래스임을 선언 |
| `@Around` | 메서드 실행 전후를 "감싸서" 추가 로직 실행 |
| `@annotation(HelloAnnotation)` | `@HelloAnnotation`이 붙은 모든 메서드에 적용 |
| `ProceedingJoinPoint` | 실제 호출된 메서드의 정보를 담고 있는 객체 |
| `joinPoint.proceed()` | 실제 메서드 실행 (이 호출 전/후로 코드 배치) |

**동작 순서**:
```
1. @HelloAnnotation이 붙은 메서드 호출
   ↓
2. Aspect의 around() 메서드 진입
   ↓
3. "HelloAnnotationAspect start" 출력
   ↓
4. joinPoint.proceed() → 실제 메서드 실행
   ↓
5. "HelloAnnotationAspect end" 출력
   ↓
6. 결과 반환
```

##### 4단계: 애노테이션 사용

```java
@Component
public class MyService {
    
    @HelloAnnotation  // Aspect 적용
    public void doSomething() {
        System.out.println("실제 비즈니스 로직 실행");
    }
}
```

**실행 결과**:
```
HelloAnnotationAspect start
실제 비즈니스 로직 실행
HelloAnnotationAspect end
```

#### 3.5.3 AOP 어드바이스 타입

Aspect가 실행되는 시점에 따라 5가지 어드바이스를 사용할 수 있습니다:

| 어드바이스 | 실행 시점 | 사용 예시 |
|----------|---------|----------|
| `@Before` | 메서드 실행 **전** | 매개변수 로깅, 사전 검증 |
| `@After` | 메서드 실행 **후** (성공/실패 무관) | 리소스 정리, 로깅 |
| `@AfterReturning` | 메서드 **정상 종료 후** | 반환값 로깅, 후처리 |
| `@AfterThrowing` | 메서드 **예외 발생 후** | 예외 로깅, 알림 전송 |
| `@Around` | 메서드 실행 **전후 모두** | 실행 시간 측정, 트랜잭션 |

**예시: @Before**
```java
@Before("@annotation(HelloAnnotation)")
public void before(JoinPoint joinPoint) {
    Object[] args = joinPoint.getArgs();  // 메서드 매개변수 가져오기
    System.out.println("매개변수 개수: " + args.length);
}
```

**예시: @AfterReturning**
```java
@AfterReturning(pointcut = "@annotation(HelloAnnotation)", returning = "result")
public void afterReturning(Object result) {
    System.out.println("반환값: " + result);
}
```

**예시: 실행 시간 측정 (실무 활용)**
```java
@Around("@annotation(MeasureExecutionTime)")
public Object measureExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    long start = System.currentTimeMillis();
    
    Object result = joinPoint.proceed();
    
    long end = System.currentTimeMillis();
    System.out.println("실행 시간: " + (end - start) + "ms");
    
    return result;
}
```

---

## 4. 오늘 배운 애노테이션 정리

### 4.1 IoC/DI 관련

| 애노테이션 | 역할 | 예시 |
|-----------|------|------|
| `@SpringBootApplication` | 스프링부트 애플리케이션 시작점 | 메인 클래스에 사용 |
| `@Component` | 클래스를 빈으로 등록 | 일반 클래스 |
| `@Autowired` | 타입에 맞는 빈을 자동 주입 | 필드, 생성자, Setter에 사용 |
| `@Primary` | 같은 타입의 빈이 여러 개일 때 우선순위 지정 | `@Component`와 함께 사용 |
| `@Qualifier("빈이름")` | 주입받을 빈의 이름을 명시 | `@Autowired`와 함께 사용 |
| `@PostConstruct` | 빈 초기화 후 자동 실행될 메서드 지정 | 초기화 로직 |
| `@ImportResource` | XML 설정 파일 로드 | `@ImportResource("classpath:beans.xml")` |

### 4.2 AOP 관련

| 애노테이션 | 역할 | 예시 |
|-----------|------|------|
| `@Aspect` | 횡단 관심사를 처리하는 클래스임을 선언 | Aspect 클래스에 사용 |
| `@Around` | 메서드 실행 전후 로직 실행 | 실행 시간 측정 |
| `@Before` | 메서드 실행 전 로직 실행 | 매개변수 검증 |
| `@After` | 메서드 실행 후 로직 실행 (예외 무관) | 리소스 정리 |
| `@AfterReturning` | 메서드 정상 종료 후 로직 실행 | 반환값 로깅 |
| `@AfterThrowing` | 메서드 예외 발생 후 로직 실행 | 예외 처리 |
| `@Target` | 애노테이션을 적용할 대상 지정 | `ElementType.METHOD` |
| `@Retention` | 애노테이션 정보 유지 정책 지정 | `RetentionPolicy.RUNTIME` |

---

## 5. 핵심 요약

### 5.1 스프링 프레임워크와 스프링부트

```
스프링 프레임워크
    ↓ (복잡한 설정, 높은 학습 곡선)
스프링부트 = 스프링 프레임워크를 쉽게 사용하는 도구
    ↓ (자동 설정, 내장 서버, 간편한 의존성 관리)
빠른 개발 가능!
```

### 5.2 IoC와 DI

**전통적인 방식**:
```java
// 개발자가 제어
A a = new A();
B b = new B();
a.setB(b);
```

**스프링 방식**:
```java
// 프레임워크가 제어 (IoC)
@Component
class A {
    @Autowired  // 자동 주입 (DI)
    private B b;
}
```

### 5.3 AOP의 핵심

- **공통 관심사**(로깅, 시간 측정, 트랜잭션 등)를 **횡단으로 적용**
- 애노테이션을 통해 필요한 곳에만 선택적으로 적용
- 코드 중복 제거 및 관심사의 분리

---

## 6. 자주 묻는 질문 (FAQ)

### Q1. 빈은 몇 개 생성되나요?
**A.** 기본적으로 **싱글톤(Singleton)** 으로 1개만 생성됩니다. 여러 개가 필요하면 `@Scope("prototype")`을 사용해야 합니다.

```java
@Component
@Scope("prototype")  // 요청할 때마다 새로운 인스턴스 생성
public class MyBean { }
```

### Q2. XML vs 애노테이션, 뭘 사용해야 하나요?
**A.** 실무에서는 **애노테이션**을 압도적으로 많이 사용합니다. XML은 레거시 프로젝트에서 볼 수 있습니다.

### Q3. Component, Service, Repository의 차이는?
**A.** 기능은 동일하지만, **역할을 명확히** 하기 위해 구분합니다:

| 애노테이션 | 역할 | 사용 위치 |
|-----------|------|----------|
| `@Component` | 일반적인 스프링 빈 | 범용 |
| `@Service` | 비즈니스 로직 계층 | Service 클래스 |
| `@Repository` | 데이터 접근 계층 | DAO 클래스 |
| `@Controller` | 프레젠테이션 계층 | 웹 컨트롤러 |

> 모두 내부적으로 `@Component`를 포함하고 있습니다!

### Q4. Autowired는 어디에 붙여야 하나요?
**A.** 3가지 방법이 있으며, **생성자 주입**이 권장됩니다:

```java
// 1. 필드 주입 (간단하지만 테스트 어려움)
@Autowired
private MyService myService;

// 2. Setter 주입
@Autowired
public void setMyService(MyService myService) {
    this.myService = myService;
}

// 3. 생성자 주입 (권장!) - 불변성 보장
@Autowired  // 생성자가 1개면 생략 가능
public MyClass(MyService myService) {
    this.myService = myService;
}
```

### Q5. PostConstruct는 언제 사용하나요?
**A.** 빈이 완전히 초기화된 후 **한 번만** 실행할 작업이 있을 때 사용합니다:

```java
@Component
public class DataInitializer {
    
    @Autowired
    private DatabaseService dbService;
    
    @PostConstruct
    public void init() {
        // 애플리케이션 시작 시 초기 데이터 로드
        dbService.loadInitialData();
    }
}
```

### Q6. Around와 Before의 차이는?
**A.**

- `@Around`: 메서드 실행 **제어 가능** (`proceed()` 호출 필요), 반환값 조작 가능
- `@Before`: 메서드 실행 전에만 동작, 실행 제어 불가

```java
// @Around - proceed() 호출을 통해 실행 제어
@Around("@annotation(MyAnnotation)")
public Object around(ProceedingJoinPoint joinPoint) throws Throwable {
    // 조건에 따라 실행 여부 결정 가능
    if (condition) {
        return joinPoint.proceed();  // 실행
    } else {
        return null;  // 실행 안 함
    }
}

// @Before - 항상 메서드 실행됨
@Before("@annotation(MyAnnotation)")
public void before(JoinPoint joinPoint) {
    // 메서드 실행 전 로직만 추가 가능
    // 메서드 실행을 막을 수 없음
}
```

---
