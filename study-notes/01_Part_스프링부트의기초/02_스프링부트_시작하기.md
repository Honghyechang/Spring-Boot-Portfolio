# 02_스프링부트_시작하기

## 📌 학습 목표
스프링부트 개발을 위한 환경을 구축하고, 프로젝트 시작에 필요한 기본 개념과 도구들을 이해합니다.

---

## 1. 스프링부트 개발 환경 구축

스프링부트 애플리케이션 개발에 필요한 도구들을 설치하고 설정합니다.

### 1.1 개발 도구 목록

| 도구 | 용도 | 사용 버전 |
|-----|------|----------|
| JDK | 자바 개발 및 실행 환경 | Temurin (OpenJDK) |
| IntelliJ IDEA | 통합 개발 환경 (IDE) | 2024.3.4.1 |
| MySQL | 데이터베이스 | 8.4 (포트: 3306) |
| DBeaver | 데이터베이스 관리 도구 | Community 25.2.2 |
| Postman | API 테스트 도구 | 11 |

---

## 2. JDK (Java Development Kit)

### 2.1 JDK란?

**JDK (Java Development Kit)** 는 자바 애플리케이션을 **개발**하고 **실행**하는 데 필요한 도구 모음입니다.

**주요 구성 요소**:
- **JRE (Java Runtime Environment)**: 자바 프로그램 실행 환경
- **컴파일러 (javac)**: `.java` → `.class` 파일로 컴파일
- **JVM (Java Virtual Machine)**: 바이트코드(.class)를 실행
- **개발 도구**: 디버거, 프로파일러 등

### 2.2 JDK의 역할

#### 개발 환경에서
```
인텔리제이 → 내장 JDK 사용 → 코드 작성 및 컴파일
```
- 인텔리제이는 자체 JDK를 가지고 있어 별도 설치 불필요
- 프로젝트별로 다른 JDK 버전 선택 가능

#### 배포 환경에서
```
서버에 JDK 설치 → java -jar myapp.jar 명령으로 실행
```
- **핵심**: 서버(운영 환경)에서는 **반드시 JDK 설치 필요**
- `.jar` 파일만 가지고는 실행 불가
- 프로젝트를 다른 사람에게 전달할 때도, 상대방은 JDK가 있어야 실행 가능

### 2.3 Oracle JDK vs OpenJDK

| 구분 | 라이선스 | 비용 | 특징 |
|-----|---------|------|------|
| **Oracle JDK** | BCL (Binary Code License) | 상용 서비스는 유료 | 오라클 공식 배포판 |
| **OpenJDK** | GPL (GNU General Public License) | 무료 | 오픈소스 기반 |

**BCL 라이선스의 문제점**:
- "일반적인 목적의 컴퓨팅"이라는 애매한 조건
- 상용 서비스 배포 시 **라이선스 비용 발생 가능**

### 2.4 Temurin (권장)

**Adoptium 프로젝트의 Temurin 배포판 사용**

**선택 이유**:
- ✅ OpenJDK 기반 (완전 무료)
- ✅ Oracle JDK와 동일한 스펙
- ✅ 상용 서비스에도 라이선스 걱정 없음
- ✅ 장기 지원 (LTS) 버전 제공

> **결론**: 이번 프로젝트에서는 **Temurin 배포판**을 사용하여 라이선스 비용 없이 개발 및 배포를 진행합니다.

---

## 3. IntelliJ IDEA

### 3.1 IDE란?

**IDE (Integrated Development Environment)** = 통합 개발 환경

**주요 기능**:
- 코드 작성 및 편집 (자동완성, 리팩토링)
- 컴파일 및 실행
- 디버깅 (중단점, 변수 확인)
- 버전 관리 (Git 통합)
- 데이터베이스 연동

### 3.2 사용 버전
- **IntelliJ IDEA 2024.3.4.1**
- Community Edition (무료) 또는 Ultimate Edition (유료, 학생/교육용 무료)

**Ultimate의 추가 기능**:
- Spring Boot 고급 지원
- 데이터베이스 도구
- 웹 개발 도구 (JavaScript, HTML)

---

## 4. MySQL

### 4.1 데이터베이스

**MySQL**은 세계에서 가장 많이 사용되는 오픈소스 관계형 데이터베이스(RDBMS)입니다.

### 4.2 설정 정보

```properties
# 사용 버전
MySQL 8.4

# 연결 정보
호스트: localhost
포트: 3306
사용자: root
비밀번호: (설치 시 설정한 비밀번호)
```

### 4.3 특징
- ✅ 무료 오픈소스
- ✅ 높은 성능과 안정성
- ✅ 풍부한 커뮤니티 및 자료
- ✅ 다양한 스토리지 엔진 (InnoDB, MyISAM 등)

---

## 5. DBeaver

### 5.1 역할

**DBeaver**는 데이터베이스 관리 도구 (Database Management Tool)입니다.

**사용 목적**:
1. **데이터베이스 연결 확인**: MySQL이 정상 작동하는지 확인
2. **초기 데이터 구축**: 테이블 생성, 초기 데이터 삽입
3. **SQL 쿼리 실행**: 직접 SQL 문 작성 및 실행
4. **데이터 모니터링**: 실시간 데이터 확인 및 분석
5. **데이터베이스 설계**: ERD (Entity-Relationship Diagram) 생성

### 5.2 사용 버전
- **DBeaver Community 25.2.2** (무료 버전)

### 5.3 DBeaver vs MySQL Workbench

| 특징 | DBeaver | MySQL Workbench |
|-----|---------|-----------------|
| 지원 DB | 다양한 DB 지원 | MySQL 전용 |
| 사용성 | 직관적 | MySQL에 최적화 |
| 기능 | 범용적 | MySQL 심화 기능 |

> **결론**: 여러 데이터베이스를 다룰 수 있는 **DBeaver 권장**

---

## 6. Postman

### 6.1 RESTful API 서버란?

스프링부트로 개발하는 애플리케이션은 크게 2가지 형태로 구분됩니다:

#### 1) 웹 서버 (전통적인 방식)
```
브라우저 → 서버 요청 → HTML 페이지 렌더링 → 브라우저에 표시
```
- **특징**: 서버에서 HTML을 생성하여 전달 (SSR - Server Side Rendering)
- **테스트**: 브라우저로 직접 접속하여 확인 가능

#### 2) RESTful API 서버 (현대적인 방식)
```
모바일 앱/프론트엔드 → 서버 요청 → JSON/XML 데이터만 반환
```
- **특징**: 데이터만 제공, 화면은 클라이언트가 처리
- **HTTP 메서드**: GET, POST, PUT, DELETE 등을 사용하여 자원(Resource) 조작
- **테스트**: 브라우저만으로는 테스트 어려움 (POST, PUT, DELETE 등)

**RESTful API의 예시**:
```
GET    /api/users      → 사용자 목록 조회
POST   /api/users      → 사용자 생성
GET    /api/users/1    → 특정 사용자 조회
PUT    /api/users/1    → 사용자 정보 수정
DELETE /api/users/1    → 사용자 삭제
```

### 6.2 Postman의 역할

**Postman**은 RESTful API를 테스트하는 클라이언트 도구입니다.

**사용 목적**:
1. **API 테스트**: 다양한 HTTP 메서드(GET, POST, PUT, DELETE) 테스트
2. **요청/응답 확인**: Header, Body, Status Code 등 상세 정보 확인
3. **독립적 테스트**: 모바일 앱이나 프론트엔드 없이 백엔드만 테스트
4. **API 문서화**: 테스트한 API를 문서로 저장 및 공유
5. **자동화 테스트**: 여러 API를 순차적으로 테스트

### 6.3 사용 버전
- **Postman 11**

### 6.4 Postman vs 브라우저

| 기능 | Postman | 브라우저 |
|-----|---------|---------|
| GET 요청 | ✅ | ✅ |
| POST 요청 | ✅ | ❌ (Form 제출만 가능) |
| PUT/DELETE | ✅ | ❌ |
| Header 설정 | ✅ | ❌ |
| Body 설정 | ✅ (JSON, XML 등) | ❌ |

---

## 7. Spring Initializr

### 7.1 Spring Initializr란?

**모든 스프링부트 프로젝트는 Spring Initializr로 시작합니다.**

**접근 방법**:
1. **웹 사이트**: https://start.spring.io
2. **IntelliJ IDEA**: New Project → Spring Initializr

### 7.2 프로젝트 생성 과정

#### 1단계: 기본 설정
```
Project: Gradle (또는 Maven)
Language: Java
Spring Boot: 3.x.x (최신 안정 버전)
```

#### 2단계: 프로젝트 메타데이터
```
Group: com.example
Artifact: demo
Name: demo
Package name: com.example.demo
Packaging: Jar (또는 War)
Java: 17 (또는 21)
```

#### 3단계: 의존성 선택
```
- Spring Web
- Spring Data JPA
- MySQL Driver
- Lombok
- Spring Boot DevTools
```

#### 4단계: 생성 및 다운로드
```
Generate 버튼 클릭 → ZIP 파일 다운로드 → 압축 해제 → IntelliJ에서 열기
```

### 7.3 JAR vs WAR

#### JAR (Java ARchive) - ⭐ 권장

```bash
# 실행 방법
java -jar myapp.jar
```

**특징**:
- ✅ **톰캣 서버 내장** (별도 WAS 불필요)
- ✅ 독립 실행 가능
- ✅ 스프링부트의 기본 권장 방식
- ✅ 마이크로서비스, 클라우드 환경에 적합
- ✅ 배포 간편 (단일 파일)

**사용 시나리오**:
- AWS, Azure 등 클라우드 배포
- Docker 컨테이너화
- 마이크로서비스 아키텍처

#### WAR (Web application ARchive)

```bash
# 외부 톰캣에 배포 필요
cp myapp.war /tomcat/webapps/
```

**특징**:
- ❌ **외부 WAS 필요** (Tomcat, JBoss 등을 별도 설치)
- ❌ 배포 복잡 (WAS 설정 필요)
- ❌ 레거시 환경에서 주로 사용

**사용 시나리오**:
- 기존 톰캣 서버가 이미 구축된 환경
- 여러 애플리케이션을 하나의 WAS에서 운영

### 7.4 JAR vs WAR 비교표

| 항목 | JAR | WAR |
|-----|-----|-----|
| 톰캣 서버 | 내장 | 외부 필요 |
| 실행 방법 | `java -jar` | WAS에 배포 |
| 배포 난이도 | 쉬움 | 복잡 |
| 권장 용도 | 현대적 배포 | 레거시 환경 |
| 스프링부트 권장 | ✅ | ❌ |

> **핵심**: JAR = 내장 서버 포함 (독립 실행), WAR = 외부 서버 필요

---

## 8. 프로젝트 시작 전 필수 지식

### 8.1 Lombok

**Lombok**은 반복적인 코드(Boilerplate Code)를 자동 생성해주는 라이브러리입니다.

#### 8.1.1 주요 애노테이션

##### 기본 애노테이션

| 애노테이션 | 기능 | 생성 코드 |
|-----------|------|----------|
| `@Getter` | Getter 메서드 자동 생성 | `getName()`, `getAge()` 등 |
| `@Setter` | Setter 메서드 자동 생성 | `setName()`, `setAge()` 등 |
| `@ToString` | toString() 메서드 자동 생성 | 클래스명과 필드값 출력 |
| `@EqualsAndHashCode` | equals()와 hashCode() 메서드 생성 | 객체 비교 로직 |
| `@Data` | @Getter + @Setter + @ToString + @EqualsAndHashCode + @RequiredArgsConstructor | 모든 기본 메서드 생성 |

##### 생성자 애노테이션

| 애노테이션 | 기능 | 예시 |
|-----------|------|------|
| `@NoArgsConstructor` | 매개변수 없는 기본 생성자 | `new Member()` |
| `@AllArgsConstructor` | 모든 필드를 매개변수로 받는 생성자 | `new Member("홍혜창", 30)` |
| `@RequiredArgsConstructor` | `final` 필드만 매개변수로 받는 생성자 | `new Member(id)` |

##### 특수 애노테이션

| 애노테이션 | 기능 | 사용 예시 |
|-----------|------|----------|
| `@Builder` | 빌더 패턴 자동 생성 | `Member.builder().name("홍혜창").age(30).build()` |
| `@Slf4j` | 로깅 객체 `log` 자동 생성 | `log.info("로그 메시지")` |

#### 8.1.2 코드 비교

**Lombok 사용 전**:
```java
public class Member {
    private String name;
    private int age;
    
    // Getter
    public String getName() {
        return name;
    }
    
    public int getAge() {
        return age;
    }
    
    // Setter
    public void setName(String name) {
        this.name = name;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    // toString
    @Override
    public String toString() {
        return "Member{name='" + name + "', age=" + age + "}";
    }
    
    // 생성자
    public Member() {}
    
    public Member(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // equals, hashCode 등... (생략)
}
```

**Lombok 사용 후**:
```java
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Member {
    private String name;
    private int age;
}
```

> **코드 라인 수**: 40줄 → 7줄 (약 80% 감소!)

#### 8.1.3 @Builder 패턴

**빌더 패턴이란?**
- 객체 생성 시 가독성을 높이고, 필드 순서에 상관없이 값을 설정할 수 있는 패턴

**일반 생성자**:
```java
// 매개변수 순서를 외워야 함
Member member = new Member("홍혜창", 30, "hyechang@example.com");
```

**빌더 패턴**:
```java
@Builder
public class Member {
    private String name;
    private int age;
    private String email;
}

// 사용
Member member = Member.builder()
                      .name("홍혜창")
                      .age(30)
                      .email("hyechang@example.com")
                      .build();
```

**장점**:
- ✅ 가독성 향상 (어떤 값이 어떤 필드인지 명확)
- ✅ 순서 무관
- ✅ 선택적 매개변수 (일부만 설정 가능)

#### 8.1.4 @EqualsAndHashCode

**특정 필드만으로 객체 비교**:

```java
@EqualsAndHashCode(of = {"name", "email"})  // name과 email로만 비교
public class Member {
    private Long id;
    private String name;
    private String email;
    private int age;
}

// 사용
Member m1 = new Member(1L, "홍혜창", "hyechang@example.com", 30);
Member m2 = new Member(2L, "홍혜창", "hyechang@example.com", 35);

m1.equals(m2);  // true (name과 email이 같으므로)
```

#### 8.1.5 @Slf4j

**로깅 객체 자동 생성**:

**Lombok 사용 전**:
```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class MyService {
    private static final Logger log = LoggerFactory.getLogger(MyService.class);
    
    public void doSomething() {
        log.info("작업 시작");
    }
}
```

**Lombok 사용 후**:
```java
@Slf4j
public class MyService {
    public void doSomething() {
        log.info("작업 시작");  // log 변수가 자동으로 생성됨!
    }
}
```

---

### 8.2 application.properties

#### 8.2.1 역할

**application.properties**는 스프링부트 애플리케이션의 **중앙 설정 파일**입니다.

**주요 용도**:
1. 데이터베이스 연결 정보
2. 서버 포트 설정
3. 로그 레벨 설정
4. 커스텀 환경 변수
5. 외부 API 키 관리

#### 8.2.2 기본 사용법

**application.properties**:
```properties
# 커스텀 설정
name=hyechang
age=30
email=hyechang@example.com
```

**스프링 빈에서 사용**:
```java
@Component
public class MyService {
    
    @Value("${name}")
    private String name;
    
    @Value("${age}")
    private Integer age;
    
    @Value("${email}")
    private String email;
    
    public void printInfo() {
        System.out.println("이름: " + name);
        System.out.println("나이: " + age);
        System.out.println("이메일: " + email);
    }
}
```

#### 8.2.3 실제 활용 예시

##### 1) 데이터베이스 설정
```properties
# MySQL 연결 정보
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# JPA 설정
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
```

##### 2) 서버 설정
```properties
# 서버 포트 변경 (기본값: 8080)
server.port=9090

# 컨텍스트 경로 설정
server.servlet.context-path=/api
```

##### 3) 로그 설정
```properties
# 전체 로그 레벨 (기본값: INFO)
logging.level.root=WARN

# 특정 패키지 로그 레벨
logging.level.com.example.demo=DEBUG
logging.level.com.example.demo.controller=TRACE

# 로그 파일 설정
logging.file.name=./logs/app.log
logging.file.max-size=10MB
logging.file.max-history=30
```

#### 8.2.4 환경별 설정 파일

**프로파일별로 다른 설정 사용**:

```
application.properties          # 공통 설정
application-dev.properties      # 개발 환경
application-prod.properties     # 운영 환경
```

**활성화**:
```properties
# application.properties
spring.profiles.active=dev  # dev 프로파일 활성화
```

**예시**:
```properties
# application-dev.properties (개발 환경)
spring.datasource.url=jdbc:mysql://localhost:3306/dev_db
logging.level.root=DEBUG

# application-prod.properties (운영 환경)
spring.datasource.url=jdbc:mysql://prod-server:3306/prod_db
logging.level.root=WARN
```

---

### 8.3 로그 출력 (Logging)

#### 8.3.1 System.out.println() vs Logger

**System.out.println()의 문제점**:
- ❌ 레벨 구분 불가 (모든 메시지가 동일)
- ❌ 출력 위치 제어 불가 (콘솔만 가능)
- ❌ 성능 저하 (동기적으로 처리)
- ❌ 운영 환경에서 로그 관리 어려움

**Logger의 장점**:
- ✅ **로그 레벨 제어**: 상황에 따라 출력 조절
- ✅ **다양한 출력 방식**: 콘솔, 파일, DB, 외부 시스템 등
- ✅ **성능 최적화**: 비동기 로깅 지원
- ✅ **포맷 지정**: 날짜, 시간, 클래스명 등 자동 포함
- ✅ **상속 구조**: 패키지별 로그 레벨 설정

#### 8.3.2 로그 레벨

로그 레벨은 **낮은 것부터 높은 순서**로 다음과 같이 구성됩니다:

```
TRACE < DEBUG < INFO < WARN < ERROR
```

| 레벨 | 용도 | 예시 |
|-----|------|------|
| **TRACE** | 가장 상세한 정보 (디버깅 시) | 메서드 진입/종료, 변수값 추적 |
| **DEBUG** | 디버깅 정보 | SQL 쿼리, 처리 흐름 |
| **INFO** | 일반 정보 (기본값) | 애플리케이션 시작/종료, 주요 이벤트 |
| **WARN** | 경고 메시지 | 잠재적 문제, 권장하지 않는 사용 |
| **ERROR** | 에러 메시지 | 예외 발생, 심각한 오류 |

**로그 레벨 설정의 의미**:
```properties
logging.level.com.example.demo=DEBUG
```
→ **DEBUG 이상** (DEBUG, INFO, WARN, ERROR)의 로그만 출력  
→ TRACE 레벨은 출력되지 않음

#### 8.3.3 로깅 객체 생성 방법

##### 방법 1: LoggerFactory 사용 (전통적)

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class CoffeeMaker {
    private static final Logger log = LoggerFactory.getLogger(CoffeeMaker.class);
    
    public void makeCoffee() {
        log.trace("TRACE 레벨 로그");
        log.debug("DEBUG 레벨 로그");
        log.info("INFO 레벨 로그");
        log.warn("WARN 레벨 로그");
        log.error("ERROR 레벨 로그");
    }
}
```

##### 방법 2: @Slf4j 사용 (권장) ⭐

```java
import lombok.extern.slf4j.Slf4j;

@Slf4j
public class CoffeeMaker {
    public void makeCoffee() {
        log.trace("TRACE 레벨 로그");
        log.debug("DEBUG 레벨 로그");
        log.info("INFO 레벨 로그");
        log.warn("WARN 레벨 로그");
        log.error("ERROR 레벨 로그");
    }
}
```

> **SLF4J**: Simple Logging Facade for Java  
> 다양한 로깅 프레임워크(Logback, Log4j 등)를 통합하는 인터페이스

#### 8.3.4 로그 레벨 설정 예시

**application.properties**:
```properties
# 패키지별 로그 레벨 설정
logging.level.com.example.demo.CoffeeMaker=DEBUG
```

**코드**:
```java
@Slf4j
public class CoffeeMaker {
    public void makeCoffee() {
        log.trace("TRACE");  // ❌ 출력 안 됨
        log.debug("DEBUG");  // ✅ 출력됨
        log.info("INFO");    // ✅ 출력됨
        log.warn("WARN");    // ✅ 출력됨
        log.error("ERROR");  // ✅ 출력됨
    }
}
```

**출력 결과**:
```
2025-10-13 14:30:15.123 DEBUG [CoffeeMaker] - DEBUG
2025-10-13 14:30:15.124 INFO  [CoffeeMaker] - INFO
2025-10-13 14:30:15.125 WARN  [CoffeeMaker] - WARN
2025-10-13 14:30:15.126 ERROR [CoffeeMaker] - ERROR
```

#### 8.3.5 로그 레벨 상속

**부모 패키지의 로그 레벨이 하위 패키지에 상속됩니다.**

```properties
# 루트 레벨 설정
logging.level.root=WARN

# com.example.demo 패키지
logging.level.com.example.demo=INFO

# com.example.demo.controller 패키지 (더 구체적)
logging.level.com.example.demo.controller=DEBUG
```

**상속 관계**:
```
root (WARN)
  └─ com (WARN 상속)
      └─ example (WARN 상속)
          └─ demo (INFO로 재정의)
              ├─ service (INFO 상속)
              ├─ repository (INFO 상속)
              └─ controller (DEBUG로 재정의)
```

**정리**:
- `com.example.demo.service` → INFO 레벨
- `com.example.demo.controller` → DEBUG 레벨
- `com.example.other` → WARN 레벨 (root 상속)

#### 8.3.6 로그 출력 위치 설정

##### 1) 콘솔 출력 (기본값)

```properties
# 기본적으로 콘솔에 출력됨 (설정 불필요)
```

##### 2) 파일 출력

```properties
# 로그 파일 경로 및 이름
logging.file.name=./logs/app.log

# 로그 파일 최대 크기
logging.file.max-size=10MB

# 보관할 로그 파일 개수
logging.file.max-history=30

# 전체 로그 파일 최대 크기
logging.file.total-size-cap=1GB
```

**파일명 패턴**:
```
logs/
  ├─ app.log                    # 현재 로그
  ├─ app.log.2025-10-13.0.gz    # 오늘 이전 로그 (압축)
  ├─ app.log.2025-10-12.0.gz    # 어제 로그
  └─ app.log.2025-10-11.0.gz    # 2일 전 로그
```

**로그 파일 생성 규칙**:
1. `app.log`에 계속 로그 기록
2. 파일 크기가 10MB 초과 시 → 새 파일 생성
3. 날짜가 바뀌면 → 이전 파일 압축 및 보관
4. 30일 이상 된 로그 → 자동 삭제

##### 3) 콘솔 + 파일 동시 출력

```properties
# 파일 출력 설정만 추가하면 콘솔도 함께 출력됨
logging.file.name=./logs/app.log
```

#### 8.3.7 로그 포맷 설정

```properties
# 콘솔 로그 포맷
logging.pattern.console=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n

# 파일 로그 포맷
logging.pattern.file=%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n
```

**포맷 설명**:
- `%d{yyyy-MM-dd HH:mm:ss.SSS}`: 날짜 및 시간
- `[%thread]`: 스레드 이름
- `%-5level`: 로그 레벨 (5자리 고정)
- `%logger{36}`: 로거 이름 (최대 36자)
- `%msg`: 로그 메시지
- `%n`: 줄바꿈

**출력 예시**:
```
2025-10-13 14:30:15.123 [main] DEBUG c.e.demo.CoffeeMaker - 커피 제조 시작
2025-10-13 14:30:15.456 [main] INFO  c.e.demo.CoffeeMaker - 커피 제조 완료
```

#### 8.3.8 실무 활용 팁

##### 1) 변수를 포함한 로그

**나쁜 예**:
```java
log.info("사용자 이름: " + username + ", 나이: " + age);  // 문자열 연결 비효율
```

**좋은 예**:
```java
log.info("사용자 이름: {}, 나이: {}", username, age);  // 파라미터 치환 (효율적)
```

##### 2) 조건부 로그

**나쁜 예**:
```java
if (log.isDebugEnabled()) {
    log.debug("복잡한 계산 결과: " + expensiveCalculation());  // 불필요한 계산
}
```

**좋은 예**:
```java
log.debug("복잡한 계산 결과: {}", () -> expensiveCalculation());  // Lazy 평가
```

##### 3) 예외 로깅

```java
try {
    // 작업 수행
} catch (Exception e) {
    log.error("작업 실패: {}", e.getMessage(), e);  // 예외 스택 트레이스 포함
}
```

##### 4) 환경별 로그 레벨

```properties
# application-dev.properties (개발 환경)
logging.level.root=DEBUG
logging.level.com.example.demo=TRACE

# application-prod.properties (운영 환경)
logging.level.root=WARN
logging.level.com.example.demo=INFO
```

---

## 9. 실전 예제: 프로젝트 설정

### 9.1 완전한 application.properties 예시

```properties
# ========================================
# 서버 설정
# ========================================

#context-path가 /일 때: /products
#context-path가 /api일 때: /api/products  기본으로 context-path는 붙어있어야한다~라는것


server.port=8080
server.servlet.context-path=/

# ========================================
# 데이터베이스 설정
# ========================================
spring.datasource.url=jdbc:mysql://localhost:3306/mydb?useSSL=false&serverTimezone=Asia/Seoul
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

# ========================================
# JPA 설정
# ========================================
spring.jpa.hibernate.ddl-auto=update
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL8Dialect

# ========================================
# 로그 설정
# ========================================
# 전체 로그 레벨
logging.level.root=INFO

# 패키지별 로그 레벨
logging.level.com.example.demo=DEBUG
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# 로그 파일 설정
logging.file.name=./logs/application.log
logging.file.max-size=10MB
logging.file.max-history=30

# ========================================
# 커스텀 설정
# ========================================
app.name=MySpringBootApp
app.version=1.0.0
app.admin.email=admin@example.com
```

### 9.2 Lombok 활용 예시

```java
package com.example.demo.model;

import lombok.*;
import lombok.extern.slf4j.Slf4j;

@Slf4j              // 로깅 객체 자동 생성
@Data               // Getter, Setter, ToString 등
@NoArgsConstructor  // 기본 생성자
@AllArgsConstructor // 모든 필드 생성자
@Builder            // 빌더 패턴
public class Member {
    
    private Long id;
    private String name;
    private String email;
    private int age;
    
    // 비즈니스 로직
    public void introduce() {
        log.info("회원 정보: 이름={}, 이메일={}, 나이={}", name, email, age);
    }
    
    public boolean isAdult() {
        boolean adult = age >= 18;
        log.debug("성인 여부 확인: {} -> {}", name, adult);
        return adult;
    }
}
```

**사용 예시**:
```java
@Service
@Slf4j
public class MemberService {
    
    public void createMember() {
        // 빌더 패턴으로 객체 생성
        Member member = Member.builder()
                              .name("홍혜창")
                              .email("hyechang@example.com")
                              .age(30)
                              .build();
        
        log.info("회원 생성: {}", member);  // @ToString 자동 적용
        member.introduce();                // 비즈니스 로직 실행
    }
}
```

---

## 10. 핵심 요약

### 10.1 개발 환경

| 도구 | 버전 | 용도 |
|-----|------|------|
| JDK | Temurin (OpenJDK) | 자바 실행 환경 |
| IntelliJ IDEA | 2024.3.4.1 | 통합 개발 환경 |
| MySQL | 8.4 | 데이터베이스 |
| DBeaver | Community 25.2.2 | DB 관리 도구 |
| Postman | 11 | API 테스트 도구 |

### 10.2 주요 개념

#### JAR vs WAR
- **JAR (권장)**: 톰캣 내장, 독립 실행 가능
- **WAR**: 외부 WAS 필요, 레거시 환경

#### Lombok
- 반복 코드 자동 생성
- `@Data`, `@Builder`, `@Slf4j` 등 활용

#### application.properties
- 중앙 설정 파일
- 데이터베이스, 서버, 로그 등 모든 설정

#### 로그 레벨
```
TRACE < DEBUG < INFO < WARN < ERROR
```
- 개발: DEBUG 레벨
- 운영: INFO 또는 WARN 레벨

### 10.3 필수 체크리스트

- [ ] JDK (Temurin) 설치 확인
- [ ] IntelliJ IDEA 설치 및 설정
- [ ] MySQL 설치 및 포트(3306) 확인
- [ ] DBeaver로 MySQL 연결 테스트
- [ ] Postman 설치
- [ ] Spring Initializr로 프로젝트 생성 (JAR)
- [ ] Lombok 플러그인 설치 (IntelliJ)
- [ ] application.properties 기본 설정
- [ ] 로그 출력 테스트

