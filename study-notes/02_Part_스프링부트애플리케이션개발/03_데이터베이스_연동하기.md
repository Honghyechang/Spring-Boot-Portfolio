# 03_데이터베이스_연동하기

<!--
# 첫 작성 (3.1 JDBC)
docs: [Ch03] 데이터베이스 연동 - JDBC 추가

# 다음 업데이트 (3.2, 3.3 추가)
docs: [Ch03] 데이터베이스 연동 - Spring Data JDBC, MyBatis 추가

# 마지막 완료 (3.4, 3.5 추가)
docs: [Ch03] 데이터베이스 연동 - JPA, MongoDB 추가 및 완료

-->

## 📌 학습 목표
스프링부트에서 데이터베이스에 접근하는 다양한 방법을 이해하고, 각 방식의 특징과 사용법을 익힌다.

---

## 목차

- [3.1 JDBC](#31-jdbc)
- [3.2 Spring Data JDBC](#32-spring-data-jdbc) 
- [3.3 MyBatis](#33-mybatis) 
- [3.4 JPA](#34-jpa) 
- [3.5 MongoDB](#35-mongodb) 

---

## 3.1 JDBC

### 3.1.1 JDBC란?

**JDBC (Java Database Connectivity)** 는 Java 애플리케이션에서 데이터베이스에 접근하기 위한 **표준 API**입니다.

#### JDBC의 구성 요소

```
[Java 애플리케이션]
      ↓
[JDBC API] ← Java가 제공하는 표준 인터페이스
      ↓
[JDBC Driver] ← 각 DB 벤더가 제공하는 구현체
      ↓
[데이터베이스 (MySQL, Oracle, PostgreSQL 등)]
```

| 구성 요소 | 제공자 | 역할 |
|----------|-------|------|
| **JDBC API** | Java (Oracle) | 데이터베이스 접근을 위한 표준 인터페이스 정의 |
| **JDBC Driver** | 각 DB 벤더 (MySQL, Oracle 등) | JDBC API의 실제 구현체 |
| **데이터베이스** | DB 벤더 | 실제 데이터 저장 및 관리 |

#### JDBC Driver의 역할

**JDBC Driver**는 Java 애플리케이션과 특정 데이터베이스 간의 **통신을 담당하는 브리지(다리)** 역할을 합니다.

- MySQL JDBC Driver: `mysql-connector-j`
- PostgreSQL JDBC Driver: `postgresql`
- Oracle JDBC Driver: `ojdbc`

**비유**:
```
JDBC API = USB 규격 (표준 인터페이스)
JDBC Driver = USB 케이블 (제조사별 구현)
데이터베이스 = USB 장치
```

#### 왜 JDBC가 필요한가?

**문제 상황**:
- 데이터베이스마다 통신 방식이 다름
- MySQL, Oracle, PostgreSQL 등 각각 다른 방식으로 접근

**JDBC의 해결**:
- **표준화된 인터페이스 제공**
- 개발자는 JDBC API만 사용
- 데이터베이스 변경 시 Driver만 교체하면 됨

```java
// MySQL이든 Oracle이든 코드는 동일!
Connection conn = DriverManager.getConnection(url, user, password);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM member");
```

---

### 3.1.2 데이터베이스 초기 설정

#### DBeaver를 통한 데이터 초기화

**실습 환경**:
- 데이터베이스: MySQL 8.4
- 관리 도구: DBeaver Community 25.2.2
- 데이터베이스명: `mydb`
- 사용자: `myuser` / 비밀번호: `mypass`

#### SQL 스크립트

```sql
-- ========================================
-- 1. 데이터베이스 생성
-- ========================================
-- mydb라는 이름의 데이터베이스 공간을 생성합니다.
-- IF NOT EXISTS: 이미 존재하면 생략 (에러 방지)
CREATE DATABASE IF NOT EXISTS mydb;

-- ========================================
-- 2. 사용자 생성 및 인증
-- ========================================
-- myuser 계정을 생성합니다.
-- @'%': 모든 호스트(IP)에서 접속 허용
-- IDENTIFIED BY 'mypass': 비밀번호를 mypass로 설정
CREATE USER IF NOT EXISTS 'myuser'@'%' IDENTIFIED BY 'mypass';

-- ========================================
-- 3. 권한 부여
-- ========================================
-- myuser가 mydb 데이터베이스의 모든 객체(테이블, 뷰 등)에 대해
-- 모든 권한(SELECT, INSERT, UPDATE, DELETE, CREATE, DROP 등)을 가지도록 설정
GRANT ALL ON mydb.* TO 'myuser'@'%';

-- ========================================
-- 4. 데이터베이스 선택
-- ========================================
USE mydb;

-- ========================================
-- 5. 테이블 생성
-- ========================================
CREATE TABLE IF NOT EXISTS member(
    id INTEGER AUTO_INCREMENT PRIMARY KEY,  -- 자동 증가 기본키
    name VARCHAR(128) NOT NULL,             -- 이름 (필수)
    email VARCHAR(256) NOT NULL,            -- 이메일 (필수)
    age INTEGER                             -- 나이 (선택)
);

-- ========================================
-- 6. 데이터 삽입
-- ========================================
INSERT INTO member(name, email, age) VALUES ('김우현', 'kimwoo@spring.co.kr', 10);
INSERT INTO member(name, email, age) VALUES ('홍혜창', 'hyechang@spring.co.kr', 20);
INSERT INTO member(name, email, age) VALUES ('윤서준', 'Seojunyoon@spring.co.kr', 22);
INSERT INTO member(name, email, age) VALUES ('김민수', 'minsusu@spring.co.kr', 30);

-- ========================================
-- 7. 데이터 조회 (확인)
-- ========================================
SELECT * FROM member;
```

#### SQL 명령어 설명

| 명령어 | 역할 | 설명 |
|-------|------|------|
| `CREATE DATABASE` | 데이터베이스 생성 | 데이터를 저장할 논리적 공간 생성 |
| `CREATE USER` | 사용자 계정 생성 | 데이터베이스 접속 계정 생성 |
| `GRANT` | 권한 부여 | 특정 사용자에게 DB 작업 권한 부여 |
| `USE` | 데이터베이스 선택 | 작업할 데이터베이스 지정 |
| `CREATE TABLE` | 테이블 생성 | 데이터를 저장할 테이블 구조 정의 |
| `INSERT INTO` | 데이터 삽입 | 테이블에 레코드 추가 |
| `SELECT` | 데이터 조회 | 테이블의 데이터 검색 |

#### 데이터 확인

```
+----+----------+-------------------------+------+
| id | name     | email                   | age  |
+----+----------+-------------------------+------+
|  1 | 김우현   | kimwoo@spring.co.kr     |   10 |
|  2 | 홍혜창   | hyechang@spring.co.kr   |   20 |
|  3 | 윤서준   | Seojunyoon@spring.co.kr |   22 |
|  4 | 김민수   | minsusu@spring.co.kr    |   30 |
+----+----------+-------------------------+------+
```

---

### 3.1.3 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    
    // MySQL JDBC Driver
    implementation 'com.mysql:mysql-connector-j:9.2.0'
    
    // Lombok (코드 자동 생성)
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 |
|-------|------|
| `spring-boot-starter` | 스프링부트 기본 기능 |
| `mysql-connector-j:9.2.0` | **MySQL JDBC Driver** (핵심!) |
| `lombok` | Getter, Setter 등 자동 생성 |

> ⚠️ **중요**: `mysql-connector-j`를 추가해야 MySQL과 통신할 수 있는 JDBC Driver가 프로젝트에 포함됩니다!

**JDBC Driver 포함 확인**:
```
프로젝트 구조
└─ External Libraries
   └─ com.mysql:mysql-connector-j:9.2.0
      └─ com.mysql.cj.jdbc.Driver ← JDBC Driver 클래스
```

---

### 3.1.4 엔티티 클래스 작성

**Member.java**:
```java
package kr.ac.hansung.cse.databasesample;

import lombok.*;

/**
 * Member 엔티티 클래스
 * - 데이터베이스의 member 테이블과 매핑되는 Java 객체
 * - Lombok을 사용하여 반복 코드 최소화
 */
@AllArgsConstructor  // 모든 필드를 매개변수로 받는 생성자 자동 생성
@ToString            // toString() 메서드 자동 생성
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### Lombok 애노테이션

| 애노테이션 | 생성 코드 |
|-----------|----------|
| `@AllArgsConstructor` | `public Member(Long id, String name, String email, Integer age) { ... }` |
| `@ToString` | `public String toString() { return "Member(id=1, name=김우현, ...)"; }` |

---

### 3.1.5 JDBC를 사용한 데이터베이스 연동

#### 전체 코드

**DatabaseSampleApplication.java**:
```java
package kr.ac.hansung.cse.databasesample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.sql.*;

@SpringBootApplication
public class DatabaseSampleApplication {

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        
        SpringApplication.run(DatabaseSampleApplication.class, args);

        // ========================================
        // 1. JDBC Driver 로딩
        // ========================================
        /*
         * Class.forName()의 역할:
         * - JDBC Driver 클래스를 JVM 메모리에 로드
         * - 로드된 Driver는 DriverManager에 자동 등록됨
         * - DriverManager가 MySQL 접속 방법을 알게 됨
         * 
         * "com.mysql.cj.jdbc.Driver":
         * - mysql-connector-j 라이브러리에 포함된 MySQL JDBC Driver 클래스
         * - 이 클래스가 JDBC API를 실제로 구현함
         * 
         * 참고: JDBC 4.0 이후로는 자동 로딩되지만, 명시적 표현을 위해 작성
         */
        Class.forName("com.mysql.cj.jdbc.Driver");

        // ========================================
        // 2. 데이터베이스 연결
        // ========================================
        /*
         * DriverManager.getConnection()의 역할:
         * - 실제 데이터베이스와의 연결(Connection) 객체 생성
         * 
         * 첫 번째 매개변수 (JDBC URL):
         * "jdbc:mysql://localhost:3306/mydb"
         *  ──── ───── ───────── ──── ────
         *   │     │       │       │     └─ 데이터베이스 이름
         *   │     │       │       └─ 포트 번호 (MySQL 기본: 3306)
         *   │     │       └─ 서버 주소 (localhost = 내 컴퓨터)
         *   │     └─ 데이터베이스 종류 (MySQL)
         *   └─ JDBC 프로토콜
         * 
         * 두 번째 매개변수: 사용자 이름 (myuser)
         * 세 번째 매개변수: 비밀번호 (mypass)
         */
        Connection connection = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/mydb",
            "myuser",
            "mypass"
        );

        // ========================================
        // 3. SQL 쿼리 준비
        // ========================================
        /*
         * PreparedStatement의 역할:
         * - SQL 쿼리를 데이터베이스에 미리 전송
         * - 실행 가능한 상태로 준비 (컴파일)
         * - SQL Injection 방지 (매개변수 바인딩 시)
         * 
         * "select * from member":
         * - member 테이블의 모든 컬럼(*), 모든 행 조회
         */
        PreparedStatement preparedStatement = connection.prepareStatement(
            "select * from member"
        );

        // ========================================
        // 4. 쿼리 실행
        // ========================================
        /*
         * executeQuery()의 역할:
         * - SELECT 쿼리 실행 (데이터 조회)
         * - 결과를 ResultSet 객체로 반환
         * 
         * ResultSet:
         * - 쿼리 결과를 담고 있는 객체
         * - 커서(cursor)를 사용하여 한 행씩 접근
         */
        ResultSet resultSet = preparedStatement.executeQuery();

        // ========================================
        // 5. 결과 처리
        // ========================================
        /*
         * while (resultSet.next()):
         * - 다음 행으로 커서 이동
         * - 더 이상 행이 없으면 false 반환 (반복 종료)
         * 
         * resultSet.getLong("id"):
         * - 현재 행의 "id" 컬럼 값을 Long 타입으로 가져옴
         * 
         * resultSet.getString("name"):
         * - 현재 행의 "name" 컬럼 값을 String 타입으로 가져옴
         * 
         * resultSet.getInt("age"):
         * - 현재 행의 "age" 컬럼 값을 Integer 타입으로 가져옴
         */
        while (resultSet.next()) {
            Member member = new Member(
                resultSet.getLong("id"),
                resultSet.getString("name"),
                resultSet.getString("email"),
                resultSet.getInt("age")
            );
            System.out.println(member);
        }

        // ========================================
        // 6. 연결 종료
        // ========================================
        /*
         * connection.close()의 역할:
         * - 데이터베이스 연결 해제
         * - 리소스(메모리, 네트워크) 반환
         * - 반드시 호출해야 함 (리소스 누수 방지)
         * 
         * 권장: try-with-resources 사용
         */
        connection.close();
    }
}
```

#### 실행 결과

```
Member(id=1, name=김우현, email=kimwoo@spring.co.kr, age=10)
Member(id=2, name=홍혜창, email=hyechang@spring.co.kr, age=20)
Member(id=3, name=윤서준, email=Seojunyoon@spring.co.kr, age=22)
Member(id=4, name=김민수, email=minsusu@spring.co.kr, age=30)
```

---

### 3.1.6 JDBC 동작 과정 상세 분석

#### 1단계: Driver 로딩

```java
Class.forName("com.mysql.cj.jdbc.Driver");
```

**내부 동작**:
```
1. JVM이 "com.mysql.cj.jdbc.Driver" 클래스 파일 로드
2. Driver 클래스의 static 초기화 블록 실행
3. Driver 객체가 DriverManager에 자동 등록
4. DriverManager: "MySQL과 통신하는 방법을 알게 되었다!"
```


#### 2단계: Connection 생성

```java
Connection connection = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "myuser",
    "mypass"
);
```

**내부 동작**:
```
1. DriverManager가 등록된 Driver들을 순회
2. URL이 "jdbc:mysql"로 시작 → MySQL Driver 선택
3. MySQL Driver가 실제 연결 시도
   - TCP 소켓 연결 (localhost:3306)
   - 인증 확인 (myuser/mypass)
   - mydb 데이터베이스 선택
4. Connection 객체 반환
```

**Connection 객체의 역할**:
- 데이터베이스와의 **세션(Session)** 을 나타냄
- 이 연결을 통해 SQL을 실행하고 결과를 받음

#### 3단계: Statement 생성 및 실행

```java
PreparedStatement preparedStatement = connection.prepareStatement(
    "select * from member"
);
ResultSet resultSet = preparedStatement.executeQuery();
```

**내부 동작**:
```
1. SQL 문자열을 MySQL 서버로 전송
2. MySQL이 SQL을 파싱(분석)하고 실행 계획 수립
3. 쿼리 실행
4. 결과를 ResultSet으로 반환
   (네트워크를 통해 Java 애플리케이션으로 전송)
```

#### 4단계: 결과 처리

```java
while (resultSet.next()) {
    // 데이터 읽기
}
```

**ResultSet의 구조**:
```
커서 위치 (처음에는 첫 행 이전)
    ↓
[Before First] ← resultSet.next() 호출 전
[Row 1] id=1, name=김우현, ...  ← resultSet.next() → true
[Row 2] id=2, name=홍혜창, ...  ← resultSet.next() → true
[Row 3] id=3, name=윤서준, ...  ← resultSet.next() → true
[Row 4] id=4, name=김민수, ...  ← resultSet.next() → true
[After Last] ← resultSet.next() → false (반복 종료)
```

---

### 3.1.7 JDBC의 문제점

#### 문제 1: 반복적인 코드

```java
// 매번 작성해야 하는 코드
Connection conn = DriverManager.getConnection(...);
PreparedStatement stmt = conn.prepareStatement(...);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
    // 매핑 코드
}
conn.close();
```

#### 문제 2: 수동 매핑

```java
// 컬럼과 객체 필드를 수동으로 매핑
Member member = new Member(
    rs.getLong("id"),
    rs.getString("name"),
    rs.getString("email"),
    rs.getInt("age")
);
```

#### 문제 3: 리소스 관리

```java
// close()를 깜빡하면 리소스 누수!
connection.close();  // 반드시 호출해야 함
```

#### 문제 4: 예외 처리

```java
// 체크 예외(Checked Exception) 처리 필요
throws ClassNotFoundException, SQLException
```

**이러한 문제들을 해결하기 위해 등장한 것이:**
- Spring Data JDBC (3.2)
- MyBatis (3.3)
- JPA (3.4)

---


## 3.2 Spring Data JDBC

### 3.2.1 Spring Data JDBC란?

**Spring Data JDBC**는 JDBC의 반복적인 코드를 제거하고, 개발자가 **비즈니스 로직에만 집중**할 수 있도록 도와주는 추상화 레이어입니다.

#### JDBC의 문제점을 해결하는 방법

| 문제점 | JDBC | Spring Data JDBC |
|-------|------|-----------------|
| Driver 로딩 | `Class.forName()` 필요 | 자동 처리 |
| Connection 관리 | 매번 생성/종료 | **커넥션 풀** 자동 관리 |
| SQL 작성 | 직접 작성 | 메서드 이름으로 자동 생성 |
| 결과 매핑 | `ResultSet` 수동 매핑 | 객체 자동 매핑 |
| 예외 처리 | Checked Exception | Runtime Exception |
| 리소스 정리 | 수동 `close()` | 자동 정리 |

> ⚠️ **중요**: Spring Data JDBC는 JDBC Driver를 사용하지 않는 것이 아닙니다! MySQL Connector 같은 JDBC Driver를 **더 편리하게 사용**하도록 감싸주는 역할을 합니다.

#### Spring Data JDBC의 핵심 개념

```
[개발자]
    ↓ (Repository 인터페이스만 정의)
[Spring Data JDBC]
    ↓ (보일러플레이트 코드 자동 생성)
[JDBC Driver (mysql-connector-j)]
    ↓
[MySQL 데이터베이스]
```

**보일러플레이트 코드(Boilerplate Code)**: 반복적으로 작성해야 하는 지루한 코드

---

### 3.2.2 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    // Spring Data JDBC (핵심!)
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    
    // MySQL JDBC Driver (여전히 필요!)
    runtimeOnly 'com.mysql:mysql-connector-j'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 | 필수 여부 |
|-------|------|----------|
| `spring-boot-starter-data-jdbc` | Spring Data JDBC 기능 제공 | ✅ 필수 |
| `mysql-connector-j` | MySQL과 통신하는 JDBC Driver | ✅ 필수 |
| `lombok` | 코드 간소화 | 권장 |

> **핵심**: `spring-boot-starter-data-jdbc`는 JDBC를 대체하는 것이 아니라, JDBC를 더 쉽게 사용하도록 도와주는 도구입니다!

---

### 3.2.3 데이터베이스 연결 설정

#### application.properties

**src/main/resources/application.properties**:
```properties
spring.application.name=springdatajbc

# ========================================
# 데이터베이스 연결 설정 (DataSource)
# ========================================
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass

# ========================================
# JDBC 로그 레벨 설정 (디버깅용)
# ========================================
logging.level.org.springframework.jdbc=DEBUG
```

#### 설정 항목 설명

| 속성 | 설명 | 예시 값 |
|-----|------|---------|
| `spring.datasource.url` | 데이터베이스 연결 URL | `jdbc:mysql://localhost:3306/mydb` |
| `spring.datasource.username` | 데이터베이스 사용자 이름 | `myuser` |
| `spring.datasource.password` | 데이터베이스 비밀번호 | `mypass` |
| `logging.level.org.springframework.jdbc` | JDBC 실행 로그 레벨 | `DEBUG` (SQL 쿼리 확인용) |

#### JDBC vs Spring Data JDBC 설정 비교

**JDBC (이전)**:
```java
// 매번 코드로 작성
Class.forName("com.mysql.cj.jdbc.Driver");
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "myuser",
    "mypass"
);
```

**Spring Data JDBC (현재)**:
```properties
# 설정 파일에 한 번만 작성
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
```

> **장점**: 설정 파일만 수정하면 모든 코드에 자동 적용! 환경별(개발/운영) 설정 파일 분리 가능!

---

### 3.2.4 엔티티 클래스 작성

#### Member 엔티티

**Member.java**:
```java
package com.example.springdatajbc;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

@Table
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Member {
    
    @Id
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### 애노테이션 설명

##### @Table

**역할**: 이 클래스가 데이터베이스 테이블과 매핑됨을 선언

**자동 매핑 규칙**:
- 클래스 이름 → 테이블 이름 (카멜 케이스 → 스네이크 케이스)
- `Member` 클래스 → `member` 테이블
- `HyechangMember` 클래스 → `hyechang_member` 테이블

**명시적 지정**:
```java
@Table("custom_table_name")  // 테이블 이름이 규칙과 다를 때
public class Member { ... }
```

**테이블 매핑 과정**:
```
[Java 클래스]           [데이터베이스]
Member 클래스     →     member 테이블
├─ id (Long)      →     id (BIGINT)
├─ name (String)  →     name (VARCHAR)
├─ email (String) →     email (VARCHAR)
└─ age (Integer)  →     age (INT)
```

##### @Id

**역할**: Primary Key(기본 키) 필드 지정

```java
@Id
private Long id;
```

- Spring Data JDBC가 이 필드를 기준으로 레코드 식별
- `save()` 시 `id`가 `null`이면 INSERT, 값이 있으면 UPDATE
- 자동 생성(AUTO_INCREMENT)된 값을 자동으로 받아옴

##### @Column (선택 사항)

**역할**: 필드명과 컬럼명이 다를 때 매핑

```java
@Column("user_name")
private String name;  // name 필드 → user_name 컬럼
```

**기본 매핑 규칙**:
- 필드명과 컬럼명이 같으면 생략 가능
- 카멜 케이스 → 스네이크 케이스 자동 변환
- `userName` → `user_name`

##### Lombok 애노테이션

| 애노테이션 | 생성 코드 |
|-----------|----------|
| `@Data` | `@Getter` + `@Setter` + `@ToString` + `@EqualsAndHashCode` + `@RequiredArgsConstructor` |
| `@Builder` | 빌더 패턴 코드 생성 |
| `@AllArgsConstructor` | 모든 필드를 매개변수로 받는 생성자 |
| `@NoArgsConstructor` | 기본 생성자 (매개변수 없음) |

---

### 3.2.5 Repository 인터페이스 작성

#### MemberRepository 인터페이스

**MemberRepository.java**:
```java
package com.example.springdatajbc;

import org.springframework.data.jdbc.repository.query.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MemberRepository extends CrudRepository<Member, Long> {
    
    // 메서드 이름 기반 쿼리 (자동 생성)
    List<Member> findByName(String name);
    List<Member> findByEmail(String email);
    List<Member> findByNameContaining(String name);
    
    // 조건 결합
    List<Member> findByEmailAndName(String email, String name);
    List<Member> findByEmailOrName(String email, String name);
    
    // 비교 연산
    List<Member> findByAgeGreaterThan(int age);
    List<Member> findByAgeLessThan(int age);
    List<Member> findByAgeBetween(int min, int max);
    
    // 커스텀 쿼리 (직접 작성)
    @Query("SELECT * FROM member WHERE name = :username AND age >= :max")
    List<Member> hyechangQuery(String username, int max);
}
```

---

### 3.2.6 Repository 핵심 개념

#### 1. @Repository와 빈 생성

**@Repository의 정체**:
```java
@Repository
public interface MemberRepository extends CrudRepository<Member, Long> {
    // 인터페이스인데 어떻게 빈 객체가 되는가?
}
```

**@Repository = @Component의 특수한 형태**:

| 애노테이션 | 역할 | 계층 |
|-----------|------|------|
| `@Component` | 범용 스프링 빈 | - |
| `@Repository` | 데이터 접근 계층 | Persistence Layer |
| `@Service` | 비즈니스 로직 계층 | Service Layer |
| `@Controller` | 프레젠테이션 계층 | Presentation Layer |

> **핵심**: 모두 `@Component`이지만, **역할을 명확히 하기 위해** 세분화된 것입니다!

#### 2. 인터페이스가 빈 객체가 되는 원리 (프록시 패턴)

**문제**: 인터페이스는 객체를 만들 수 없는데?

**해결**: Spring이 **프록시 객체**를 자동 생성!

```
애플리케이션 시작 시:

1. Spring이 @Repository를 발견
2. MemberRepository 인터페이스 분석
3. 이 인터페이스를 구현하는 클래스를 런타임에 자동 생성 (프록시)
4. 프록시 객체를 빈으로 등록
5. 다른 곳에서 주입 시 프록시 객체 제공
```

**프록시 객체의 역할**:
```java
// Spring이 런타임에 자동으로 생성하는 코드 (개념적 표현)
public class MemberRepositoryImpl implements MemberRepository {
    
    @Override
    public <S extends Member> S save(S entity) {
        // entity.getId()가 null이면 INSERT
        // entity.getId()가 있으면 UPDATE
        // SQL 자동 생성 및 실행
    }
    
    @Override
    public Optional<Member> findById(Long id) {
        // SELECT * FROM member WHERE id = ? 실행
        // ResultSet → Member 객체 자동 매핑
    }
    
    // 기타 메서드들도 자동 구현...
}
```

#### 3. CrudRepository의 제네릭

```java
public interface MemberRepository extends CrudRepository<Member, Long>
                                                        ────────  ────
                                                        엔티티    PK 타입
```

**제네릭 의미**:
- `<Member, Long>`: "Member 엔티티를 다루며, Primary Key는 Long 타입"
- Spring이 이 정보를 바탕으로 SQL 자동 생성

#### 4. CrudRepository 기본 메서드

**자동으로 제공되는 메서드**:

| 메서드 | 설명 | 생성 SQL |
|-------|------|----------|
| `save(entity)` | 저장 또는 수정 | `INSERT` 또는 `UPDATE` |
| `findById(id)` | ID로 조회 | `SELECT * FROM member WHERE id = ?` |
| `findAll()` | 전체 조회 | `SELECT * FROM member` |
| `existsById(id)` | 존재 여부 확인 | `SELECT COUNT(*) FROM member WHERE id = ?` |
| `count()` | 전체 개수 | `SELECT COUNT(*) FROM member` |
| `deleteById(id)` | ID로 삭제 | `DELETE FROM member WHERE id = ?` |
| `delete(entity)` | 엔티티 삭제 | `DELETE FROM member WHERE id = ?` |
| `deleteAll()` | 전체 삭제 | `DELETE FROM member` |

**save()의 동작 원리**:
```java
Member member = new Member();
member.setName("홍혜창");
memberRepository.save(member);  // id가 null → INSERT

member.setAge(30);
memberRepository.save(member);  // id가 있음 → UPDATE
```

---

### 3.2.7 쿼리 메서드 (Query Method)

#### 메서드 이름 기반 쿼리 생성

Spring Data JDBC는 **메서드 이름을 분석**하여 자동으로 SQL을 생성합니다.

#### 기본 구조

```
find...By... + 조건필드 + 비교연산자
 │    │        │          │
 │    │        │          └─ GreaterThan, LessThan 등
 │    │        └─ Name, Email, Age 등 (엔티티 필드명)
 │    └─ 조건 시작
 └─ 조회 작업 (find, get, read 모두 동일)
```

#### 주요 키워드

##### 1. 필드 일치

```java
List<Member> findByName(String name);
// SQL: SELECT * FROM member WHERE name = ?

List<Member> findByEmail(String email);
// SQL: SELECT * FROM member WHERE email = ?
```

##### 2. 조건 결합 (AND, OR)

```java
// AND 조건 (모두 만족)
List<Member> findByEmailAndName(String email, String name);
// SQL: SELECT * FROM member WHERE email = ? AND name = ?

// OR 조건 (하나라도 만족)
List<Member> findByEmailOrName(String email, String name);
// SQL: SELECT * FROM member WHERE email = ? OR name = ?
```

##### 3. 문자열 검색

```java
// 포함 (LIKE '%...%')
List<Member> findByNameContaining(String name);
// SQL: SELECT * FROM member WHERE name LIKE %?%

// 시작 (LIKE '...%')
List<Member> findByNameStartingWith(String name);
// SQL: SELECT * FROM member WHERE name LIKE ?%

// 끝 (LIKE '%...')
List<Member> findByNameEndingWith(String name);
// SQL: SELECT * FROM member WHERE name LIKE %?
```

##### 4. 비교 연산

```java
// 보다 큼 (>)
List<Member> findByAgeGreaterThan(int age);
// SQL: SELECT * FROM member WHERE age > ?

// 보다 작음 (<)
List<Member> findByAgeLessThan(int age);
// SQL: SELECT * FROM member WHERE age < ?

// 이상 (>=)
List<Member> findByAgeGreaterThanEqual(int age);
// SQL: SELECT * FROM member WHERE age >= ?

// 이하 (<=)
List<Member> findByAgeLessThanEqual(int age);
// SQL: SELECT * FROM member WHERE age <= ?

// 범위 (BETWEEN)
List<Member> findByAgeBetween(int min, int max);
// SQL: SELECT * FROM member WHERE age BETWEEN ? AND ?
```

##### 5. NULL 체크

```java
// NULL인 경우
List<Member> findByEmailIsNull();
// SQL: SELECT * FROM member WHERE email IS NULL

// NULL이 아닌 경우
List<Member> findByEmailIsNotNull();
// SQL: SELECT * FROM member WHERE email IS NOT NULL
```

##### 6. 정렬 (OrderBy)

```java
// 오름차순
List<Member> findByNameOrderByAgeAsc(String name);
// SQL: SELECT * FROM member WHERE name = ? ORDER BY age ASC

// 내림차순
List<Member> findByNameOrderByAgeDesc(String name);
// SQL: SELECT * FROM member WHERE name = ? ORDER BY age DESC
```

##### 7. 개수 제한

```java
// 첫 번째 결과
Member findFirstByName(String name);
// SQL: SELECT * FROM member WHERE name = ? LIMIT 1

// 상위 N개
List<Member> findTop3ByOrderByAgeDesc();
// SQL: SELECT * FROM member ORDER BY age DESC LIMIT 3
```

#### 쿼리 메서드 키워드 정리표

| 키워드 | SQL | 예시 |
|-------|-----|------|
| `And` | `AND` | `findByNameAndEmail` |
| `Or` | `OR` | `findByNameOrEmail` |
| `Containing` | `LIKE %?%` | `findByNameContaining` |
| `StartingWith` | `LIKE ?%` | `findByNameStartingWith` |
| `EndingWith` | `LIKE %?` | `findByNameEndingWith` |
| `GreaterThan` | `>` | `findByAgeGreaterThan` |
| `LessThan` | `<` | `findByAgeLessThan` |
| `Between` | `BETWEEN` | `findByAgeBetween` |
| `IsNull` | `IS NULL` | `findByEmailIsNull` |
| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull` |
| `OrderBy...Asc` | `ORDER BY ... ASC` | `findByNameOrderByAgeAsc` |
| `OrderBy...Desc` | `ORDER BY ... DESC` | `findByNameOrderByAgeDesc` |
| `First` | `LIMIT 1` | `findFirstByName` |
| `Top3` | `LIMIT 3` | `findTop3ByOrderByAge` |

---

### 3.2.8 커스텀 쿼리 (@Query)

#### @Query 애노테이션

**복잡한 쿼리는 직접 작성**:

```java
@Query("SELECT * FROM member WHERE name = :username AND age >= :max")
List<Member> hyechangQuery(String username, int max);
```

#### 파라미터 바인딩

**`:변수명` 형식으로 바인딩**:

```java
@Query("SELECT * FROM member WHERE name = :username AND age >= :max")
List<Member> hyechangQuery(String username, int max);
                          ────────────  ────
                                │          └─ :max와 매핑
                                └─ :username과 매핑
```

#### @Query 사용 시나리오

| 상황 | 메서드 이름 | @Query |
|-----|-----------|--------|
| 단순 조건 | ✅ 권장 | ❌ 불필요 |
| 복잡한 JOIN | ❌ 불가능 | ✅ 필수 |
| 집계 함수 (SUM, AVG) | ❌ 제한적 | ✅ 권장 |
| 성능 최적화 필요 | ❌ 제한적 | ✅ 권장 |

**예시**:
```java
// 집계 쿼리
@Query("SELECT AVG(age) FROM member")
Double getAverageAge();

// JOIN 쿼리
@Query("SELECT m.* FROM member m JOIN orders o ON m.id = o.member_id WHERE o.status = :status")
List<Member> findMembersWithOrderStatus(String status);
```

---

### 3.2.9 애플리케이션 실행 코드

#### SpringJdbcApplication 클래스

**SpringJdbcApplication.java**:
```java
package com.example.springdatajbc;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.util.Iterator;
import java.util.List;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class SpringJdbcApplication implements ApplicationRunner {

    private final MemberRepository memberRepository;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 1. 데이터 생성 (Builder 패턴)
        Member member = Member.builder()
                              .name("hyechang")
                              .email("test@hyechang.ac.kr")
                              .age(25)
                              .build();
        
        // 2. 저장 (INSERT)
        memberRepository.save(member);

        // 3. 수정 (UPDATE)
        member.setAge(35);
        memberRepository.save(member);

        // 4. ID로 조회
        Optional<Member> getm = memberRepository.findById(1L);
        if (getm.isPresent()) {
            log.info(getm.get().toString());
        }

        // 5. 전체 조회
        Iterable<Member> iterable = memberRepository.findAll();
        Iterator<Member> iterator = iterable.iterator();
        while (iterator.hasNext()) {
            log.info(iterator.next().toString());
        }

        // 6. 커스텀 쿼리 메서드
        List<Member> members = memberRepository.findByAgeGreaterThan(3);
        log.info("--- findByAgeGreaterThan(3) 결과 시작 (총 {}개) ---", members.size());
        for (Member m : members) {
            log.info(m.toString());
        }
        log.info("--- findByAgeGreaterThan(3) 결과 종료 ---");
    }
}
```

---

### 3.2.10 주요 개념 상세 분석

#### 1. @RequiredArgsConstructor + final

**의존성 주입 방식**:

```java
@Component
@RequiredArgsConstructor
public class SpringJdbcApplication {
    
    private final MemberRepository memberRepository;
    // final = 반드시 초기화되어야 함
}
```

**내부 동작**:
```java
// Lombok이 자동 생성하는 코드
public SpringJdbcApplication(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
}
```

**Spring의 DI 과정**:
```
1. @Component 스캔 → SpringJdbcApplication 클래스 발견
2. 생성자 발견 (MemberRepository 필요)
3. 스프링 컨테이너에서 MemberRepository 빈 검색
4. 검색된 빈(프록시 객체)을 생성자에 주입
5. SpringJdbcApplication 빈 생성 완료
```

#### 2. ApplicationRunner 인터페이스

**역할**: 애플리케이션 시작 직후 자동 실행

```
애플리케이션 시작 순서:

1. @SpringBootApplication 실행
2. 컴포넌트 스캔 및 빈 생성
3. 의존성 주입
4. ApplicationRunner 구현체의 run() 자동 실행 ← 여기!
5. 애플리케이션 정상 구동
```

**사용 목적**:
- 초기 데이터 삽입
- 데이터베이스 마이그레이션
- 시스템 초기화 작업
- 테스트 데이터 생성

#### 3. save()의 동작 원리

```java
Member member = Member.builder().name("hyechang").age(25).build();
memberRepository.save(member);  // ① INSERT
// 이 시점에서 member.getId()에 자동 생성된 ID 할당됨

member.setAge(35);
memberRepository.save(member);  // ② UPDATE
```

**내부 판단 로직**:
```
save() 호출 시:

if (entity.getId() == null) {
    // INSERT
    INSERT INTO member (name, email, age) VALUES (?, ?, ?)
    // 자동 생성된 ID를 entity.setId()로 설정
} else {
    // UPDATE
    UPDATE member SET name=?, email=?, age=? WHERE id=?
}
```

#### 4. Optional 처리

```java
Optional<Member> getm = memberRepository.findById(1L);
if (getm.isPresent()) {
    log.info(getm.get().toString());
}
```

**Optional을 사용하는 이유**:
- `null` 체크를 명시적으로 강제
- `NullPointerException` 방지

**더 나은 방식**:
```java
memberRepository.findById(1L)
                .ifPresent(member -> log.info(member.toString()));

// 또는
Member member = memberRepository.findById(1L)
                                 .orElse(new Member());  // 없으면 기본값

// 또는
Member member = memberRepository.findById(1L)
                                 .orElseThrow(() -> new RuntimeException("회원 없음"));
```

---

### 3.2.11 커넥션 풀 (Connection Pool)

#### 커넥션 풀이란?

**문제 상황 (JDBC 직접 사용 시)**:
```java
// 요청 1
Connection conn1 = DriverManager.getConnection(...);  // 연결 생성 (느림!)
// 쿼리 실행
conn1.close();  // 연결 종료

// 요청 2
Connection conn2 = DriverManager.getConnection(...);  // 또 연결 생성 (느림!)
// 쿼리 실행
conn2.close();  // 또 연결 종료
```

**문제점**:
- 매번 DB 연결 생성/종료 → **시간 소요** (네트워크 통신, 인증 등)
- 동시 요청 많을 시 → **성능 저하**

**해결책: 커넥션 풀**

```
[커넥션 풀]
├─ Connection 1 (미리 생성, 대기 중)
├─ Connection 2 (미리 생성, 대기 중)
├─ Connection 3 (미리 생성, 대기 중)
└─ Connection 4 (미리 생성, 대기 중)

요청 시:
1. 풀에서 빌려옴 (빠름!)
2. 쿼리 실행
3. 풀에 반납 (close()가 아님!)
```

#### 커넥션 풀의 동작 원리

**1. 애플리케이션 시작 시**:

```
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
↓
Spring Boot가 이 설정을 읽고
↓
HikariCP (기본 커넥션 풀) 초기화
↓
mydb에 Connection 10개 미리 생성 (기본값)
↓
풀에 저장하고 대기
```

**2. Repository 메서드 호출 시**:

```java
memberRepository.save(member);
↓
Spring Data JDBC가 내부적으로:
1. 커넥션 풀에서 Connection 빌려옴 (대기 중인 것 사용)
2. SQL 실행: INSERT INTO member ...
3. Connection을 풀에 반납 (close()가 아님!)
```

**3. 애플리케이션 종료 시**:

```
애플리케이션 종료 시작
↓
Spring이 자동으로 커넥션 풀 종료
↓
풀의 모든 Connection들을 DB에 반환
↓
실제 연결 종료
```

#### 커넥션 풀 설정

**application.properties**:
```properties
# HikariCP 커넥션 풀 설정
spring.datasource.hikari.maximum-pool-size=10      # 최대 커넥션 수
spring.datasource.hikari.minimum-idle=5            # 최소 유지 커넥션 수
spring.datasource.hikari.connection-timeout=20000  # 커넥션 대기 시간 (ms)
spring.datasource.hikari.idle-timeout=300000       # 유휴 커넥션 유지 시간 (ms)
```

| 설정 | 설명 | 기본값 |
|-----|------|--------|
| `maximum-pool-size` | 풀이 유지할 최대 커넥션 수 | 10 |
| `minimum-idle` | 항상 유지할 최소 커넥션 수 | `maximum-pool-size`와 동일 |
| `connection-timeout` | 커넥션을 못 얻을 때 대기 시간 | 30000ms (30초) |
| `idle-timeout` | 사용하지 않는 커넥션 제거 시간 | 600000ms (10분) |

#### 커넥션 풀 동작 시나리오

**시나리오 1: 정상 상황**

```
초기 상태: 풀에 10개 커넥션 대기 중

요청 1: save() 호출
  ├─ 커넥션 1 빌려옴 (풀: 9개 남음)
  ├─ INSERT 실행
  └─ 커넥션 1 반납 (풀: 10개)

요청 2: findAll() 호출
  ├─ 커넥션 2 빌려옴 (풀: 9개 남음)
  ├─ SELECT 실행
  └─ 커넥션 2 반납 (풀: 10개)
```

**시나리오 2: 동시 요청 많은 경우**

```
풀: 10개 커넥션

동시에 15개 요청 발생
  ├─ 10개 요청: 즉시 커넥션 할당 ✅
  └─ 5개 요청: 대기 ⏳
      └─ connection-timeout(30초) 내에 반납되면 ✅
      └─ 30초 초과 시 에러 발생 ❌
```

#### JDBC vs 커넥션 풀 비교

| 항목 | JDBC 직접 사용 | 커넥션 풀 |
|-----|---------------|----------|
| 연결 생성 | 매번 생성 (느림) | 미리 생성 (빠름) |
| 연결 종료 | 매번 종료 | 풀에 반납 (재사용) |
| 성능 | 나쁨 | 좋음 ⭐ |
| 리소스 관리 | 수동 | 자동 ⭐ |
| 동시 요청 처리 | 비효율적 | 효율적 ⭐ |

#### 핵심 정리

**커넥션 풀의 3가지 핵심**:

1. **미리 생성**: 애플리케이션 시작 시 Connection들을 미리 만들어 둠
2. **재사용**: `close()`가 실제 종료가 아니라 풀에 반납 (다시 사용 가능)
3. **자동 관리**: Spring이 빌리기/반납 모두 자동 처리

**개발자가 신경 쓸 것**:
- ❌ Connection 생성/종료: Spring이 자동 처리
- ❌ 커넥션 풀 관리: HikariCP가 자동 처리
- ✅ 적절한 풀 크기 설정: 트래픽에 맞게 조정

**연결 대상**:
- 테이블이 아니라 **데이터베이스(`mydb`)** 에 연결
- 하나의 Connection으로 여러 테이블 작업 가능

---

### 3.2.12 메인 애플리케이션

**SpringdatajbcApplication.java**:
```java
package com.example.springdatajbc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringdatajbcApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringdatajbcApplication.class, args);
    }
}
```

**실행 순서**:
```
1. main() 메서드 실행
2. @SpringBootApplication 처리
   ├─ 컴포넌트 스캔
   ├─ 자동 설정
   └─ 빈 생성
3. application.properties 읽기
   └─ 커넥션 풀 초기화 (DB 연결 10개 생성)
4. @Repository 인터페이스 발견
   └─ 프록시 객체 생성 및 빈 등록
5. @Component 발견
   └─ SpringJdbcApplication 빈 생성 및 의존성 주입
6. ApplicationRunner 구현체 실행
   └─ run() 메서드 호출
7. 애플리케이션 구동 완료
```

---



### 3.2.13 JDBC vs Spring Data JDBC 최종 비교

#### 코드 비교

**JDBC (3.1)**:
```java
// 1. Driver 로딩
Class.forName("com.mysql.cj.jdbc.Driver");

// 2. Connection 생성
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", "myuser", "mypass"
);

// 3. Statement 생성
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM member");

// 4. 쿼리 실행
ResultSet rs = stmt.executeQuery();

// 5. 결과 매핑
while (rs.next()) {
    Member member = new Member(
        rs.getLong("id"),
        rs.getString("name"),
        rs.getString("email"),
        rs.getInt("age")
    );
    System.out.println(member);
}

// 6. 리소스 정리
conn.close();
```

**Spring Data JDBC (3.2)**:
```java
// 설정 파일 (한 번만)
// spring.datasource.url=jdbc:mysql://localhost:3306/mydb

// Repository 인터페이스 (선언만)
public interface MemberRepository extends CrudRepository<Member, Long> {
    List<Member> findByAgeGreaterThan(int age);
}

// 사용
List<Member> members = memberRepository.findAll();
members.forEach(System.out::println);
```

**코드 라인 수**: 25줄 → 3줄 (약 88% 감소!)

#### 장단점 비교

| 특징 | JDBC | Spring Data JDBC |
|-----|------|-----------------|
| **코드 양** | 많음 ❌ | 적음 ✅ |
| **반복 코드** | 많음 ❌ | 없음 ✅ |
| **학습 곡선** | 낮음 ✅ | 중간 |
| **유연성** | 높음 ✅ | 중간 |
| **성능 최적화** | 쉬움 ✅ | 제한적 |
| **생산성** | 낮음 ❌ | 높음 ✅ |
| **커넥션 관리** | 수동 ❌ | 자동 ✅ |
| **SQL 가시성** | 명확 ✅ | 숨겨짐 (로그로 확인) |

---

### 3.2.14 Spring Data JDBC의 한계

#### 한계 1: 복잡한 연관관계

**문제**:
```java
// Member - Order 관계 (1:N)
// Spring Data JDBC에서는 복잡함
@Table
public class Member {
    @Id
    private Long id;
    private String name;
    
    // @ManyToOne 같은 애노테이션이 제한적
}
```
테이블과의 연관관계를 표현할 수 없다.

**해결**: JPA 사용 (3.4에서 학습) @Entity 와 @ManyToOne , @ManyToMany 등등 사용이 가능

#### 한계 2: DDL 자동 생성
DDL 자동 생성 미지원
Spring Data JDBC는 JPA의 핵심 편의 기능 중 하나인 DDL(Data Definition Language) 자동 생성 기능을 지원하지 않음


| 명령어 | 역할 | 
|-----|------|
| **CREATE TABLE** |테이블 생성 |
| **ALTER TABLE** | 테이블 수정|
| **DROP TABLE** | 테이블 삭제 |
| **TRUNCATE TABLE** | 테이블 데이터 삭제 |


📌 문제 상황 (수동 작업 필요)
자바 엔티티에 새로운 필드를 추가하더라도, 데이터베이스 테이블에는 수동으로 SQL을 작성하여 반영해야 합니다.

```java


// Java 엔티티에 필드 추가
@Table
public class Member {
    @Id
    private Long id;
    private String name;
    // ...
    private String phone;  // 👈 새로 추가!
}

```
SQL

- ❌ Spring Data JDBC는 이 부분을 자동으로 처리하지 않음!
- 테이블에 컬럼을 수동으로 추가해야 함!
ALTER TABLE member ADD COLUMN phone VARCHAR(255);
결과: 엔티티 수정 시 SQL을 직접 작성해야 하므로 테이블과 엔티티 불일치 가능성이 높아지고 개발 속도가 저하!

**해결**: JPA 사용 (3.4에서 학습) : JPA는 설정 파일을 통해 애플리케이션 시작 시 엔티티를 분석하여 자동으로 DDL을 실행합니다.
```
application.properties
spring.jpa.hibernate.ddl-auto=update
```


## 3.3 MyBatis

### 3.3.1 MyBatis란?

**MyBatis**는 SQL 중심의 데이터베이스 연동 프레임워크로, **개발자가 작성한 SQL과 Java 객체를 매핑**하는 데 특화되어 있습니다.

#### 핵심 개념

```
[개발자]
    ↓ (SQL 직접 작성)
[MyBatis]
    ↓ (JDBC 코드 자동 생성 및 결과 매핑)
[JDBC Driver]
    ↓
[데이터베이스]
```

**MyBatis의 역할**:
- 개발자: SQL만 작성
- MyBatis: Connection, PreparedStatement, ResultSet 등 **JDBC 보일러플레이트 코드 자동 처리**
- 결과를 Java 객체로 자동 매핑

---

### 3.3.2 Spring Data JDBC vs MyBatis

#### 근본적인 차이

| 특징 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **철학** | 도메인(객체) 중심 | **SQL 중심** ⭐ |
| **SQL 작성** | 메서드 이름 자동 생성 + @Query | **항상 직접 작성** (XML 또는 애노테이션) |
| **SQL 위치** | 인라인(@Query 내부) | **별도 XML 파일** (분리) |
| **동적 SQL** | 제한적 | **강력한 지원** ⭐ |
| **복잡한 쿼리** | 어려움 | **매우 유리** ⭐ |
| **성능 최적화** | 제한적 | **세밀한 제어 가능** ⭐ |
| **학습 곡선** | 낮음 | 중간 |
| **코드 양** | 적음 | 중간 (XML 작성) |

#### 왜 MyBatis를 사용하는가?

**Spring Data JDBC + @Query의 한계**:

```java
// Spring Data JDBC
@Query("SELECT * FROM member WHERE " +
       "(:name IS NULL OR name LIKE %:name%) AND " +
       "(:minAge IS NULL OR age >= :minAge) AND " +
       "(:maxAge IS NULL OR age <= :maxAge)")
List<Member> search(@Param("name") String name, 
                    @Param("minAge") Integer minAge,
                    @Param("maxAge") Integer maxAge);
```

**문제점**:
- ❌ SQL이 Java 문자열 안에 있어 가독성 저하
- ❌ 복잡한 동적 쿼리 작성 어려움
- ❌ SQL 문법 검증 불가 (컴파일 시점)
- ❌ SQL이 길어질수록 유지보수 어려움

**MyBatis의 해결**:

```xml
<!-- XML 파일에 SQL 분리 -->
<select id="search" resultType="Member">
    SELECT * FROM member
    <where>
        <if test="name != null">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="minAge != null">
            AND age >= #{minAge}
        </if>
        <if test="maxAge != null">
            AND age <= #{maxAge}
        </if>
    </where>
</select>
```

**장점**:
- ✅ SQL이 독립된 파일로 분리 (가독성 향상)
- ✅ **동적 SQL** 작성 용이 (`<if>`, `<choose>`, `<foreach>` 등)
- ✅ SQL 재사용 가능 (`<include>`)
- ✅ 조건에 따라 쿼리 자체가 변경 가능
- ✅ 복잡한 JOIN, 서브쿼리에 강함

---

### 3.3.3 MyBatis vs Spring Data JDBC 사용 시나리오

#### Spring Data JDBC 적합한 경우

```
✅ 단순한 CRUD 작업
✅ 단일 테이블 조회/수정
✅ 메서드 이름으로 자동 생성 가능한 쿼리
✅ 간단한 조건 검색

예: findByName(), findByAgeGreaterThan()
```

#### MyBatis 적합한 경우

```
✅ 복잡한 JOIN (3개 이상 테이블)
✅ 동적 SQL (조건에 따라 쿼리 변경)
✅ 복잡한 집계 쿼리 (GROUP BY, HAVING)
✅ 성능 최적화가 중요한 쿼리
✅ SQL에 익숙한 팀
✅ 대규모 프로젝트

예: 검색 기능, 통계 리포트, 복잡한 비즈니스 로직
```

#### 실전 예시

**요구사항**: 회원 검색 (이름, 나이 범위, 정렬 순서 - 모두 선택 사항)

**Spring Data JDBC (복잡함)**:
```java
// 모든 경우의 수를 메서드로 만들어야 함
List<Member> findByName(String name);
List<Member> findByAgeBetween(int min, int max);
List<Member> findByNameAndAgeBetween(String name, int min, int max);
// ... 조합이 늘어날수록 메서드 폭발!
```

**MyBatis (간단함)**:
```xml
<select id="search">
    SELECT * FROM member
    <where>
        <!--    <>태그 안에서는 #{} 이 아닌 바로 접근이 가능하다.     -->
        <if test="name != null">AND name LIKE #{name}</if>
        <if test="minAge != null">AND age >= #{minAge}</if>
        <if test="maxAge != null">AND age <= #{maxAge}</if>
    </where>
    <if test="orderBy != null">
        ORDER BY ${orderBy} ${direction}
    </if>
</select>
```

---

### 3.3.4 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    // MyBatis Spring Boot Starter
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.5'
    
    // H2 Database (내장 DB, 테스트용)
    runtimeOnly 'com.h2database:h2'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter-test:3.0.5'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 |
|-------|------|
| `mybatis-spring-boot-starter` | MyBatis를 Spring Boot에서 쉽게 사용하도록 통합 |
| `h2` | 내장형 데이터베이스 (애플리케이션 재시작 시 초기화) |

**H2 Database의 특징**:
- 애플리케이션에 **내장**되어 실행
- **메모리 기반** (재시작 시 데이터 초기화)
- **테스트 및 개발 환경**에 적합
- 별도 DB 서버 설치 불필요
- H2도 데이터베이스이므로 **JDBC Driver 필요** (h2 의존성이 Driver 포함)

---

### 3.3.5 설정 파일

**application.properties**:
```properties
spring.application.name=mybatisSample

# ========================================
# MyBatis 설정
# ========================================
# SQL이 작성된 XML 파일 위치
mybatis.mapper-locations=classpath:mapper/**/*.xml

# 스네이크 케이스 → 카멜 케이스 자동 변환
mybatis.configuration.map-underscore-to-camel-case=true

# ========================================
# H2 Database 초기화
# ========================================
# schema.sql, data.sql 자동 실행
spring.sql.init.mode=always
spring.sql.init.encoding=utf-8
```

#### 설정 설명

| 속성 | 설명 |
|-----|------|
| `mybatis.mapper-locations` | SQL Mapper XML 파일 경로 (`src/main/resources/mapper/` 하위 모든 XML) |
| `map-underscore-to-camel-case` | DB 컬럼 `user_name` → Java 필드 `userName` 자동 매핑 |
| `spring.sql.init.mode` | 애플리케이션 시작 시 초기화 스크립트 실행 (H2 테스트용) |

---

### 3.3.6 프로젝트 구조

```
src/main/java/com/example/mybatisSample/
├─ mapper/              # Mapper 인터페이스
│  ├─ MemberMapper.java
│  └─ ArticleMapper.java
├─ model/               # 도메인 모델 (Entity)
│  ├─ Member.java
│  └─ Article.java
└─ MyBatisApplication.java

src/main/resources/
├─ mapper/              # SQL Mapper XML
│  └─ MemberMapper.xml
├─ schema.sql           # 테이블 생성 SQL
├─ data.sql             # 초기 데이터 SQL
└─ application.properties
```

---

### 3.3.7 모델 클래스 (Model)

#### Member 클래스

**Member.java**:
```java
package com.example.mybatisSample.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### Article 클래스

**Article.java**:
```java
package com.example.mybatisSample.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    private Long id;
    private String title;
    private String description;
    private Date created;
    private Date updated;
    private Long memberId;
}
```

#### Spring Data JDBC와의 차이
#### 클래스의 정체성

| 프레임워크 | 클래스 역할 | 비유 |
|----------|-----------|------|
| **Spring Data JDBC** | **테이블 + 그릇** | 설계도 = 건물 |
| **MyBatis** | **그릇만** | 창고에서 물건 꺼내서 상자에 담기 |

---

#### Spring Data JDBC - "클래스 = 테이블"

```java
@Table  // ① 테이블 선언 + ② 결과 담는 그릇 (이중 역할!)
public class Member {
    @Id
    private Long id;
    private String name;
}
```

**특징**:
```
클래스 ←→ 테이블 (완전히 동일시)

- 클래스 구조 = 테이블 구조
- 클래스 변경 → 테이블 변경 필요
- 테이블 변경 → 클래스 변경 필요
```

**문제 발생**:
- ❌ **연관관계 표현 제한**: `@ManyToOne`, `@OneToMany` 부족
- ❌ **동기화 필요**: 테이블 ↔ 클래스 항상 일치해야 함
---

#### MyBatis - "클래스 = SQL 결과 담는 그릇"

```java
// 애노테이션 없음! 순수 그릇!
public class Member {
    private Long id;
    private String name;
}
```

```xml
<select id="selectAll" resultType="Member">
    SELECT id, name FROM member
</select>
```

**특징**:
```
SQL 실행 → ResultSet → 클래스(그릇)

- 테이블과 클래스 독립적
- SQL이 테이블 결정
- 클래스는 결과만 담음
```

**문제 해결**:
- ✅ **연관관계 자유**: SQL로 JOIN 마음대로
- ✅ **동기화 불필요**: 테이블 ↔ 클래스 독립적
- ✅ **필요한 컬럼만**: SELECT id, name만 가능

---

#### 비교표

| 항목 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **클래스 정체성** | 테이블 그 자체 | SQL 결과 그릇 |
| **테이블 매핑** | `@Table` 필수 | 애노테이션 불필요 |
| **테이블-클래스 관계** | 완전히 동일해야 함 | 독립적 |
| **연관관계** | ❌ 제한적 | ✅ SQL로 자유롭게 |
| **테이블 변경 시** | ❌ 클래스도 변경 | ✅ SQL만 변경 |
| **클래스 변경 시** | ❌ 테이블도 변경 | ✅ 영향 없음 |
| **동기화 문제** | ❌ 항상 발생 | ✅ 없음 |

---

#### 실전 예시

##### 시나리오: 테이블에 phone 컬럼 추가

**데이터베이스**:
```sql
ALTER TABLE member ADD COLUMN phone VARCHAR(20);
```

**Spring Data JDBC**:
```java
@Table
public class Member {
    @Id private Long id;
    private String name;
    private String phone;  // ❌ 필수 추가! (안 하면 문제)
}
```

**MyBatis**:
```java
// ✅ 클래스 그대로 사용 가능!
public class Member {
    private Long id;
    private String name;
    // phone 없어도 됨!
}
```

```xml
<!-- ✅ 필요할 때만 SELECT -->
<select id="selectAll" resultType="Member">
    SELECT id, name FROM member  <!-- phone 안 가져와도 OK -->
</select>

<!-- phone 필요한 경우만 별도 쿼리 -->
<select id="selectWithPhone" resultType="MemberWithPhone">
    SELECT id, name, phone FROM member
</select>
```

---

##### 시나리오: Member-Order 연관관계

**Spring Data JDBC**:
```java
@Table
public class Member {
    @Id private Long id;
    private String name;
    
    // ❌ 연관관계 표현이 제한적
    // private List<Order> orders;
}
```

**MyBatis**:
```java
// 그냥 그릇!
public class Member {
    private Long id;
    private String name;
}

public class MemberWithOrders {
    private Long id;
    private String name;
    private List<Order> orders;  // ✅ 자유롭게 구성
}
```

```xml
<!-- ✅ SQL로 자유롭게 JOIN -->
<select id="selectMemberWithOrders" resultType="MemberWithOrders">
    SELECT 
        m.id, m.name,
        o.id as order_id, o.product_name
    FROM member m
    LEFT JOIN orders o ON m.id = o.member_id
    WHERE m.id = #{id}
</select>
```

---

#### 핵심 요약

**Spring Data JDBC**:
```
@Table = "나는 member 테이블이면서 동시에 그릇이야!"

장점: 간단한 CRUD 자동화
단점: 테이블 = 클래스 (강제), 연관관계 약함, 동기화 필요
```

**MyBatis**:
```
클래스 = "나는 그냥 그릇이야! 테이블은 SQL이 결정해!"

장점: 테이블-클래스 독립, 연관관계 자유, 복잡한 쿼리 강력
단점: SQL 직접 작성 필요
```

**결론**:
- Spring Data JDBC의 **한계 (연관관계, 동기화)**는 MyBatis에서 **애초에 발생하지 않음**
- 하지만 MyBatis는 모든 SQL을 직접 작성해야 하는 번거로움 존재


### 3.3.8 Mapper 인터페이스

#### @Mapper 애노테이션

**역할**: 이 인터페이스가 MyBatis의 SQL 매핑 인터페이스임을 선언

```java
@Mapper  // MyBatis가 인식
public interface MemberMapper {
    List<Member> selectAll();
}
```

**Spring의 처리**:
```
1. @Mapper 스캔
2. 프록시 객체 자동 생성 (구현체)
3. 스프링 빈으로 등록
4. 다른 클래스에서 주입 가능
```

**Spring Data JDBC와 비교**:

| 프레임워크 | 애노테이션 | 역할 |
|----------|-----------|------|
| Spring Data JDBC | `@Repository` | 데이터 접근 계층 |
| MyBatis | `@Mapper` | SQL 매핑 인터페이스 |

> **공통점**: 둘 다 인터페이스만 정의하면 Spring이 구현체를 자동 생성!

---

### 3.3.9 XML 기반 SQL 매핑

#### MemberMapper 인터페이스

**MemberMapper.java**:
```java
package com.example.mybatisSample.mapper;

import com.example.mybatisSample.model.Member;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Optional;

@Mapper
public interface MemberMapper {
    List<Member> selectAll();
    Optional<Member> selectById(@Param("id") Long id);
    Optional<Member> selectByEmail(@Param("email") String email);
    List<Member> selectAllOrderByAgeAsc();
    List<Member> selectAllOrderBy(@Param("order") String order, @Param("dir") String dir);
    List<Member> selectByNameLike(@Param("name") String name);
    int selectCount();
    int insert(@Param("member") Member member);
    int update(@Param("member") Member member);
    int delete(@Param("member") Member member);
    int deleteById(@Param("id") Long id);
    int deleteAll();
}
```

#### @Param 애노테이션

**역할**: 메서드 매개변수에 이름을 부여하여 XML/애노테이션 SQL에서 참조

```java
Optional<Member> selectByEmail(@Param("email") String email);
                               ─────────────
                                     ↓
                               XML에서 #{email}로 참조
```

**사용 예시**:
```java
// 단일 파라미터
selectById(@Param("id") Long id)
// XML: #{id}

// 객체 파라미터
insert(@Param("member") Member member)
// XML: #{member.name}, #{member.email}

// 복수 파라미터
selectAllOrderBy(@Param("order") String order, @Param("dir") String dir)
// XML: #{order}, #{dir}
```

---

### 3.3.10 MemberMapper.xml

**src/main/resources/mapper/MemberMapper.xml**:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.mybatisSample.mapper.MemberMapper">

    <!-- 전체 조회 -->
    <select id="selectAll" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member
    </select>

    <!-- ID로 조회 -->
    <select id="selectById" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE id = #{id}
    </select>

    <!-- 이메일로 조회 -->
    <select id="selectByEmail" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE email = #{email}
    </select>

    <!-- 나이 오름차순 정렬 -->
    <select id="selectAllOrderByAgeAsc" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member ORDER BY age ASC
    </select>

    <!-- 동적 정렬 -->
    <select id="selectAllOrderBy" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member ORDER BY ${order} ${dir}
    </select>

    <!-- 이름 LIKE 검색 -->
    <select id="selectByNameLike" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE name LIKE #{name}
    </select>

    <!-- 개수 조회 -->
    <select id="selectCount" resultType="int">
        SELECT COUNT(*) FROM member
    </select>

    <!-- 삽입 (자동 생성 키 반환) -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="member.id" keyColumn="id">
        INSERT INTO member(name, email, age) 
        VALUES (#{member.name}, #{member.email}, #{member.age})
    </insert>

    <!-- 수정 -->
    <update id="update">
        UPDATE member 
        SET name = #{member.name}, email = #{member.email}, age = #{member.age} 
        WHERE id = #{member.id}
    </update>

    <!-- 삭제 (객체) -->
    <delete id="delete">
        DELETE FROM member WHERE id = #{member.id}
    </delete>

    <!-- 삭제 (ID) -->
    <delete id="deleteById">
        DELETE FROM member WHERE id = #{id}
    </delete>

    <!-- 전체 삭제 -->
    <delete id="deleteAll">
        DELETE FROM member
    </delete>

</mapper>
```

---

### 3.3.11 XML 태그 상세 설명

#### 기본 구조

| 태그 | 역할 | 필수 속성 |
|-----|------|----------|
| `<mapper>` | 루트 태그 | `namespace` |
| `<select>` | SELECT 쿼리 | `id`, `resultType` |
| `<insert>` | INSERT 쿼리 | `id` |
| `<update>` | UPDATE 쿼리 | `id` |
| `<delete>` | DELETE 쿼리 | `id` |

#### namespace

```xml
<mapper namespace="com.example.mybatisSample.mapper.MemberMapper">
```

**역할**: 이 XML이 어떤 Mapper 인터페이스와 연결될지 지정

**매핑 과정**:
```
1. MyBatis가 @Mapper 인터페이스 스캔
2. namespace와 인터페이스 경로 비교
3. 일치하면 XML과 인터페이스 연결
4. 메서드 호출 시 id와 일치하는 SQL 실행
```

#### id 속성

```xml
<select id="selectAll">
```

**역할**: Mapper 인터페이스의 메서드 이름과 **정확히 일치**해야 함

```java
// 인터페이스
List<Member> selectAll();

// XML
<select id="selectAll">  // 메서드명과 동일!
```

#### resultType

```xml
<select id="selectAll" resultType="com.example.mybatisSample.model.Member">
```

**역할**: SQL 실행 결과를 어떤 Java 타입으로 매핑할지 지정

**타입별 사용**:
```xml
<!-- 단일 객체 -->
<select resultType="com.example.mybatisSample.model.Member">

<!-- 리스트 (요소 타입 지정) -->
<select resultType="com.example.mybatisSample.model.Member">

<!-- 기본 타입 -->
<select resultType="int">
<select resultType="String">
<select resultType="Long">
```

---

### 3.3.12 파라미터 바인딩

#### #{} vs ${}

| 문법 | 설명 | SQL 변환 | 사용 |
|-----|------|---------|------|
| `#{파라미터}` | **PreparedStatement** (권장) | `?`로 치환 | 값 바인딩 |
| `${파라미터}` | **Statement** (주의) | 문자열 직접 삽입 | 테이블명, 컬럼명 |

#### #{} (권장) ⭐

```xml
<select id="selectById">
    SELECT * FROM member WHERE id = #{id}
</select>
```

**변환 과정**:
```
1. SQL: SELECT * FROM member WHERE id = ?
2. PreparedStatement 사용
3. id 값을 안전하게 바인딩
```

**장점**:
- ✅ **SQL Injection 방지**
- ✅ 자동 타입 변환
- ✅ null 처리 안전

#### ${} (주의!)

```xml
<select id="selectAllOrderBy">
    SELECT * FROM member ORDER BY ${order} ${dir}
</select>
```

**변환 과정**:
```
1. order = "name", dir = "ASC"
2. SQL: SELECT * FROM member ORDER BY name ASC
3. 문자열 직접 치환
```

**주의사항**:
- ❌ **SQL Injection 위험**
- ❌ 사용자 입력값에 사용 금지
- ✅ 테이블명, 컬럼명, ORDER BY 절에만 사용

**안전한 사용 예시**:
```java
// 컨트롤러에서 값 검증
String order = "name";  // 화이트리스트 검증
if (!List.of("name", "age", "email").contains(order)) {
    throw new IllegalArgumentException("잘못된 정렬 기준");
}
```

---

### 3.3.13 자동 생성 키 처리

#### useGeneratedKeys

```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="member.id" keyColumn="id">
    INSERT INTO member(name, email, age) 
    VALUES (#{member.name}, #{member.email}, #{member.age})
</insert>
```

#### 속성 설명

| 속성 | 역할 |
|-----|------|
| `useGeneratedKeys="true"` | DB가 자동 생성한 키(AUTO_INCREMENT)를 가져옴 |
| `keyColumn="id"` | DB 테이블의 자동 생성 키 컬럼명 |
| `keyProperty="member.id"` | 생성된 키 값을 저장할 Java 객체 필드 |

#### 동작 과정

```java
Member member = Member.builder()
                      .name("홍혜창")
                      .email("test@example.com")
                      .age(25)
                      .build();

System.out.println(member.getId());  // null

memberMapper.insert(member);  // INSERT 실행

System.out.println(member.getId());  // 5 (DB에서 생성된 ID)
```

**내부 동작**:
```
1. INSERT SQL 실행
2. DB가 id = 5 자동 생성
3. MyBatis가 생성된 5를 가져옴
4. member.setId(5) 자동 호출
5. member 객체 재사용 가능
```

#### useGeneratedKeys 생략 시

```xml
<!-- useGeneratedKeys 없음 -->
<insert id="insert">
    INSERT INTO member(name, email, age) VALUES (#{member.name}, #{member.email}, #{member.age})
</insert>
```

```java
Member member = Member.builder().name("홍혜창").build();
memberMapper.insert(member);

System.out.println(member.getId());  // null (ID가 채워지지 않음)
```

**결과**:
- DB에는 레코드 정상 생성 (AUTO_INCREMENT 작동)
- Java 객체에는 ID가 채워지지 않음

#### 사용 시나리오

| 상황 | useGeneratedKeys 설정 | 이유 |
|-----|---------------------|------|
| **ID 재사용 필요** | ✅ 필수 | 생성된 ID로 후속 작업 필요 |
| **ID 재사용 불필요** | ❌ 생략 가능 | 단순 INSERT만 수행 |

**예시**:
```java
// 시나리오: 회원 가입 후 환영 이메일 발송
Member member = new Member("홍혜창", "test@example.com", 25);
memberMapper.insert(member);  // useGeneratedKeys="true"

// 생성된 ID로 환영 이메일 발송
emailService.sendWelcome(member.getId(), member.getEmail());
```

---

### 3.3.14 애노테이션 기반 SQL 매핑

#### ArticleMapper 인터페이스

**ArticleMapper.java**:
```java
package com.example.mybatisSample.mapper;

import com.example.mybatisSample.model.Article;
import org.apache.ibatis.annotations.*;

import java.util.List;
import java.util.Optional;

@Mapper
public interface ArticleMapper {
    
    @Select("SELECT * FROM article")
    List<Article> selectAll();
    
    @Select("SELECT * FROM article WHERE id = #{id}")
    Optional<Article> selectById(@Param("id") Long id);
    
    @Insert("INSERT INTO article(title, description, created, updated, member_id) " +
            "VALUES (#{article.title}, #{article.description}, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, #{article.memberId})")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "article.id")
    int insert(@Param("article") Article article);
    
    @Update("UPDATE article SET title = #{title}, description = #{description}, updated = CURRENT_TIMESTAMP WHERE id = #{id}")
    int update(@Param("id") Long id, @Param("title") String title, @Param("description") String description);
    
    @Delete("DELETE FROM article WHERE id = #{id}")
    int deleteById(@Param("id") Long id);
}
```

#### 애노테이션 종류

| 애노테이션 | 역할 | SQL 종류 |
|-----------|------|----------|
| `@Select` | SELECT 쿼리 | 조회 |
| `@Insert` | INSERT 쿼리 | 삽입 |
| `@Update` | UPDATE 쿼리 | 수정 |
| `@Delete` | DELETE 쿼리 | 삭제 |
| `@Options` | 추가 옵션 (자동 생성 키 등) | INSERT |

#### XML vs 애노테이션 비교

**XML 방식**:
```xml
<!-- MemberMapper.xml -->
<select id="selectAll" resultType="Member">
    SELECT * FROM member
</select>
```

**애노테이션 방식**:
```java
// ArticleMapper.java
@Select("SELECT * FROM article")
List<Article> selectAll();
```

#### 언제 어떤 방식을 사용할까?

| 상황 | XML | 애노테이션 |
|-----|-----|-----------|
| **단순한 쿼리** | ❌ | ✅ 권장 |
| **복잡한 쿼리** | ✅ 권장 | ❌ |
| **동적 SQL** | ✅ 권장 | ❌ |
| **SQL 재사용** | ✅ 권장 | ❌ |
| **빠른 프로토타이핑** | ❌ | ✅ 권장 |

**실무 권장**:
- 복잡한 쿼리, 동적 SQL → **XML**
- 단순한 CRUD → **애노테이션**

---

### 3.3.15 컬럼명과 필드명 불일치 해결

#### 문제 상황

**데이터베이스**:
```sql
CREATE TABLE article (
    id BIGINT,
    title VARCHAR(255),
    content VARCHAR(1000),  -- Java 필드는 'description'
    member_id BIGINT
);
```

**Java 클래스**:
```java
public class Article {
    private Long id;
    private String title;
    private String description;  // DB 컬럼은 'content'
    private Long memberId;
}
```

#### 해결 방법

##### 방법 1: application.properties 설정 (권장) ⭐

```properties
mybatis.configuration.map-underscore-to-camel-case=true
```

**자동 변환**:
```
DB: member_id  → Java: memberId
DB: created_at → Java: createdAt
DB: user_name  → Java: userName
```

**장점**:
- ✅ 전역 설정 (한 번만 작성)
- ✅ 스네이크 케이스 ↔ 카멜 케이스 자동 변환
- ✅ 대부분의 불일치 문제 해결

**한계**:
- ❌ `content` ↔ `description` 같은 완전히 다른 이름은 해결 못 함

##### 방법 2: SQL AS 키워드 (선택적)

```sql
SELECT id, title, content AS description, member_id 
FROM article
```

**적용**:
```java
@Select("SELECT id, title, content AS description, member_id FROM article")
List<Article> selectAll();
```

**장점**:
- ✅ 간단한 경우 빠르게 해결

**단점**:
- ❌ 모든 SELECT 문에 반복 작성
- ❌ 유지보수 어려움

##### 방법 3: `<resultMap>` (완전한 제어) ⭐

**XML**:
```xml
<resultMap id="articleResult" type="com.example.mybatisSample.model.Article">
    <result column="content" property="description"/>
    <result column="member_id" property="memberId"/>
</resultMap>

<select id="selectAll" resultMap="articleResult">
    SELECT * FROM article
</select>

<select id="selectById" resultMap="articleResult">
    SELECT * FROM article WHERE id = #{id}
</select>
```

**재사용 가능**:
- 한 번 정의하면 여러 쿼리에서 `resultMap="articleResult"` 참조

**애노테이션**:
```java
@Results(id = "articleResult", value = {
    @Result(column = "content", property = "description"),
    @Result(column = "member_id", property = "memberId")
})
@Select("SELECT * FROM article")
List<Article> selectAll();

@ResultMap("articleResult")  // 재사용
@Select("SELECT * FROM article WHERE id = #{id}")
Optional<Article> selectById(@Param("id") Long id);
```

**사용 시점**:
- 첫 번째 쿼리: `@Results`로 정의
- 이후 쿼리: `@ResultMap`으로 재사용

**장점**:
- ✅ 완전한 커스텀 매핑 가능
- ✅ 재사용 가능
- ✅ 복잡한 매핑 처리 가능

**단점**:
- ❌ 코드가 길어짐

#### 권장 순서

```
1. map-underscore-to-camel-case=true (대부분 해결)
   ↓
2. 안 되면 AS 키워드 (간단한 경우)
   ↓
3. 여전히 안 되면 <resultMap> (복잡한 경우)
```

---

### 3.3.16 애플리케이션 실행

#### MyBatisApplication 클래스

**MyBatisApplication.java**:
```java
package com.example.mybatisSample;

import com.example.mybatisSample.mapper.ArticleMapper;
import com.example.mybatisSample.mapper.MemberMapper;
import com.example.mybatisSample.model.Article;
import com.example.mybatisSample.model.Member;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Slf4j
@RequiredArgsConstructor
@Component
public class MyBatisApplication implements ApplicationRunner {
    
    private final ArticleMapper articleMapper;
    private final MemberMapper memberMapper;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        
        // 1. 회원 수 조회
        int count = memberMapper.selectCount();
        log.info("count: {}", count);

        // 2. 이메일로 회원 조회
        Member member = memberMapper.selectByEmail("hyechang@spring.ac.kr")
                                     .orElseThrow();
        log.info("member: {}", member);

        // 3. 게시글 작성
        Article article = Article.builder()
                                 .title("제목입니다.")
                                 .description("내용입니다.")
                                 .memberId(member.getId())
                                 .build();
        
        int insert = articleMapper.insert(article);
        log.info("insert: {}", insert);
        log.info("생성된 게시글 ID: {}", article.getId());  // 자동 생성된 ID 출력
    }
}
```

#### 메인 클래스

**MybatisSampleApplication.java**:
```java
package com.example.mybatisSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MybatisSampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(MybatisSampleApplication.class, args);
    }
}
```

---

### 3.3.17 실행 결과 및 로그

#### 실행 결과 로그 출력

```
 :: Spring Boot ::                (v3.5.6)

2025-10-15T12:56:13.692+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : Starting MybatisSampleApplication using Java 21.0.8 with PID 32404 (C:\Users\ghddm\Desktop\SpringBoot\mybatisSample\build\classes\java\main started by ghddm in C:\Users\ghddm\Desktop\SpringBoot\mybatisSample)
2025-10-15T12:56:13.698+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : No active profile set, falling back to 1 default profile: "default"
2025-10-15T12:56:15.404+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-10-15T12:56:15.834+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection conn0: url=jdbc:h2:mem:daa4c2b0-93b6-4052-8dca-ecd1ca6e5774 user=SA
2025-10-15T12:56:15.839+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-10-15T12:56:16.510+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : Started MybatisSampleApplication in 4.122 seconds (process running for 5.349)
2025-10-15T12:56:16.571+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : count: 4
2025-10-15T12:56:16.581+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : member: Member(id=1, name=홍혜창, email=hyechang@spring.ac.kr, age=10)
2025-10-15T12:56:16.589+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : insert: 1
2025-10-15T12:56:16.599+09:00  INFO 32404 --- [mybatisSample] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2025-10-15T12:56:16.603+09:00  INFO 32404 --- [mybatisSample] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
```

---

### 3.3.18 Spring Data JDBC vs MyBatis 최종 비교

#### 코드 비교

**Spring Data JDBC**:
```java
// Repository 인터페이스
public interface MemberRepository extends CrudRepository<Member, Long> {
    List<Member> findByEmail(String email);  // 메서드 이름으로 자동 생성
    
    @Query("SELECT * FROM member WHERE name LIKE :name")  // 복잡한 쿼리는 @Query
    List<Member> searchByName(@Param("name") String name);
}
```

**MyBatis**:
```java
// Mapper 인터페이스
@Mapper
public interface MemberMapper {
    Optional<Member> selectByEmail(@Param("email") String email);
    List<Member> searchByName(@Param("name") String name);
}
```

```xml
<!-- SQL은 XML에 분리 -->
<select id="selectByEmail">
    SELECT * FROM member WHERE email = #{email}
</select>

<select id="searchByName">
    SELECT * FROM member WHERE name LIKE #{name}
</select>
```

#### 특징 비교

| 특징 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **SQL 자동 생성** | ✅ 메서드 이름 규칙 | ❌ 항상 직접 작성 |
| **SQL 위치** | Java 코드 내부 | **XML 파일 분리** ⭐ |
| **동적 SQL** | 제한적 | **강력한 지원** ⭐ |
| **복잡한 쿼리** | 어려움 | **매우 유리** ⭐ |
| **코드 양** | 적음 | 중간 (XML) |
| **학습 곡선** | 낮음 | 중간 |
| **SQL 제어** | 제한적 | **완전한 제어** ⭐ |
| **가독성** | 중간 | **높음** (SQL 분리) ⭐ |
| **테스트** | 쉬움 | 중간 |

---

### 3.3.19 MyBatis의 장단점

#### 장점

**1. SQL에 대한 완전한 제어** ⭐
```xml
<!-- 복잡한 JOIN도 자유롭게 -->
<select id="selectWithMember">
    SELECT a.*, m.name as member_name
    FROM article a
    INNER JOIN member m ON a.member_id = m.id
    WHERE a.created > #{startDate}
    ORDER BY a.created DESC
</select>
```

**2. 동적 SQL 강력** ⭐
```xml
<select id="search">
    SELECT * FROM member
    <where>
        <if test="name != null">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="minAge != null">
            AND age >= #{minAge}
        </if>
        <if test="maxAge != null">
            AND age <= #{maxAge}
        </if>
    </where>
    <if test="orderBy != null">
        ORDER BY ${orderBy} ${direction}
    </if>
</select>
```

**3. SQL 분리로 가독성 향상** ⭐
```
Java 코드: 비즈니스 로직만
XML 파일: SQL만

→ 관심사의 분리 (Separation of Concerns)
```

**4. 성능 최적화 용이**
- 필요한 컬럼만 선택 가능
- 복잡한 서브쿼리, WITH절 자유롭게 사용
- 인덱스 힌트 등 DB 특화 기능 활용

**5. SQL에 익숙한 팀에 적합**
- DBA가 작성한 최적화된 SQL 그대로 사용
- 기존 SQL 자산 재활용 가능

#### 단점

**1. 보일러플레이트 증가**
```java
// 메서드마다 SQL 작성 필요
@Select("SELECT * FROM member")
List<Member> selectAll();

@Select("SELECT * FROM member WHERE id = #{id}")
Optional<Member> selectById(@Param("id") Long id);
```

**2. 단순 CRUD도 직접 작성**
```xml
<!-- Spring Data JDBC는 자동인데... -->
<select id="findById">SELECT * FROM member WHERE id = #{id}</select>
<insert id="insert">INSERT INTO member(...) VALUES(...)</insert>
<update id="update">UPDATE member SET ... WHERE id = #{id}</update>
<delete id="delete">DELETE FROM member WHERE id = #{id}</delete>
```

**3. XML 파일 관리 부담**
- 인터페이스와 XML 파일 동기화 필요
- 메서드명 오타 시 런타임 에러

**4. 타입 안전성 부족**
```xml
<!-- 컴파일 시점에 오류 발견 못 함 -->
<select id="selectById">
    SELECT * FROM member WHERE id = #{idx}  <!-- id가 아니라 idx? -->
</select>
```

---

### 3.3.20 핵심 정리

#### MyBatis의 3가지 핵심

**1. SQL 중심 접근**
```
개발자: SQL 작성에 집중
MyBatis: JDBC 보일러플레이트 제거
```

**2. XML 분리**
```
Java: 비즈니스 로직
XML: SQL
→ 관심사의 분리
```

**3. 동적 SQL**
```
<if>, <choose>, <foreach> 등으로
조건에 따라 SQL 동적 생성
```



## 3.4 JPA - Part 1: 기본 개념, 엔티티 매핑, 리포지토리

### 3.4.1 JPA (Java Persistence API)란?

**JPA**는 Java 애플리케이션에서 **객체와 데이터베이스 테이블을 매핑**하고 관리하는 **표준 인터페이스**입니다.

#### ORM (Object-Relational Mapping) - 핵심 개념

지금까지 배운 데이터베이스 접근 방식들과 JPA의 근본적인 차이는 **기준이 무엇인가**입니다.

| 방식 | 기준 | 접근 방법 |
|-----|------|----------|
| **JDBC** | 테이블 중심 | 테이블 구조 → SQL 작성 → 결과를 객체로 변환 |
| **Spring Data JDBC** | 테이블 중심 | 테이블과 객체 동기화 필수 |
| **MyBatis** | SQL 중심 | 최적화된 SQL 작성 → 결과를 객체로 매핑 |
| **JPA** | **객체 중심** | 객체 설계 → 매핑 정의 → SQL 자동 생성 |

**ORM의 철학**:
```
개발자: 객체(Object)를 설계하고 관리
    ↓
JPA: 객체와 테이블의 관계(Relational) 정의
    ↓
Hibernate: 매핑(Mapping) 기반 SQL 자동 생성 및 실행
    ↓
Database: 테이블에서 데이터 저장/조회
```

**핵심**: 테이블을 생각하지 않고 **객체만 생각**하면 된다!

---

#### JPA, Hibernate, Spring Data JPA의 관계

**문제**: JPA는 인터페이스일 뿐 구현체가 아닙니다.

**해결 방법**:

| 계층 | 역할 | 제공자 |
|-----|------|--------|
| **JPA (표준 인터페이스)** | ORM의 표준 명세 정의 | Oracle (Java 표준) |
| **Hibernate** | JPA의 실제 구현체 | 오픈소스 프로젝트 |
| **Spring Data JPA** | Hibernate를 Spring에서 쉽게 사용하도록 통합 | Spring |

**구조**:
```
개발자
  ↓
Spring Data JPA (편의 계층)
  ↓
Hibernate (구현체)
  ↓
JPA (표준 인터페이스)
  ↓
JDBC Driver
  ↓
Database
```

---

### 3.4.2 프로젝트 설정

#### 의존성 (build.gradle)

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.mysql:mysql-connector-j'
    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

**주요 의존성**:
- `spring-boot-starter-data-jpa`: Spring Data JPA + Hibernate 통합
- `mysql-connector-j`: MySQL JDBC Driver (JPA는 JDBC를 기반으로 동작)

---

#### 설정 파일 (application.properties)

```properties
spring.application.name=jpaHibernateSample

# 데이터베이스 연결 (MySQL)
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass

# DDL 관리 전략
spring.jpa.hibernate.ddl-auto=create

# SQL 로깅 활성화 (개발용)
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.highlight_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true
```

#### 설정 파일 상세 설명

##### `spring.jpa.hibernate.ddl-auto` - DDL 관리 전략

이 속성은 **Hibernate**의 기능으로, 애플리케이션 시작 시 엔티티 정의와 데이터베이스 스키마를 **어떻게 동기화**할지 결정합니다.

| 전략 | 동작 | 용도 |
|-----|------|------|
| **`create`** | 시작 시 기존 테이블 삭제(`DROP`) → 엔티티 기반 새로 생성(`CREATE`) | 개발 초기, 테스트 환경 |
| **`create-drop`** | `create`와 동일하게 생성 후, 애플리케이션 정상 종료 시 테이블 삭제 | 단위 테스트, 통합 테스트 |
| **`update`** | 기존 테이블 유지하며 엔티티와의 차이점만 반영 (컬럼 추가는 함, 삭제는 안 함) | 개발 환경 (데이터 유지) |
| **`validate`** | 데이터베이스 스키마와 엔티티 검증만 수행, DDL 작업 없음 | 스테이징, 운영 환경 |
| **`none`** | DDL 작업 완전히 수행 안 함 | 운영 환경 |

**운영 환경에서 `validate` 또는 `none` 사용 이유**:
```
운영 중인 데이터베이스는 고객 데이터, 거래 기록 등 매우 중요한 정보를 담고 있습니다.
자동 스키마 변경은 예측 불가능한 문제를 일으킬 수 있으므로,
테이블 구조를 개발자가 Migration 툴로 수동 관리합니다.
```

---

##### SQL 로깅 설정

```properties
spring.jpa.show-sql=true                          # SQL 출력 활성화
spring.jpa.properties.hibernate.format_sql=true   # SQL 줄바꿈 및 들여쓰기
spring.jpa.properties.hibernate.highlight_sql=true # 색상 강조 (IDE 지원 시)
spring.jpa.properties.hibernate.use_sql_comments=true # 쿼리 주석 추가
```

**목적**: 생성된 SQL을 보기 좋게 출력하여 **디버깅 및 테스트 효율성 향상**

---

### 3.4.3 엔티티 클래스 (Entity) - 가장 중요!

#### Member 엔티티

```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(
    name = "vip_table",
    indexes = {
        @Index(name = "idx_name", columnList = "display_name, age"),
        @Index(name = "idx_email", columnList = "primary_contact")
    }
)
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Member {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "display_name", length = 2048, nullable = false, unique = true)
    private String name;
    
    @Column(name = "primary_contact")
    private String email;
    
    private Integer age;
    
    @Transient
    private String address;
}
```

---

#### 핵심 어노테이션 상세 설명

##### `@Entity` - 테이블 매핑 선언

```java
@Entity
public class Member { ... }
```

| 항목 | 설명 |
|-----|------|
| **역할** | 이 Java 클래스가 데이터베이스 테이블과 매핑되는 **엔티티(Entity)**임을 JPA에 선언 |
| **의미** | 클래스의 인스턴스 하나 = 테이블의 한 레코드(행) |
| **자동 처리** | Hibernate가 이 클래스를 기반으로 테이블 자동 생성 (DDL 설정에 따라) |

**Spring Data JDBC와의 비교**:

| 항목 | Spring Data JDBC | JPA |
|-----|-----------------|-----|
| **매핑 선언** | `@Table` | `@Entity` |
| **테이블 생성** | 스키마 자동 생성 미지원 | **DDL 자동 생성** ⭐ |
| **테이블-클래스 동기화** | 수동 (매번 일치시켜야 함) | **자동** (엔티티 기준) |
| **연관관계 표현** | 제한적 | **강력한 지원** ⭐ |

---

##### `@Table` - 테이블 상세 매핑

```java
@Table(
    name = "vip_table",
    indexes = {
        @Index(name = "idx_name", columnList = "display_name, age")
    }
)
```

| 속성 | 역할 |
|-----|------|
| **`name`** | 엔티티가 매핑될 테이블의 실제 이름 (생략 시 클래스 이름 사용) |
| **`indexes`** | 테이블에 생성할 인덱스 목록 |

##### `@Index` - 인덱스 정의

```java
@Index(name = "idx_name", columnList = "display_name, age")
```

| 속성 | 값 | 의미 |
|-----|-----|------|
| **`name`** | `"idx_name"` | DB에 생성될 인덱스의 이름 (관리 목적) |
| **`columnList`** | `"display_name, age"` | 인덱스를 구성할 **DB 컬럼명** (Java 필드명 아님!) |

**⚠️ 주의**: columnList에는 **반드시 `@Column(name="...")에 지정한 DB 컬럼명**을 사용해야 합니다.

**잘못된 예**:
```java
@Index(name = "idx_name", columnList = "name, age")  // ❌ Java 필드명 사용
```

**올바른 예**:
```java
@Index(name = "idx_name", columnList = "display_name, age")  // ✅ DB 컬럼명 사용
```

---

##### `@Id` - 기본 키 지정

```java
@Id
private Long id;
```

| 항목 | 설명 |
|-----|------|
| **역할** | 해당 필드를 데이터베이스 **기본 키(Primary Key)**로 지정 |
| **의미** | 각 레코드를 유일하게 식별하는 필드 |
| **필수** | 모든 `@Entity`는 반드시 하나의 `@Id`를 가져야 함 |

---

##### `@GeneratedValue` - ID 생성 전략

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

**역할**: 기본 키 값이 **자동으로 생성되는 방식**을 지정합니다.

| 전략 | `GenerationType` | ID 생성 주체 | 동작 순서 |
|-----|-----------------|-----------|---------|
| **IDENTITY** | `IDENTITY` | 데이터베이스 | 1. INSERT 실행 2. DB가 ID 생성 3. ID를 객체에 반영 |
| **SEQUENCE** | `SEQUENCE` | 데이터베이스 | 1. ID 미리 요청 2. ID를 객체에 반영 3. INSERT 실행 |
| **TABLE** | `TABLE` | JPA/애플리케이션 | 1. 관리 테이블 조회 2. ID 생성 3. INSERT 실행 |
| **AUTO** | `AUTO` | JPA (DB에 맞춰 선택) | DB 종류에 따라 `IDENTITY` 또는 `SEQUENCE` 자동 선택 |

**각 전략의 특징**:

- **IDENTITY**: MySQL, PostgreSQL에서 주로 사용. 간단하지만 ID 즉시 확보 불가
- **SEQUENCE**: Oracle, PostgreSQL에서 주로 사용. 배치 처리 최적화 가능
- **AUTO** (권장): 개발자가 DB 종류를 신경 쓸 필요 없음

**save() 호출 후 ID 자동 반영 예시**:

```java
Member member = Member.builder()
                      .name("혜창")
                      .email("hyechang@spring.ac.kr")
                      .age(20)
                      .build();

System.out.println(member.getId());  // null (아직 저장 안 됨)

memberRepository.save(member);       // INSERT 실행, ID 자동 생성 및 반영

System.out.println(member.getId());  // 1 (DB가 자동 생성한 ID 포함)
```

---

##### `@Column` - 컬럼 상세 매핑

```java
@Column(name = "display_name", length = 2048, nullable = false, unique = true)
private String name;
```

| 속성 | 값 | 역할 |
|-----|-----|------|
| **`name`** | `"display_name"` | Java 필드명과 DB 컬럼명을 다르게 지정 (Java: `name` → DB: `display_name`) |
| **`length`** | `2048` | VARCHAR 컬럼의 최대 길이 (생략 시 기본값 255) |
| **`nullable`** | `false` | `NOT NULL` 제약조건 (NULL 값 허용 안 함) |
| **`unique`** | `true` | `UNIQUE` 제약조건 (중복 값 허용 안 함) |

**생략 시 기본 동작**:
```java
private String email;  // @Column 생략

// 기본 매핑:
// - DB 컬럼명: email (필드명과 동일)
// - nullable: true (NULL 허용)
// - length: 255 (VARCHAR 기본값)
```

---

##### `@Transient` - 데이터베이스 매핑 제외

```java
@Transient
private String address;
```

| 항목 | 설명 |
|-----|------|
| **역할** | 해당 필드를 데이터베이스 매핑에서 제외 |
| **의미** | DB 테이블에 컬럼이 생성되지 않음 |
| **용도** | 임시 값, 계산된 값, 세션 정보 등 **메모리에만 필요한 데이터** |

**동작**:
```java
member.setAddress("서울시 강남구");  // 메모리에만 저장됨
memberRepository.save(member);      // address는 INSERT에 포함되지 않음

Member loaded = memberRepository.findById(1L).orElse(null);
System.out.println(loaded.getAddress());  // null (DB에서 로드한 것이므로)
```

---

#### 생성되는 DDL (SQL)

위 Member 엔티티로부터 자동 생성되는 테이블:

```sql
CREATE TABLE vip_table (
    age INTEGER,
    id BIGINT NOT NULL AUTO_INCREMENT,
    display_name VARCHAR(2048) NOT NULL,
    primary_contact VARCHAR(255),
    PRIMARY KEY (id),
    UNIQUE KEY (display_name),
    INDEX idx_name (display_name, age),
    INDEX idx_email (primary_contact)
) ENGINE=InnoDB;
```

---

### 3.4.4 JPA Auditing (리스너) - 자동 시간 기록

#### 개념

**리스너(Listener)**는 특정 **이벤트(Event)**가 발생하면 미리 정의된 **액션(Action)**을 자동으로 수행하는 메커니즘입니다.

**엔티티의 생명주기 이벤트**:

| 이벤트 | 시점 | 예시 |
|-------|------|------|
| **Persist** | 객체가 처음 저장될 때 | `save()` 호출 |
| **Update** | 객체가 변경될 때 | `save()` 재호출 |
| **Remove** | 객체가 삭제될 때 | `delete()` 호출 |

**JPA Auditing**: `Persist`와 `Update` 이벤트에 반응하여 **생성 시간, 수정 시간을 자동 기록**

---

#### 단계 1: Auditing 활성화 (메인 애플리케이션)

```java
package com.example.jpaHibernateSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing
public class JpaHibernateSampleApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(JpaHibernateSampleApplication.class, args);
    }
}
```

**`@EnableJpaAuditing`의 역할**: 스프링에게 "엔티티 생명주기 이벤트를 감시하겠다"는 선언

---

#### 단계 2: 엔티티에 리스너 부착

```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
import java.time.LocalDateTime;

@Entity
@EntityListeners(AuditingEntityListener.class)
public class Article {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
    
    @CreatedDate
    private LocalDateTime created;
    
    @LastModifiedDate
    private LocalDateTime updated;
}
```

| 어노테이션 | 역할 |
|-----------|------|
| **`@EntityListeners`** | "이 엔티티의 생명주기 이벤트를 `AuditingEntityListener`에게 전달하라" |
| **`@CreatedDate`** | Persist 이벤트 시 **현재 시각**을 자동 기록 (이후 변경 안 함) |
| **`@LastModifiedDate`** | Persist 이벤트와 Update 이벤트 시 **현재 시각**을 자동 기록 (매번 갱신) |

---

#### Auditing 동작 원리

```
1. @EnableJpaAuditing 활성화
   ↓
2. @EntityListeners(AuditingEntityListener.class) 감시 시작
   ↓
3. articleRepository.save(newArticle) 호출 (Persist 이벤트)
   ↓
4. AuditingEntityListener가 이벤트 감지
   ↓
5. @CreatedDate 필드에 현재 시각 주입
5. @LastModifiedDate 필드에 현재 시각 주입
   ↓
6. INSERT SQL 실행 (시간 정보 포함)
   ↓
7. 나중에 article.setTitle("변경") 후 save() 호출 (Update 이벤트)
   ↓
8. @LastModifiedDate만 갱신, @CreatedDate는 유지
   ↓
9. UPDATE SQL 실행
```

**예시**:

```java
Article article = Article.builder()
                         .title("첫 글")
                         .content("내용")
                         .build();

articleRepository.save(article);
// created: 2025-01-15 10:30:45
// updated: 2025-01-15 10:30:45

// 일주일 후...
article.setTitle("제목 수정");
articleRepository.save(article);
// created: 2025-01-15 10:30:45 (변경 안 됨)
// updated: 2025-01-22 14:15:20 (갱신됨)
```

---

### 3.4.5 Repository 인터페이스

#### MemberRepository

```java
package com.example.jpaHibernateSample.repository;

import com.example.jpaHibernateSample.Member;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    // 기본 CRUD 메서드는 JpaRepository가 제공
    // 필요에 따라 커스텀 메서드 추가
}
```

#### Spring Data JPA가 제공하는 기본 메서드

| 메서드 | 반환 타입 | 역할 |
|-------|---------|------|
| `save(entity)` | `T` | INSERT 또는 UPDATE |
| `findById(id)` | `Optional<T>` | ID로 조회 |
| `findAll()` | `List<T>` | 전체 조회 |
| `existsById(id)` | `boolean` | 존재 여부 확인 |
| `count()` | `long` | 전체 개수 |
| `deleteById(id)` | `void` | ID로 삭제 |
| `delete(entity)` | `void` | 엔티티 삭제 |
| `deleteAll()` | `void` | 전체 삭제 |

**코드 작성 없이 모두 자동 구현!**

---

#### MySQL vs H2 - 코드 변경 필요 없음!

**H2 사용 시**:
```gradle
runtimeOnly 'com.h2database:h2'
```

```properties
# spring.datasource.url 설정 불필요 (자동 생성)
# 자동으로 메모리 DB 사용
spring.jpa.hibernate.ddl-auto=create-drop
```

**MySQL 사용 시**:
```gradle
runtimeOnly 'com.mysql:mysql-connector-j'
```

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
spring.jpa.hibernate.ddl-auto=create
```

**중요**: 설정 파일과 의존성만 변경하면 된다! **엔티티 코드는 그대로!**

---

### 3.4.6 기본 애플리케이션 실행

```java
package com.example.jpaHibernateSample;

import com.example.jpaHibernateSample.repository.MemberRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class JpaApplication implements ApplicationRunner {
    
    private final MemberRepository memberRepository;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        memberRepository.save(
            Member.builder()
                  .name("hyechang")
                  .email("hyechang@spring.ac.kr")
                  .age(20)
                  .build()
        );
        
        memberRepository.save(
            Member.builder()
                  .name("woohyun")
                  .email("woohyun@spring.ac.kr")
                  .age(25)
                  .build()
        );
    }
}
```

**결과** (DBeaver에서 확인):
```
id | display_name | primary_contact          | age
1  | hyechang     | hyechang@spring.ac.kr    | 20
2  | woohyun      | woohyun@spring.ac.kr     | 25
```

**핵심**: **SQL을 한 줄도 작성하지 않았는데 데이터가 저장됨!** 이것이 JPA의 가장 큰 장점입니다.

---

### 3.4.7 쿼리 메서드 (Query Method)

Spring Data JPA는 **메서드 이름을 분석**하여 자동으로 JPQL을 생성하고 실행합니다. (Spring Data JDBC와 규칙이 동일합니다)

#### 기본 규칙

| 패턴 | 예시 | 생성되는 JPQL |
|-----|------|-------------|
| `findBy<필드>` | `findByName(String name)` | `select m from Member m where m.name = :name` |
| `findBy<필드>And<필드>` | `findByNameAndAge(String name, int age)` | `where m.name = :name and m.age = :age` |
| `findBy<필드>Or<필드>` | `findByNameOrEmail(String name, String email)` | `where m.name = :name or m.email = :email` |
| `findBy<필드>GreaterThan` | `findByAgeGreaterThan(int age)` | `where m.age > :age` |
| `findBy<필드>LessThan` | `findByAgeLessThan(int age)` | `where m.age < :age` |
| `findBy<필드>Between` | `findByAgeBetween(int min, int max)` | `where m.age between :min and :max` |
| `findBy<필드>Containing` | `findByNameContaining(String part)` | `where m.name like %:part%` |
| `findBy<필드>StartingWith` | `findByNameStartingWith(String prefix)` | `where m.name like :prefix%` |
| `findBy<필드>IsNull` | `findByEmailIsNull()` | `where m.email is null` |
| `findBy<필드>OrderBy<필드>Asc` | `findByAgeGreaterThanOrderByNameAsc(int age)` | `where m.age > :age order by m.name asc` |

#### MemberRepository 예시

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    List<Member> findByName(String name);
    
    List<Member> findByNameAndAge(String name, int age);
    
    List<Member> findByAgeGreaterThan(int age);
    
    List<Member> findByNameContaining(String name);
    
    List<Member> findByAgeBetween(int min, int max);
    
    Member findFirstByOrderByIdDesc();
}
```

---

### 3.4.8 정렬 (Sort)

#### 문제: 메서드 이름에 정렬 조건을 하드코딩?

```java
// 이런 식으로 만들어야 하나?
List<Member> findByAgeGreaterThanOrderByNameAsc(int age);
List<Member> findByAgeGreaterThanOrderByNameDesc(int age);
List<Member> findByAgeGreaterThanOrderByAgeAsc(int age);
// ... 모든 조합을 만들어야 함 ❌
```

#### 해결: Sort 객체로 동적 정렬

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    List<Member> findByAgeGreaterThan(int age, Sort sort);
    
    List<Member> findByNameContaining(String name, Sort sort);
}
```

#### Sort 객체 생성 및 사용

**방법 1: Sort.Order 배열 (다중 정렬 기준, 명시적)**

```java
Sort sort = Sort.by(
    Sort.Order.asc("name"),   // 1차: name 오름차순
    Sort.Order.desc("age")    // 2차: age 내림차순
);

List<Member> members = memberRepository.findByAgeGreaterThan(20, sort);
```

**방법 2: Sort.Direction과 properties (단일 방향)**

```java
Sort sort = Sort.by(
    Sort.Direction.DESC,  // 모든 필드를 내림차순으로
    "age", "name"         // age → name 순서로 정렬
);

List<Member> members = memberRepository.findByNameContaining("hyechang", sort);
```

**Sort 생성 요약**:
```java
// 정적 팩토리 메서드 Sort.by()를 사용
Sort sort = Sort.by(Sort.Order... orders);

// Sort.Order 생성
Sort.Order.asc("fieldName");    // 오름차순
Sort.Order.desc("fieldName");   // 내림차순
```

---

### 3.4.9 페이지네이션 (Pageable)

#### 문제: 전체 데이터를 한 번에 조회?

클라이언트 앱에서 수백만 개의 데이터를 한 번에 보여줄 수는 없습니다. **페이지 단위**로 나누어 전달하는 것이 효율적입니다.

#### 해결: Pageable 객체

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    Page<Member> findByNameContaining(String name, Pageable pageable);
}
```

#### Pageable 객체 생성

```java
// PageRequest.of(페이지번호, 페이지크기, 정렬정보)
Pageable pageable = PageRequest.of(0, 20, Sort.by(Sort.Direction.DESC, "id"));

Page<Member> page = memberRepository.findByNameContaining("hyechang", pageable);
```

#### Page 객체가 제공하는 정보

```java
page.getContent();          // List<Member> - 현재 페이지의 실제 데이터
page.getTotalElements();    // long - 조건을 만족하는 전체 데이터 개수
page.getTotalPages();       // int - 전체 페이지 수
page.getNumber();           // int - 현재 페이지 번호 (0부터 시작)
page.getSize();             // int - 페이지당 데이터 개수
page.hasNext();             // boolean - 다음 페이지 존재 여부
page.hasPrevious();         // boolean - 이전 페이지 존재 여부
page.isFirst();             // boolean - 첫 페이지인지 여부
page.isLast();              // boolean - 마지막 페이지인지 여부
```

**사용 예시**:

```java
Pageable pageable = PageRequest.of(0, 10);  // 첫 번째 페이지, 10개 항목
Page<Member> page = memberRepository.findAll(pageable);

System.out.println("전체 데이터: " + page.getTotalElements());
System.out.println("전체 페이지: " + page.getTotalPages());
System.out.println("현재 페이지: " + page.getNumber());
System.out.println("데이터 개수: " + page.getContent().size());

page.getContent().forEach(member -> System.out.println(member));
```

---

### 3.4.10 동적 쿼리 (Example)

#### 문제: 모든 검색 조건 조합의 메서드 필요?

```java
// 이름만 검색
List<Member> findByName(String name);

// 나이만 검색
List<Member> findByAge(int age);

// 이름과 나이
List<Member> findByNameAndAge(String name, int age);

// 이름, 나이, 이메일
List<Member> findByNameAndAgeAndEmail(String name, int age, String email);

// ... 모든 조합을 작성해야 함 ❌
```

#### 해결: Example 객체 (동적 조건)

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    // Example을 받는 기본 메서드는 JpaRepository가 제공함
    <S extends Member> List<S> findAll(Example<Member> example);
}
```

#### Example 사용 방법

```java
// 1단계: 검색 조건이 담긴 엔티티 객체 생성 (probe)
Member probe = Member.builder()
                     .name("hyechang")
                     .age(20)
                     .build();

// 2단계: 매칭 방식 정의
ExampleMatcher matcher = ExampleMatcher.matchingAll();  // AND 조건

// 3단계: Example 생성
Example<Member> example = Example.of(probe, matcher);

// 4단계: 쿼리 실행
List<Member> results = memberRepository.findAll(example);
```

#### ExampleMatcher 옵션

| 메서드 | 조건 | 설명 |
|-------|------|------|
| `matchingAll()` | AND | probe의 모든 필드가 일치해야 함 (기본값) |
| `matchingAny()` | OR | probe의 필드 중 하나라도 일치하면 됨 |

**예시**:

```java
// AND 조건: name이 "hyechang" AND age가 20
Member probe = Member.builder().name("hyechang").age(20).build();
ExampleMatcher matcher = ExampleMatcher.matchingAll();
List<Member> results = memberRepository.findAll(Example.of(probe, matcher));

// OR 조건: name이 "hyechang" OR age가 20
ExampleMatcher matcher = ExampleMatcher.matchingAny();
List<Member> results = memberRepository.findAll(Example.of(probe, matcher));
```

#### Example의 한계

**지원하지 않는 기능**:
- 크기 비교 (`>`, `<`, `>=`, `<=`)
- LIKE 패턴 (기본 LIKE는 지원, 상세한 패턴 설정은 제한적)

**복잡한 조건이 필요하면 JPQL 사용**

---

### 3.4.11 JPQL (Java Persistence Query Language) - 가장 중요!

#### JPQL이란?

**JPQL**은 SQL과 유사하지만, **데이터베이스 테이블이 아닌 Java 엔티티 객체를 대상**으로 작성하는 쿼리 언어입니다.

| 항목 | SQL | JPQL |
|-----|-----|------|
| **대상** | 테이블, 컬럼 | 엔티티 클래스, 필드 |
| **쿼리 예** | `SELECT * FROM member WHERE name = ?` | `SELECT m FROM Member m WHERE m.name = :name` |
| **DB 의존성** | 높음 (DB 방언이 다르면 수정 필요) | 낮음 (JPQL은 동일, Hibernate가 DB별 SQL로 변환) |

**핵심**: 테이블을 생각하지 말고 **엔티티 객체**를 생각해야 합니다!

---

#### JPQL 문법 기본 규칙

##### 1. 엔티티 이름과 별칭

```java
// ✅ 올바른 방식
@Query("SELECT m FROM Member m WHERE m.name = :name")
Member findByName(@Param("name") String name);

// ❌ 잘못된 방식 (테이블 이름 사용)
@Query("SELECT * FROM member WHERE name = :name")

// ❌ 잘못된 방식 (별칭 없음)
@Query("SELECT Member FROM Member WHERE Member.name = :name")
```

**규칙**:
- 엔티티 이름은 **대소문자 구분** (`Member` ≠ `member`)
- **반드시 별칭 사용** (예: `Member m`) - AS는 생략 가능 (`Member as m`)

##### 2. 필드 참조

```java
@Query("SELECT m.name, m.email FROM Member m")  // 필드 사용
@Query("SELECT m FROM Member m")                 // 엔티티 전체 사용
```

---

#### JPQL 반환 타입 규칙 (가장 헷갈리는 부분!)

JPQL의 SELECT 절에 **무엇을 선택하느냐**에 따라 반환 타입이 결정됩니다.

##### 패턴 1: 엔티티 전체 반환

```java
@Query("SELECT m FROM Member m WHERE m.id = :id")
Member findByIdJpql(@Param("id") Long id);

@Query("SELECT m FROM Member m")
List<Member> findAllJpql();
```

**동작**:
```
SELECT m    → Member 엔티티 전체 선택
결과: Member 객체 또는 List<Member>
```

---

##### 패턴 2: 필드 목록 반환 (Object[] 배열)

```java
@Query("SELECT m.name, m.email, m.age FROM Member m")
List<Object[]> findMemberInfo();
```

**동작**:
```
SELECT m.name, m.email, m.age
       ↓       ↓        ↓
     [0]     [1]     [2]

결과: List<Object[]>
각 요소: Object[] = {이름, 이메일, 나이}

사용:
List<Object[]> results = findMemberInfo();
for (Object[] row : results) {
    String name = (String) row[0];
    String email = (String) row[1];
    int age = (int) row[2];
}
```

---

##### 패턴 3: DTO 객체로 직접 변환 (NEW 연산자)

```java
// DTO 클래스 정의 (반드시 생성자 필요)
public class MemberDto {
    public MemberDto(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
}

// JPQL - NEW 연산자 사용
@Query("SELECT new com.example.jpaHibernateSample.MemberDto(m.name, m.email, m.age) FROM Member m")
List<MemberDto> findMemberDtos();
```

**규칙**:
- DTO 클래스는 **생성자의 파라미터 순서**와 **JPQL SELECT 항목 순서**가 정확히 일치해야 함
- 패키지명.클래스명 **전체 경로** 사용

**사용**:
```java
List<MemberDto> results = findMemberDtos();
for (MemberDto dto : results) {
    System.out.println(dto.getName());
    System.out.println(dto.getEmail());
}
```

---

#### JPQL 파라미터 바인딩

```java
// `:이름` 방식 (권장)
@Query("SELECT m FROM Member m WHERE m.name = :name AND m.age = :age")
List<Member> findByNameAndAge(@Param("name") String name, @Param("age") int age);

// `?1, ?2` 위치 방식 (비권장)
@Query("SELECT m FROM Member m WHERE m.name = ?1 AND m.age = ?2")
List<Member> findByNameAndAgePos(String name, int age);
```

**권장 이유**: `:name` 방식이 가독성이 좋고 유지보수가 용이합니다.

---

#### 복잡한 JPQL 분석 (LEFT JOIN, GROUP BY)

```java
@Query("SELECT m.name, m.email, COUNT(a.id) as articleCount " +
       "FROM Member m " +
       "LEFT JOIN Article a ON a.member = m " +
       "GROUP BY m " +
       "ORDER BY articleCount DESC")
List<Object[]> getMembersWithArticleCount();
```

**상세 분석**:

| 부분 | 설명 |
|-----|------|
| **`LEFT JOIN Article a ON a.member = m`** | Member 엔티티(m)를 기준으로 Article 엔티티(a)와 LEFT JOIN. 조건: Article의 member 필드가 현재 Member를 가리킴 |
| **`GROUP BY m`** | Member의 모든 필드(기본키 포함)를 기준으로 그룹화. (SQL의 `GROUP BY m.id`와 동일 의미) |
| **`COUNT(a.id)`** | 각 그룹의 Article 개수를 집계함수로 계산 |
| **`ORDER BY articleCount DESC`** | 게시글 많은 순서대로 내림차순 정렬 |

**반환 데이터 구조**:
```
Object[0] = "hyechang"      (m.name)
Object[1] = "hyechang@..."  (m.email)
Object[2] = 5               (COUNT(a.id) = 게시글 5개)

List<Object[]> = [
    {"hyechang", "hyechang@...", 5},
    {"woohyun", "woohyun@...", 3},
    {"other", "other@...", 1}
]

사용:
for (Object[] row : getMembersWithArticleCount()) {
    String name = (String) row[0];
    String email = (String) row[1];
    long count = (long) row[2];
}
```

---

#### SELECT 절의 규칙 (GROUP BY 사용 시)

JPQL도 SQL과 동일한 규칙을 따릅니다:

**SELECT에 올 수 있는 항목**:
- GROUP BY 기준이 되는 필드: `m.name`, `m.email` (그룹 기준이므로 그대로 사용 가능)
- 집계함수: `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()` (필수 사용)

**SELECT에 올 수 없는 항목**:
- GROUP BY 기준이 아닌 필드 (예: `a.id` - 집계함수 없이 사용 불가)

---

### 3.4.12 JPQL을 통한 데이터 변경 (UPDATE, DELETE)

#### UPDATE

```java
@Modifying
@Transactional
@Query("UPDATE Member m SET m.age = :age WHERE m.id = :id")
int updateMemberAge(@Param("age") int age, @Param("id") Long id);
```

| 어노테이션 | 역할 |
|-----------|------|
| **`@Modifying`** | 이 쿼리가 SELECT가 아닌 데이터 변경 쿼리(UPDATE/DELETE)임을 선언 |
| **`@Transactional`** | 데이터 변경은 트랜잭션 내에서 실행되어야 하므로 필수 |

**속성** (간단히 알기):
- `clearAutomatically = true`: 쿼리 실행 후 영속성 컨텍스트 초기화
- `flushAutomatically = true`: 쿼리 실행 전 영속성 컨텍스트 동기화

---

#### DELETE

```java
@Modifying
@Transactional
@Query("DELETE FROM Member m WHERE m.age < :age")
int deleteYoungMembers(@Param("age") int age);
```

**반환값**: 영향받은 행의 개수 (int)

```java
int deleted = deleteYoungMembers(18);
System.out.println("삭제된 회원: " + deleted + "명");
```

---

### 3.4.13 Native SQL (네이티브 쿼리)

#### 필요한 경우

JPQL로는 표현 불가능한 데이터베이스 특화 기능이 필요할 때:
- MySQL의 `RAND()`, `GROUP_CONCAT()`
- Oracle의 `ROWNUM`
- 복잡한 윈도우 함수
- 성능 최적화된 특화 SQL

#### 사용 방법

```java
@Query(
    value = "SELECT * FROM member ORDER BY RAND() LIMIT :limit",
    nativeQuery = true
)
List<Member> findRandomMembers(@Param("limit") int limit);
```

| 속성 | 값 | 의미 |
|-----|-----|------|
| **`value`** | SQL 문자열 | 테이블명, 컬럼명 사용 (엔티티 아님) |
| **`nativeQuery`** | `true` | 이 쿼리를 JPQL이 아닌 **네이티브 SQL**로 처리 |

---

#### Native SQL과 JPQL 비교

| 항목 | JPQL | Native SQL |
|-----|------|-----------|
| **대상** | 엔티티, 필드 | 테이블, 컬럼 |
| **쿼리 예** | `SELECT m FROM Member m` | `SELECT * FROM member` |
| **DB 의존성** | 낮음 | 높음 (DB 방언에 따라 수정 필요) |
| **가독성** | 높음 | 낮음 |
| **성능 최적화** | 제한적 | 강력 |
| **특화 기능** | 불가능 | 가능 |

**권장사항**:
- 대부분의 쿼리는 **JPQL 사용**
- 성능이 중요하거나 DB 특화 기능 필요 시만 **Native SQL 사용**

---

### 3.4.14 완전한 Repository 예시

```java
package com.example.jpaHibernateSample.repository;

import com.example.jpaHibernateSample.Member;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    // 1. 쿼리 메서드
    List<Member> findByName(String name);
    
    List<Member> findByNameAndAge(String name, int age);
    
    List<Member> findByAgeGreaterThan(int age);
    
    List<Member> findByNameContaining(String namePart);
    
    // 2. 정렬 사용
    List<Member> findByAgeGreaterThan(int age, org.springframework.data.domain.Sort sort);
    
    // 3. 페이지네이션
    Page<Member> findByNameContaining(String namePart, Pageable pageable);
    
    // 4. JPQL - 조회
    @Query("SELECT m FROM Member m WHERE m.name = :name")
    Optional<Member> findByNameJpql(@Param("name") String name);
    
    // 5. JPQL - 복잡한 쿼리
    @Query("SELECT m.name, COUNT(m.id) FROM Member m GROUP BY m.name")
    List<Object[]> countMembersByName();
    
    // 6. JPQL - UPDATE
    @Modifying
    @Transactional
    @Query("UPDATE Member m SET m.age = :age WHERE m.id = :id")
    int updateAge(@Param("age") int age, @Param("id") Long id);
    
    // 7. Native SQL
    @Query(value = "SELECT * FROM vip_table WHERE age > :age", nativeQuery = true)
    List<Member> findOlderMembers(@Param("age") int age);
}
```

---

### 3.4.15 쿼리 메서드 vs JPQL vs Native SQL 선택 기준

| 상황 | 추천 방법 | 이유 |
|-----|---------|------|
| 단순한 CRUD (findBy, save, delete) | 쿼리 메서드 | 코드 작성 불필요, 가독성 좋음 |
| 단순한 검색 조건 조합 | 쿼리 메서드 | 메서드 이름으로 충분 |
| 복잡한 조건 (JOIN, GROUP BY, 집계) | JPQL | DB 의존성 낮음, 객체 중심 |
| 성능 최적화 필요 | Native SQL | 세밀한 제어 가능 |
| DB 특화 함수 필요 | Native SQL | 불가피한 선택 |

---

### 3.4.16 요약: JPA의 핵심 개념

| 개념 | 설명 |
|-----|------|
| **@Entity** | 엔티티 클래스 선언, DDL 자동 생성 |
| **@Table** | 테이블 매핑, 이름, 인덱스 정의 |
| **@Column** | 컬럼 매핑, 제약조건 정의 |
| **@Id + @GeneratedValue** | 기본 키 자동 생성 |
| **@Transient** | DB 매핑 제외 |
| **JpaRepository** | 기본 CRUD 자동 제공 |
| **쿼리 메서드** | 메서드 이름 기반 쿼리 자동 생성 |
| **Sort + Pageable** | 동적 정렬, 페이지네이션 |
| **@Query + JPQL** | 복잡한 쿼리, 객체 중심 |
| **Native SQL** | DB 특화 SQL, 성능 최적화 |
| **@EnableJpaAuditing** | 자동 시간 기록 (생성, 수정) |

---

