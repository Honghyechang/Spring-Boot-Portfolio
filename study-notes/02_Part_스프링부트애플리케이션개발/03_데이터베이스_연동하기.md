# 03_데이터베이스_연동하기

<!--
# 첫 작성 (3.1 JDBC)
docs: [Ch03] 데이터베이스 연동 - JDBC 추가

# 다음 업데이트 (3.2, 3.3 추가)
docs: [Ch03] 데이터베이스 연동 - Spring Data JDBC, MyBatis 추가

# 마지막 완료 (3.4, 3.5 추가)
docs: [Ch03] 데이터베이스 연동 - JPA, MongoDB 추가 및 완료

-->

## 📌 학습 목표
스프링부트에서 데이터베이스에 접근하는 다양한 방법을 이해하고, 각 방식의 특징과 사용법을 익힌다.

---

## 목차

- [3.1 JDBC](#31-jdbc)
- [3.2 Spring Data JDBC](#32-spring-data-jdbc) 
- [3.3 MyBatis](#33-mybatis) 
- [3.4 JPA](#34-jpa) 
- [3.5 MongoDB](#35-mongodb) 

---

## 3.1 JDBC

### 3.1.1 JDBC란?

**JDBC (Java Database Connectivity)** 는 Java 애플리케이션에서 데이터베이스에 접근하기 위한 **표준 API**입니다.

#### JDBC의 구성 요소

```
[Java 애플리케이션]
      ↓
[JDBC API] ← Java가 제공하는 표준 인터페이스
      ↓
[JDBC Driver] ← 각 DB 벤더가 제공하는 구현체
      ↓
[데이터베이스 (MySQL, Oracle, PostgreSQL 등)]
```

| 구성 요소 | 제공자 | 역할 |
|----------|-------|------|
| **JDBC API** | Java (Oracle) | 데이터베이스 접근을 위한 표준 인터페이스 정의 |
| **JDBC Driver** | 각 DB 벤더 (MySQL, Oracle 등) | JDBC API의 실제 구현체 |
| **데이터베이스** | DB 벤더 | 실제 데이터 저장 및 관리 |

#### JDBC Driver의 역할

**JDBC Driver**는 Java 애플리케이션과 특정 데이터베이스 간의 **통신을 담당하는 브리지(다리)** 역할을 합니다.

- MySQL JDBC Driver: `mysql-connector-j`
- PostgreSQL JDBC Driver: `postgresql`
- Oracle JDBC Driver: `ojdbc`

**비유**:
```
JDBC API = USB 규격 (표준 인터페이스)
JDBC Driver = USB 케이블 (제조사별 구현)
데이터베이스 = USB 장치
```

#### 왜 JDBC가 필요한가?

**문제 상황**:
- 데이터베이스마다 통신 방식이 다름
- MySQL, Oracle, PostgreSQL 등 각각 다른 방식으로 접근

**JDBC의 해결**:
- **표준화된 인터페이스 제공**
- 개발자는 JDBC API만 사용
- 데이터베이스 변경 시 Driver만 교체하면 됨

```java
// MySQL이든 Oracle이든 코드는 동일!
Connection conn = DriverManager.getConnection(url, user, password);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM member");
```

---

### 3.1.2 데이터베이스 초기 설정

#### DBeaver를 통한 데이터 초기화

**실습 환경**:
- 데이터베이스: MySQL 8.4
- 관리 도구: DBeaver Community 25.2.2
- 데이터베이스명: `mydb`
- 사용자: `myuser` / 비밀번호: `mypass`

#### SQL 스크립트

```sql
-- ========================================
-- 1. 데이터베이스 생성
-- ========================================
-- mydb라는 이름의 데이터베이스 공간을 생성합니다.
-- IF NOT EXISTS: 이미 존재하면 생략 (에러 방지)
CREATE DATABASE IF NOT EXISTS mydb;

-- ========================================
-- 2. 사용자 생성 및 인증
-- ========================================
-- myuser 계정을 생성합니다.
-- @'%': 모든 호스트(IP)에서 접속 허용
-- IDENTIFIED BY 'mypass': 비밀번호를 mypass로 설정
CREATE USER IF NOT EXISTS 'myuser'@'%' IDENTIFIED BY 'mypass';

-- ========================================
-- 3. 권한 부여
-- ========================================
-- myuser가 mydb 데이터베이스의 모든 객체(테이블, 뷰 등)에 대해
-- 모든 권한(SELECT, INSERT, UPDATE, DELETE, CREATE, DROP 등)을 가지도록 설정
GRANT ALL ON mydb.* TO 'myuser'@'%';

-- ========================================
-- 4. 데이터베이스 선택
-- ========================================
USE mydb;

-- ========================================
-- 5. 테이블 생성
-- ========================================
CREATE TABLE IF NOT EXISTS member(
    id INTEGER AUTO_INCREMENT PRIMARY KEY,  -- 자동 증가 기본키
    name VARCHAR(128) NOT NULL,             -- 이름 (필수)
    email VARCHAR(256) NOT NULL,            -- 이메일 (필수)
    age INTEGER                             -- 나이 (선택)
);

-- ========================================
-- 6. 데이터 삽입
-- ========================================
INSERT INTO member(name, email, age) VALUES ('김우현', 'kimwoo@spring.co.kr', 10);
INSERT INTO member(name, email, age) VALUES ('홍혜창', 'hyechang@spring.co.kr', 20);
INSERT INTO member(name, email, age) VALUES ('윤서준', 'Seojunyoon@spring.co.kr', 22);
INSERT INTO member(name, email, age) VALUES ('김민수', 'minsusu@spring.co.kr', 30);

-- ========================================
-- 7. 데이터 조회 (확인)
-- ========================================
SELECT * FROM member;
```

#### SQL 명령어 설명

| 명령어 | 역할 | 설명 |
|-------|------|------|
| `CREATE DATABASE` | 데이터베이스 생성 | 데이터를 저장할 논리적 공간 생성 |
| `CREATE USER` | 사용자 계정 생성 | 데이터베이스 접속 계정 생성 |
| `GRANT` | 권한 부여 | 특정 사용자에게 DB 작업 권한 부여 |
| `USE` | 데이터베이스 선택 | 작업할 데이터베이스 지정 |
| `CREATE TABLE` | 테이블 생성 | 데이터를 저장할 테이블 구조 정의 |
| `INSERT INTO` | 데이터 삽입 | 테이블에 레코드 추가 |
| `SELECT` | 데이터 조회 | 테이블의 데이터 검색 |

#### 데이터 확인

```
+----+----------+-------------------------+------+
| id | name     | email                   | age  |
+----+----------+-------------------------+------+
|  1 | 김우현   | kimwoo@spring.co.kr     |   10 |
|  2 | 홍혜창   | hyechang@spring.co.kr   |   20 |
|  3 | 윤서준   | Seojunyoon@spring.co.kr |   22 |
|  4 | 김민수   | minsusu@spring.co.kr    |   30 |
+----+----------+-------------------------+------+
```

---

### 3.1.3 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    
    // MySQL JDBC Driver
    implementation 'com.mysql:mysql-connector-j:9.2.0'
    
    // Lombok (코드 자동 생성)
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 |
|-------|------|
| `spring-boot-starter` | 스프링부트 기본 기능 |
| `mysql-connector-j:9.2.0` | **MySQL JDBC Driver** (핵심!) |
| `lombok` | Getter, Setter 등 자동 생성 |

> ⚠️ **중요**: `mysql-connector-j`를 추가해야 MySQL과 통신할 수 있는 JDBC Driver가 프로젝트에 포함됩니다!

**JDBC Driver 포함 확인**:
```
프로젝트 구조
└─ External Libraries
   └─ com.mysql:mysql-connector-j:9.2.0
      └─ com.mysql.cj.jdbc.Driver ← JDBC Driver 클래스
```

---

### 3.1.4 엔티티 클래스 작성

**Member.java**:
```java
package kr.ac.hansung.cse.databasesample;

import lombok.*;

/**
 * Member 엔티티 클래스
 * - 데이터베이스의 member 테이블과 매핑되는 Java 객체
 * - Lombok을 사용하여 반복 코드 최소화
 */
@AllArgsConstructor  // 모든 필드를 매개변수로 받는 생성자 자동 생성
@ToString            // toString() 메서드 자동 생성
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### Lombok 애노테이션

| 애노테이션 | 생성 코드 |
|-----------|----------|
| `@AllArgsConstructor` | `public Member(Long id, String name, String email, Integer age) { ... }` |
| `@ToString` | `public String toString() { return "Member(id=1, name=김우현, ...)"; }` |

---

### 3.1.5 JDBC를 사용한 데이터베이스 연동

#### 전체 코드

**DatabaseSampleApplication.java**:
```java
package kr.ac.hansung.cse.databasesample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.sql.*;

@SpringBootApplication
public class DatabaseSampleApplication {

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        
        SpringApplication.run(DatabaseSampleApplication.class, args);

        // ========================================
        // 1. JDBC Driver 로딩
        // ========================================
        /*
         * Class.forName()의 역할:
         * - JDBC Driver 클래스를 JVM 메모리에 로드
         * - 로드된 Driver는 DriverManager에 자동 등록됨
         * - DriverManager가 MySQL 접속 방법을 알게 됨
         * 
         * "com.mysql.cj.jdbc.Driver":
         * - mysql-connector-j 라이브러리에 포함된 MySQL JDBC Driver 클래스
         * - 이 클래스가 JDBC API를 실제로 구현함
         * 
         * 참고: JDBC 4.0 이후로는 자동 로딩되지만, 명시적 표현을 위해 작성
         */
        Class.forName("com.mysql.cj.jdbc.Driver");

        // ========================================
        // 2. 데이터베이스 연결
        // ========================================
        /*
         * DriverManager.getConnection()의 역할:
         * - 실제 데이터베이스와의 연결(Connection) 객체 생성
         * 
         * 첫 번째 매개변수 (JDBC URL):
         * "jdbc:mysql://localhost:3306/mydb"
         *  ──── ───── ───────── ──── ────
         *   │     │       │       │     └─ 데이터베이스 이름
         *   │     │       │       └─ 포트 번호 (MySQL 기본: 3306)
         *   │     │       └─ 서버 주소 (localhost = 내 컴퓨터)
         *   │     └─ 데이터베이스 종류 (MySQL)
         *   └─ JDBC 프로토콜
         * 
         * 두 번째 매개변수: 사용자 이름 (myuser)
         * 세 번째 매개변수: 비밀번호 (mypass)
         */
        Connection connection = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/mydb",
            "myuser",
            "mypass"
        );

        // ========================================
        // 3. SQL 쿼리 준비
        // ========================================
        /*
         * PreparedStatement의 역할:
         * - SQL 쿼리를 데이터베이스에 미리 전송
         * - 실행 가능한 상태로 준비 (컴파일)
         * - SQL Injection 방지 (매개변수 바인딩 시)
         * 
         * "select * from member":
         * - member 테이블의 모든 컬럼(*), 모든 행 조회
         */
        PreparedStatement preparedStatement = connection.prepareStatement(
            "select * from member"
        );

        // ========================================
        // 4. 쿼리 실행
        // ========================================
        /*
         * executeQuery()의 역할:
         * - SELECT 쿼리 실행 (데이터 조회)
         * - 결과를 ResultSet 객체로 반환
         * 
         * ResultSet:
         * - 쿼리 결과를 담고 있는 객체
         * - 커서(cursor)를 사용하여 한 행씩 접근
         */
        ResultSet resultSet = preparedStatement.executeQuery();

        // ========================================
        // 5. 결과 처리
        // ========================================
        /*
         * while (resultSet.next()):
         * - 다음 행으로 커서 이동
         * - 더 이상 행이 없으면 false 반환 (반복 종료)
         * 
         * resultSet.getLong("id"):
         * - 현재 행의 "id" 컬럼 값을 Long 타입으로 가져옴
         * 
         * resultSet.getString("name"):
         * - 현재 행의 "name" 컬럼 값을 String 타입으로 가져옴
         * 
         * resultSet.getInt("age"):
         * - 현재 행의 "age" 컬럼 값을 Integer 타입으로 가져옴
         */
        while (resultSet.next()) {
            Member member = new Member(
                resultSet.getLong("id"),
                resultSet.getString("name"),
                resultSet.getString("email"),
                resultSet.getInt("age")
            );
            System.out.println(member);
        }

        // ========================================
        // 6. 연결 종료
        // ========================================
        /*
         * connection.close()의 역할:
         * - 데이터베이스 연결 해제
         * - 리소스(메모리, 네트워크) 반환
         * - 반드시 호출해야 함 (리소스 누수 방지)
         * 
         * 권장: try-with-resources 사용
         */
        connection.close();
    }
}
```

#### 실행 결과

```
Member(id=1, name=김우현, email=kimwoo@spring.co.kr, age=10)
Member(id=2, name=홍혜창, email=hyechang@spring.co.kr, age=20)
Member(id=3, name=윤서준, email=Seojunyoon@spring.co.kr, age=22)
Member(id=4, name=김민수, email=minsusu@spring.co.kr, age=30)
```

---

### 3.1.6 JDBC 동작 과정 상세 분석

#### 1단계: Driver 로딩

```java
Class.forName("com.mysql.cj.jdbc.Driver");
```

**내부 동작**:
```
1. JVM이 "com.mysql.cj.jdbc.Driver" 클래스 파일 로드
2. Driver 클래스의 static 초기화 블록 실행
3. Driver 객체가 DriverManager에 자동 등록
4. DriverManager: "MySQL과 통신하는 방법을 알게 되었다!"
```


#### 2단계: Connection 생성

```java
Connection connection = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "myuser",
    "mypass"
);
```

**내부 동작**:
```
1. DriverManager가 등록된 Driver들을 순회
2. URL이 "jdbc:mysql"로 시작 → MySQL Driver 선택
3. MySQL Driver가 실제 연결 시도
   - TCP 소켓 연결 (localhost:3306)
   - 인증 확인 (myuser/mypass)
   - mydb 데이터베이스 선택
4. Connection 객체 반환
```

**Connection 객체의 역할**:
- 데이터베이스와의 **세션(Session)** 을 나타냄
- 이 연결을 통해 SQL을 실행하고 결과를 받음

#### 3단계: Statement 생성 및 실행

```java
PreparedStatement preparedStatement = connection.prepareStatement(
    "select * from member"
);
ResultSet resultSet = preparedStatement.executeQuery();
```

**내부 동작**:
```
1. SQL 문자열을 MySQL 서버로 전송
2. MySQL이 SQL을 파싱(분석)하고 실행 계획 수립
3. 쿼리 실행
4. 결과를 ResultSet으로 반환
   (네트워크를 통해 Java 애플리케이션으로 전송)
```

#### 4단계: 결과 처리

```java
while (resultSet.next()) {
    // 데이터 읽기
}
```

**ResultSet의 구조**:
```
커서 위치 (처음에는 첫 행 이전)
    ↓
[Before First] ← resultSet.next() 호출 전
[Row 1] id=1, name=김우현, ...  ← resultSet.next() → true
[Row 2] id=2, name=홍혜창, ...  ← resultSet.next() → true
[Row 3] id=3, name=윤서준, ...  ← resultSet.next() → true
[Row 4] id=4, name=김민수, ...  ← resultSet.next() → true
[After Last] ← resultSet.next() → false (반복 종료)
```

---

### 3.1.7 JDBC의 문제점

#### 문제 1: 반복적인 코드

```java
// 매번 작성해야 하는 코드
Connection conn = DriverManager.getConnection(...);
PreparedStatement stmt = conn.prepareStatement(...);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
    // 매핑 코드
}
conn.close();
```

#### 문제 2: 수동 매핑

```java
// 컬럼과 객체 필드를 수동으로 매핑
Member member = new Member(
    rs.getLong("id"),
    rs.getString("name"),
    rs.getString("email"),
    rs.getInt("age")
);
```

#### 문제 3: 리소스 관리

```java
// close()를 깜빡하면 리소스 누수!
connection.close();  // 반드시 호출해야 함
```

#### 문제 4: 예외 처리

```java
// 체크 예외(Checked Exception) 처리 필요
throws ClassNotFoundException, SQLException
```

**이러한 문제들을 해결하기 위해 등장한 것이:**
- Spring Data JDBC (3.2)
- MyBatis (3.3)
- JPA (3.4)

---


## 3.2 Spring Data JDBC

### 3.2.1 Spring Data JDBC란?

**Spring Data JDBC**는 JDBC의 반복적인 코드를 제거하고, 개발자가 **비즈니스 로직에만 집중**할 수 있도록 도와주는 추상화 레이어입니다.

#### JDBC의 문제점을 해결하는 방법

| 문제점 | JDBC | Spring Data JDBC |
|-------|------|-----------------|
| Driver 로딩 | `Class.forName()` 필요 | 자동 처리 |
| Connection 관리 | 매번 생성/종료 | **커넥션 풀** 자동 관리 |
| SQL 작성 | 직접 작성 | 메서드 이름으로 자동 생성 |
| 결과 매핑 | `ResultSet` 수동 매핑 | 객체 자동 매핑 |
| 예외 처리 | Checked Exception | Runtime Exception |
| 리소스 정리 | 수동 `close()` | 자동 정리 |

> ⚠️ **중요**: Spring Data JDBC는 JDBC Driver를 사용하지 않는 것이 아닙니다! MySQL Connector 같은 JDBC Driver를 **더 편리하게 사용**하도록 감싸주는 역할을 합니다.

#### Spring Data JDBC의 핵심 개념

```
[개발자]
    ↓ (Repository 인터페이스만 정의)
[Spring Data JDBC]
    ↓ (보일러플레이트 코드 자동 생성)
[JDBC Driver (mysql-connector-j)]
    ↓
[MySQL 데이터베이스]
```

**보일러플레이트 코드(Boilerplate Code)**: 반복적으로 작성해야 하는 지루한 코드

---

### 3.2.2 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    // Spring Data JDBC (핵심!)
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    
    // MySQL JDBC Driver (여전히 필요!)
    runtimeOnly 'com.mysql:mysql-connector-j'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 | 필수 여부 |
|-------|------|----------|
| `spring-boot-starter-data-jdbc` | Spring Data JDBC 기능 제공 | ✅ 필수 |
| `mysql-connector-j` | MySQL과 통신하는 JDBC Driver | ✅ 필수 |
| `lombok` | 코드 간소화 | 권장 |

> **핵심**: `spring-boot-starter-data-jdbc`는 JDBC를 대체하는 것이 아니라, JDBC를 더 쉽게 사용하도록 도와주는 도구입니다!

---

### 3.2.3 데이터베이스 연결 설정

#### application.properties

**src/main/resources/application.properties**:
```properties
spring.application.name=springdatajbc

# ========================================
# 데이터베이스 연결 설정 (DataSource)
# ========================================
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass

# ========================================
# JDBC 로그 레벨 설정 (디버깅용)
# ========================================
logging.level.org.springframework.jdbc=DEBUG
```

#### 설정 항목 설명

| 속성 | 설명 | 예시 값 |
|-----|------|---------|
| `spring.datasource.url` | 데이터베이스 연결 URL | `jdbc:mysql://localhost:3306/mydb` |
| `spring.datasource.username` | 데이터베이스 사용자 이름 | `myuser` |
| `spring.datasource.password` | 데이터베이스 비밀번호 | `mypass` |
| `logging.level.org.springframework.jdbc` | JDBC 실행 로그 레벨 | `DEBUG` (SQL 쿼리 확인용) |

#### JDBC vs Spring Data JDBC 설정 비교

**JDBC (이전)**:
```java
// 매번 코드로 작성
Class.forName("com.mysql.cj.jdbc.Driver");
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "myuser",
    "mypass"
);
```

**Spring Data JDBC (현재)**:
```properties
# 설정 파일에 한 번만 작성
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
```

> **장점**: 설정 파일만 수정하면 모든 코드에 자동 적용! 환경별(개발/운영) 설정 파일 분리 가능!

---

### 3.2.4 엔티티 클래스 작성

#### Member 엔티티

**Member.java**:
```java
package com.example.springdatajbc;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

@Table
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Member {
    
    @Id
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### 애노테이션 설명

##### @Table

**역할**: 이 클래스가 데이터베이스 테이블과 매핑됨을 선언

**자동 매핑 규칙**:
- 클래스 이름 → 테이블 이름 (카멜 케이스 → 스네이크 케이스)
- `Member` 클래스 → `member` 테이블
- `HyechangMember` 클래스 → `hyechang_member` 테이블

**명시적 지정**:
```java
@Table("custom_table_name")  // 테이블 이름이 규칙과 다를 때
public class Member { ... }
```

**테이블 매핑 과정**:
```
[Java 클래스]           [데이터베이스]
Member 클래스     →     member 테이블
├─ id (Long)      →     id (BIGINT)
├─ name (String)  →     name (VARCHAR)
├─ email (String) →     email (VARCHAR)
└─ age (Integer)  →     age (INT)
```

##### @Id

**역할**: Primary Key(기본 키) 필드 지정

```java
@Id
private Long id;
```

- Spring Data JDBC가 이 필드를 기준으로 레코드 식별
- `save()` 시 `id`가 `null`이면 INSERT, 값이 있으면 UPDATE
- 자동 생성(AUTO_INCREMENT)된 값을 자동으로 받아옴

##### @Column (선택 사항)

**역할**: 필드명과 컬럼명이 다를 때 매핑

```java
@Column("user_name")
private String name;  // name 필드 → user_name 컬럼
```

**기본 매핑 규칙**:
- 필드명과 컬럼명이 같으면 생략 가능
- 카멜 케이스 → 스네이크 케이스 자동 변환
- `userName` → `user_name`

##### Lombok 애노테이션

| 애노테이션 | 생성 코드 |
|-----------|----------|
| `@Data` | `@Getter` + `@Setter` + `@ToString` + `@EqualsAndHashCode` + `@RequiredArgsConstructor` |
| `@Builder` | 빌더 패턴 코드 생성 |
| `@AllArgsConstructor` | 모든 필드를 매개변수로 받는 생성자 |
| `@NoArgsConstructor` | 기본 생성자 (매개변수 없음) |

---

### 3.2.5 Repository 인터페이스 작성

#### MemberRepository 인터페이스

**MemberRepository.java**:
```java
package com.example.springdatajbc;

import org.springframework.data.jdbc.repository.query.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MemberRepository extends CrudRepository<Member, Long> {
    
    // 메서드 이름 기반 쿼리 (자동 생성)
    List<Member> findByName(String name);
    List<Member> findByEmail(String email);
    List<Member> findByNameContaining(String name);
    
    // 조건 결합
    List<Member> findByEmailAndName(String email, String name);
    List<Member> findByEmailOrName(String email, String name);
    
    // 비교 연산
    List<Member> findByAgeGreaterThan(int age);
    List<Member> findByAgeLessThan(int age);
    List<Member> findByAgeBetween(int min, int max);
    
    // 커스텀 쿼리 (직접 작성)
    @Query("SELECT * FROM member WHERE name = :username AND age >= :max")
    List<Member> hyechangQuery(String username, int max);
}
```

---

### 3.2.6 Repository 핵심 개념

#### 1. @Repository와 빈 생성

**@Repository의 정체**:
```java
@Repository
public interface MemberRepository extends CrudRepository<Member, Long> {
    // 인터페이스인데 어떻게 빈 객체가 되는가?
}
```

**@Repository = @Component의 특수한 형태**:

| 애노테이션 | 역할 | 계층 |
|-----------|------|------|
| `@Component` | 범용 스프링 빈 | - |
| `@Repository` | 데이터 접근 계층 | Persistence Layer |
| `@Service` | 비즈니스 로직 계층 | Service Layer |
| `@Controller` | 프레젠테이션 계층 | Presentation Layer |

> **핵심**: 모두 `@Component`이지만, **역할을 명확히 하기 위해** 세분화된 것입니다!

#### 2. 인터페이스가 빈 객체가 되는 원리 (프록시 패턴)

**문제**: 인터페이스는 객체를 만들 수 없는데?

**해결**: Spring이 **프록시 객체**를 자동 생성!

```
애플리케이션 시작 시:

1. Spring이 @Repository를 발견
2. MemberRepository 인터페이스 분석
3. 이 인터페이스를 구현하는 클래스를 런타임에 자동 생성 (프록시)
4. 프록시 객체를 빈으로 등록
5. 다른 곳에서 주입 시 프록시 객체 제공
```

**프록시 객체의 역할**:
```java
// Spring이 런타임에 자동으로 생성하는 코드 (개념적 표현)
public class MemberRepositoryImpl implements MemberRepository {
    
    @Override
    public <S extends Member> S save(S entity) {
        // entity.getId()가 null이면 INSERT
        // entity.getId()가 있으면 UPDATE
        // SQL 자동 생성 및 실행
    }
    
    @Override
    public Optional<Member> findById(Long id) {
        // SELECT * FROM member WHERE id = ? 실행
        // ResultSet → Member 객체 자동 매핑
    }
    
    // 기타 메서드들도 자동 구현...
}
```

#### 3. CrudRepository의 제네릭

```java
public interface MemberRepository extends CrudRepository<Member, Long>
                                                        ────────  ────
                                                        엔티티    PK 타입
```

**제네릭 의미**:
- `<Member, Long>`: "Member 엔티티를 다루며, Primary Key는 Long 타입"
- Spring이 이 정보를 바탕으로 SQL 자동 생성

#### 4. CrudRepository 기본 메서드

**자동으로 제공되는 메서드**:

| 메서드 | 설명 | 생성 SQL |
|-------|------|----------|
| `save(entity)` | 저장 또는 수정 | `INSERT` 또는 `UPDATE` |
| `findById(id)` | ID로 조회 | `SELECT * FROM member WHERE id = ?` |
| `findAll()` | 전체 조회 | `SELECT * FROM member` |
| `existsById(id)` | 존재 여부 확인 | `SELECT COUNT(*) FROM member WHERE id = ?` |
| `count()` | 전체 개수 | `SELECT COUNT(*) FROM member` |
| `deleteById(id)` | ID로 삭제 | `DELETE FROM member WHERE id = ?` |
| `delete(entity)` | 엔티티 삭제 | `DELETE FROM member WHERE id = ?` |
| `deleteAll()` | 전체 삭제 | `DELETE FROM member` |

**save()의 동작 원리**:
```java
Member member = new Member();
member.setName("홍혜창");
memberRepository.save(member);  // id가 null → INSERT

member.setAge(30);
memberRepository.save(member);  // id가 있음 → UPDATE
```

---

### 3.2.7 쿼리 메서드 (Query Method)

#### 메서드 이름 기반 쿼리 생성

Spring Data JDBC는 **메서드 이름을 분석**하여 자동으로 SQL을 생성합니다.

#### 기본 구조

```
find...By... + 조건필드 + 비교연산자
 │    │        │          │
 │    │        │          └─ GreaterThan, LessThan 등
 │    │        └─ Name, Email, Age 등 (엔티티 필드명)
 │    └─ 조건 시작
 └─ 조회 작업 (find, get, read 모두 동일)
```

#### 주요 키워드

##### 1. 필드 일치

```java
List<Member> findByName(String name);
// SQL: SELECT * FROM member WHERE name = ?

List<Member> findByEmail(String email);
// SQL: SELECT * FROM member WHERE email = ?
```

##### 2. 조건 결합 (AND, OR)

```java
// AND 조건 (모두 만족)
List<Member> findByEmailAndName(String email, String name);
// SQL: SELECT * FROM member WHERE email = ? AND name = ?

// OR 조건 (하나라도 만족)
List<Member> findByEmailOrName(String email, String name);
// SQL: SELECT * FROM member WHERE email = ? OR name = ?
```

##### 3. 문자열 검색

```java
// 포함 (LIKE '%...%')
List<Member> findByNameContaining(String name);
// SQL: SELECT * FROM member WHERE name LIKE %?%

// 시작 (LIKE '...%')
List<Member> findByNameStartingWith(String name);
// SQL: SELECT * FROM member WHERE name LIKE ?%

// 끝 (LIKE '%...')
List<Member> findByNameEndingWith(String name);
// SQL: SELECT * FROM member WHERE name LIKE %?
```

##### 4. 비교 연산

```java
// 보다 큼 (>)
List<Member> findByAgeGreaterThan(int age);
// SQL: SELECT * FROM member WHERE age > ?

// 보다 작음 (<)
List<Member> findByAgeLessThan(int age);
// SQL: SELECT * FROM member WHERE age < ?

// 이상 (>=)
List<Member> findByAgeGreaterThanEqual(int age);
// SQL: SELECT * FROM member WHERE age >= ?

// 이하 (<=)
List<Member> findByAgeLessThanEqual(int age);
// SQL: SELECT * FROM member WHERE age <= ?

// 범위 (BETWEEN)
List<Member> findByAgeBetween(int min, int max);
// SQL: SELECT * FROM member WHERE age BETWEEN ? AND ?
```

##### 5. NULL 체크

```java
// NULL인 경우
List<Member> findByEmailIsNull();
// SQL: SELECT * FROM member WHERE email IS NULL

// NULL이 아닌 경우
List<Member> findByEmailIsNotNull();
// SQL: SELECT * FROM member WHERE email IS NOT NULL
```

##### 6. 정렬 (OrderBy)

```java
// 오름차순
List<Member> findByNameOrderByAgeAsc(String name);
// SQL: SELECT * FROM member WHERE name = ? ORDER BY age ASC

// 내림차순
List<Member> findByNameOrderByAgeDesc(String name);
// SQL: SELECT * FROM member WHERE name = ? ORDER BY age DESC
```

##### 7. 개수 제한

```java
// 첫 번째 결과
Member findFirstByName(String name);
// SQL: SELECT * FROM member WHERE name = ? LIMIT 1

// 상위 N개
List<Member> findTop3ByOrderByAgeDesc();
// SQL: SELECT * FROM member ORDER BY age DESC LIMIT 3
```

#### 쿼리 메서드 키워드 정리표

| 키워드 | SQL | 예시 |
|-------|-----|------|
| `And` | `AND` | `findByNameAndEmail` |
| `Or` | `OR` | `findByNameOrEmail` |
| `Containing` | `LIKE %?%` | `findByNameContaining` |
| `StartingWith` | `LIKE ?%` | `findByNameStartingWith` |
| `EndingWith` | `LIKE %?` | `findByNameEndingWith` |
| `GreaterThan` | `>` | `findByAgeGreaterThan` |
| `LessThan` | `<` | `findByAgeLessThan` |
| `Between` | `BETWEEN` | `findByAgeBetween` |
| `IsNull` | `IS NULL` | `findByEmailIsNull` |
| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull` |
| `OrderBy...Asc` | `ORDER BY ... ASC` | `findByNameOrderByAgeAsc` |
| `OrderBy...Desc` | `ORDER BY ... DESC` | `findByNameOrderByAgeDesc` |
| `First` | `LIMIT 1` | `findFirstByName` |
| `Top3` | `LIMIT 3` | `findTop3ByOrderByAge` |

---

### 3.2.8 커스텀 쿼리 (@Query)

#### @Query 애노테이션

**복잡한 쿼리는 직접 작성**:

```java
@Query("SELECT * FROM member WHERE name = :username AND age >= :max")
List<Member> hyechangQuery(String username, int max);
```

#### 파라미터 바인딩

**`:변수명` 형식으로 바인딩**:

```java
@Query("SELECT * FROM member WHERE name = :username AND age >= :max")
List<Member> hyechangQuery(String username, int max);
                          ────────────  ────
                                │          └─ :max와 매핑
                                └─ :username과 매핑
```

#### @Query 사용 시나리오

| 상황 | 메서드 이름 | @Query |
|-----|-----------|--------|
| 단순 조건 | ✅ 권장 | ❌ 불필요 |
| 복잡한 JOIN | ❌ 불가능 | ✅ 필수 |
| 집계 함수 (SUM, AVG) | ❌ 제한적 | ✅ 권장 |
| 성능 최적화 필요 | ❌ 제한적 | ✅ 권장 |

**예시**:
```java
// 집계 쿼리
@Query("SELECT AVG(age) FROM member")
Double getAverageAge();

// JOIN 쿼리
@Query("SELECT m.* FROM member m JOIN orders o ON m.id = o.member_id WHERE o.status = :status")
List<Member> findMembersWithOrderStatus(String status);
```

---

### 3.2.9 애플리케이션 실행 코드

#### SpringJdbcApplication 클래스

**SpringJdbcApplication.java**:
```java
package com.example.springdatajbc;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.util.Iterator;
import java.util.List;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class SpringJdbcApplication implements ApplicationRunner {

    private final MemberRepository memberRepository;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 1. 데이터 생성 (Builder 패턴)
        Member member = Member.builder()
                              .name("hyechang")
                              .email("test@hyechang.ac.kr")
                              .age(25)
                              .build();
        
        // 2. 저장 (INSERT)
        memberRepository.save(member);

        // 3. 수정 (UPDATE)
        member.setAge(35);
        memberRepository.save(member);

        // 4. ID로 조회
        Optional<Member> getm = memberRepository.findById(1L);
        if (getm.isPresent()) {
            log.info(getm.get().toString());
        }

        // 5. 전체 조회
        Iterable<Member> iterable = memberRepository.findAll();
        Iterator<Member> iterator = iterable.iterator();
        while (iterator.hasNext()) {
            log.info(iterator.next().toString());
        }

        // 6. 커스텀 쿼리 메서드
        List<Member> members = memberRepository.findByAgeGreaterThan(3);
        log.info("--- findByAgeGreaterThan(3) 결과 시작 (총 {}개) ---", members.size());
        for (Member m : members) {
            log.info(m.toString());
        }
        log.info("--- findByAgeGreaterThan(3) 결과 종료 ---");
    }
}
```

---

### 3.2.10 주요 개념 상세 분석

#### 1. @RequiredArgsConstructor + final

**의존성 주입 방식**:

```java
@Component
@RequiredArgsConstructor
public class SpringJdbcApplication {
    
    private final MemberRepository memberRepository;
    // final = 반드시 초기화되어야 함
}
```

**내부 동작**:
```java
// Lombok이 자동 생성하는 코드
public SpringJdbcApplication(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
}
```

**Spring의 DI 과정**:
```
1. @Component 스캔 → SpringJdbcApplication 클래스 발견
2. 생성자 발견 (MemberRepository 필요)
3. 스프링 컨테이너에서 MemberRepository 빈 검색
4. 검색된 빈(프록시 객체)을 생성자에 주입
5. SpringJdbcApplication 빈 생성 완료
```

#### 2. ApplicationRunner 인터페이스

**역할**: 애플리케이션 시작 직후 자동 실행

```
애플리케이션 시작 순서:

1. @SpringBootApplication 실행
2. 컴포넌트 스캔 및 빈 생성
3. 의존성 주입
4. ApplicationRunner 구현체의 run() 자동 실행 ← 여기!
5. 애플리케이션 정상 구동
```

**사용 목적**:
- 초기 데이터 삽입
- 데이터베이스 마이그레이션
- 시스템 초기화 작업
- 테스트 데이터 생성

#### 3. save()의 동작 원리

```java
Member member = Member.builder().name("hyechang").age(25).build();
memberRepository.save(member);  // ① INSERT
// 이 시점에서 member.getId()에 자동 생성된 ID 할당됨

member.setAge(35);
memberRepository.save(member);  // ② UPDATE
```

**내부 판단 로직**:
```
save() 호출 시:

if (entity.getId() == null) {
    // INSERT
    INSERT INTO member (name, email, age) VALUES (?, ?, ?)
    // 자동 생성된 ID를 entity.setId()로 설정
} else {
    // UPDATE
    UPDATE member SET name=?, email=?, age=? WHERE id=?
}
```

#### 4. Optional 처리

```java
Optional<Member> getm = memberRepository.findById(1L);
if (getm.isPresent()) {
    log.info(getm.get().toString());
}
```

**Optional을 사용하는 이유**:
- `null` 체크를 명시적으로 강제
- `NullPointerException` 방지

**더 나은 방식**:
```java
memberRepository.findById(1L)
                .ifPresent(member -> log.info(member.toString()));

// 또는
Member member = memberRepository.findById(1L)
                                 .orElse(new Member());  // 없으면 기본값

// 또는
Member member = memberRepository.findById(1L)
                                 .orElseThrow(() -> new RuntimeException("회원 없음"));
```

---

### 3.2.11 커넥션 풀 (Connection Pool)

#### 커넥션 풀이란?

**문제 상황 (JDBC 직접 사용 시)**:
```java
// 요청 1
Connection conn1 = DriverManager.getConnection(...);  // 연결 생성 (느림!)
// 쿼리 실행
conn1.close();  // 연결 종료

// 요청 2
Connection conn2 = DriverManager.getConnection(...);  // 또 연결 생성 (느림!)
// 쿼리 실행
conn2.close();  // 또 연결 종료
```

**문제점**:
- 매번 DB 연결 생성/종료 → **시간 소요** (네트워크 통신, 인증 등)
- 동시 요청 많을 시 → **성능 저하**

**해결책: 커넥션 풀**

```
[커넥션 풀]
├─ Connection 1 (미리 생성, 대기 중)
├─ Connection 2 (미리 생성, 대기 중)
├─ Connection 3 (미리 생성, 대기 중)
└─ Connection 4 (미리 생성, 대기 중)

요청 시:
1. 풀에서 빌려옴 (빠름!)
2. 쿼리 실행
3. 풀에 반납 (close()가 아님!)
```

#### 커넥션 풀의 동작 원리

**1. 애플리케이션 시작 시**:

```
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
↓
Spring Boot가 이 설정을 읽고
↓
HikariCP (기본 커넥션 풀) 초기화
↓
mydb에 Connection 10개 미리 생성 (기본값)
↓
풀에 저장하고 대기
```

**2. Repository 메서드 호출 시**:

```java
memberRepository.save(member);
↓
Spring Data JDBC가 내부적으로:
1. 커넥션 풀에서 Connection 빌려옴 (대기 중인 것 사용)
2. SQL 실행: INSERT INTO member ...
3. Connection을 풀에 반납 (close()가 아님!)
```

**3. 애플리케이션 종료 시**:

```
애플리케이션 종료 시작
↓
Spring이 자동으로 커넥션 풀 종료
↓
풀의 모든 Connection들을 DB에 반환
↓
실제 연결 종료
```

#### 커넥션 풀 설정

**application.properties**:
```properties
# HikariCP 커넥션 풀 설정
spring.datasource.hikari.maximum-pool-size=10      # 최대 커넥션 수
spring.datasource.hikari.minimum-idle=5            # 최소 유지 커넥션 수
spring.datasource.hikari.connection-timeout=20000  # 커넥션 대기 시간 (ms)
spring.datasource.hikari.idle-timeout=300000       # 유휴 커넥션 유지 시간 (ms)
```

| 설정 | 설명 | 기본값 |
|-----|------|--------|
| `maximum-pool-size` | 풀이 유지할 최대 커넥션 수 | 10 |
| `minimum-idle` | 항상 유지할 최소 커넥션 수 | `maximum-pool-size`와 동일 |
| `connection-timeout` | 커넥션을 못 얻을 때 대기 시간 | 30000ms (30초) |
| `idle-timeout` | 사용하지 않는 커넥션 제거 시간 | 600000ms (10분) |

#### 커넥션 풀 동작 시나리오

**시나리오 1: 정상 상황**

```
초기 상태: 풀에 10개 커넥션 대기 중

요청 1: save() 호출
  ├─ 커넥션 1 빌려옴 (풀: 9개 남음)
  ├─ INSERT 실행
  └─ 커넥션 1 반납 (풀: 10개)

요청 2: findAll() 호출
  ├─ 커넥션 2 빌려옴 (풀: 9개 남음)
  ├─ SELECT 실행
  └─ 커넥션 2 반납 (풀: 10개)
```

**시나리오 2: 동시 요청 많은 경우**

```
풀: 10개 커넥션

동시에 15개 요청 발생
  ├─ 10개 요청: 즉시 커넥션 할당 ✅
  └─ 5개 요청: 대기 ⏳
      └─ connection-timeout(30초) 내에 반납되면 ✅
      └─ 30초 초과 시 에러 발생 ❌
```

#### JDBC vs 커넥션 풀 비교

| 항목 | JDBC 직접 사용 | 커넥션 풀 |
|-----|---------------|----------|
| 연결 생성 | 매번 생성 (느림) | 미리 생성 (빠름) |
| 연결 종료 | 매번 종료 | 풀에 반납 (재사용) |
| 성능 | 나쁨 | 좋음 ⭐ |
| 리소스 관리 | 수동 | 자동 ⭐ |
| 동시 요청 처리 | 비효율적 | 효율적 ⭐ |

#### 핵심 정리

**커넥션 풀의 3가지 핵심**:

1. **미리 생성**: 애플리케이션 시작 시 Connection들을 미리 만들어 둠
2. **재사용**: `close()`가 실제 종료가 아니라 풀에 반납 (다시 사용 가능)
3. **자동 관리**: Spring이 빌리기/반납 모두 자동 처리

**개발자가 신경 쓸 것**:
- ❌ Connection 생성/종료: Spring이 자동 처리
- ❌ 커넥션 풀 관리: HikariCP가 자동 처리
- ✅ 적절한 풀 크기 설정: 트래픽에 맞게 조정

**연결 대상**:
- 테이블이 아니라 **데이터베이스(`mydb`)** 에 연결
- 하나의 Connection으로 여러 테이블 작업 가능

---

### 3.2.12 메인 애플리케이션

**SpringdatajbcApplication.java**:
```java
package com.example.springdatajbc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringdatajbcApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringdatajbcApplication.class, args);
    }
}
```

**실행 순서**:
```
1. main() 메서드 실행
2. @SpringBootApplication 처리
   ├─ 컴포넌트 스캔
   ├─ 자동 설정
   └─ 빈 생성
3. application.properties 읽기
   └─ 커넥션 풀 초기화 (DB 연결 10개 생성)
4. @Repository 인터페이스 발견
   └─ 프록시 객체 생성 및 빈 등록
5. @Component 발견
   └─ SpringJdbcApplication 빈 생성 및 의존성 주입
6. ApplicationRunner 구현체 실행
   └─ run() 메서드 호출
7. 애플리케이션 구동 완료
```

---



### 3.2.13 JDBC vs Spring Data JDBC 최종 비교

#### 코드 비교

**JDBC (3.1)**:
```java
// 1. Driver 로딩
Class.forName("com.mysql.cj.jdbc.Driver");

// 2. Connection 생성
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", "myuser", "mypass"
);

// 3. Statement 생성
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM member");

// 4. 쿼리 실행
ResultSet rs = stmt.executeQuery();

// 5. 결과 매핑
while (rs.next()) {
    Member member = new Member(
        rs.getLong("id"),
        rs.getString("name"),
        rs.getString("email"),
        rs.getInt("age")
    );
    System.out.println(member);
}

// 6. 리소스 정리
conn.close();
```

**Spring Data JDBC (3.2)**:
```java
// 설정 파일 (한 번만)
// spring.datasource.url=jdbc:mysql://localhost:3306/mydb

// Repository 인터페이스 (선언만)
public interface MemberRepository extends CrudRepository<Member, Long> {
    List<Member> findByAgeGreaterThan(int age);
}

// 사용
List<Member> members = memberRepository.findAll();
members.forEach(System.out::println);
```

**코드 라인 수**: 25줄 → 3줄 (약 88% 감소!)

#### 장단점 비교

| 특징 | JDBC | Spring Data JDBC |
|-----|------|-----------------|
| **코드 양** | 많음 ❌ | 적음 ✅ |
| **반복 코드** | 많음 ❌ | 없음 ✅ |
| **학습 곡선** | 낮음 ✅ | 중간 |
| **유연성** | 높음 ✅ | 중간 |
| **성능 최적화** | 쉬움 ✅ | 제한적 |
| **생산성** | 낮음 ❌ | 높음 ✅ |
| **커넥션 관리** | 수동 ❌ | 자동 ✅ |
| **SQL 가시성** | 명확 ✅ | 숨겨짐 (로그로 확인) |

---

### 3.2.14 Spring Data JDBC의 한계

#### 한계 1: 복잡한 연관관계

**문제**:
```java
// Member - Order 관계 (1:N)
// Spring Data JDBC에서는 복잡함
@Table
public class Member {
    @Id
    private Long id;
    private String name;
    
    // @ManyToOne 같은 애노테이션이 제한적
}
```
테이블과의 연관관계를 표현할 수 없다.

**해결**: JPA 사용 (3.4에서 학습) @Entity 와 @ManyToOne , @ManyToMany 등등 사용이 가능

#### 한계 2: DDL 자동 생성
DDL 자동 생성 미지원
Spring Data JDBC는 JPA의 핵심 편의 기능 중 하나인 DDL(Data Definition Language) 자동 생성 기능을 지원하지 않음


| 명령어 | 역할 | 
|-----|------|
| **CREATE TABLE** |테이블 생성 |
| **ALTER TABLE** | 테이블 수정|
| **DROP TABLE** | 테이블 삭제 |
| **TRUNCATE TABLE** | 테이블 데이터 삭제 |


📌 문제 상황 (수동 작업 필요)
자바 엔티티에 새로운 필드를 추가하더라도, 데이터베이스 테이블에는 수동으로 SQL을 작성하여 반영해야 합니다.

```java


// Java 엔티티에 필드 추가
@Table
public class Member {
    @Id
    private Long id;
    private String name;
    // ...
    private String phone;  // 👈 새로 추가!
}

```
SQL

- ❌ Spring Data JDBC는 이 부분을 자동으로 처리하지 않음!
- 테이블에 컬럼을 수동으로 추가해야 함!
ALTER TABLE member ADD COLUMN phone VARCHAR(255);
결과: 엔티티 수정 시 SQL을 직접 작성해야 하므로 테이블과 엔티티 불일치 가능성이 높아지고 개발 속도가 저하!

**해결**: JPA 사용 (3.4에서 학습) : JPA는 설정 파일을 통해 애플리케이션 시작 시 엔티티를 분석하여 자동으로 DDL을 실행합니다.
```
application.properties
spring.jpa.hibernate.ddl-auto=update
```


## 3.3 MyBatis

### 3.3.1 MyBatis란?

**MyBatis**는 SQL 중심의 데이터베이스 연동 프레임워크로, **개발자가 작성한 SQL과 Java 객체를 매핑**하는 데 특화되어 있습니다.

#### 핵심 개념

```
[개발자]
    ↓ (SQL 직접 작성)
[MyBatis]
    ↓ (JDBC 코드 자동 생성 및 결과 매핑)
[JDBC Driver]
    ↓
[데이터베이스]
```

**MyBatis의 역할**:
- 개발자: SQL만 작성
- MyBatis: Connection, PreparedStatement, ResultSet 등 **JDBC 보일러플레이트 코드 자동 처리**
- 결과를 Java 객체로 자동 매핑

---

### 3.3.2 Spring Data JDBC vs MyBatis

#### 근본적인 차이

| 특징 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **철학** | 도메인(객체) 중심 | **SQL 중심** ⭐ |
| **SQL 작성** | 메서드 이름 자동 생성 + @Query | **항상 직접 작성** (XML 또는 애노테이션) |
| **SQL 위치** | 인라인(@Query 내부) | **별도 XML 파일** (분리) |
| **동적 SQL** | 제한적 | **강력한 지원** ⭐ |
| **복잡한 쿼리** | 어려움 | **매우 유리** ⭐ |
| **성능 최적화** | 제한적 | **세밀한 제어 가능** ⭐ |
| **학습 곡선** | 낮음 | 중간 |
| **코드 양** | 적음 | 중간 (XML 작성) |

#### 왜 MyBatis를 사용하는가?

**Spring Data JDBC + @Query의 한계**:

```java
// Spring Data JDBC
@Query("SELECT * FROM member WHERE " +
       "(:name IS NULL OR name LIKE %:name%) AND " +
       "(:minAge IS NULL OR age >= :minAge) AND " +
       "(:maxAge IS NULL OR age <= :maxAge)")
List<Member> search(@Param("name") String name, 
                    @Param("minAge") Integer minAge,
                    @Param("maxAge") Integer maxAge);
```

**문제점**:
- ❌ SQL이 Java 문자열 안에 있어 가독성 저하
- ❌ 복잡한 동적 쿼리 작성 어려움
- ❌ SQL 문법 검증 불가 (컴파일 시점)
- ❌ SQL이 길어질수록 유지보수 어려움

**MyBatis의 해결**:

```xml
<!-- XML 파일에 SQL 분리 -->
<select id="search" resultType="Member">
    SELECT * FROM member
    <where>
        <if test="name != null">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="minAge != null">
            AND age >= #{minAge}
        </if>
        <if test="maxAge != null">
            AND age <= #{maxAge}
        </if>
    </where>
</select>
```

**장점**:
- ✅ SQL이 독립된 파일로 분리 (가독성 향상)
- ✅ **동적 SQL** 작성 용이 (`<if>`, `<choose>`, `<foreach>` 등)
- ✅ SQL 재사용 가능 (`<include>`)
- ✅ 조건에 따라 쿼리 자체가 변경 가능
- ✅ 복잡한 JOIN, 서브쿼리에 강함

---

### 3.3.3 MyBatis vs Spring Data JDBC 사용 시나리오

#### Spring Data JDBC 적합한 경우

```
✅ 단순한 CRUD 작업
✅ 단일 테이블 조회/수정
✅ 메서드 이름으로 자동 생성 가능한 쿼리
✅ 간단한 조건 검색

예: findByName(), findByAgeGreaterThan()
```

#### MyBatis 적합한 경우

```
✅ 복잡한 JOIN (3개 이상 테이블)
✅ 동적 SQL (조건에 따라 쿼리 변경)
✅ 복잡한 집계 쿼리 (GROUP BY, HAVING)
✅ 성능 최적화가 중요한 쿼리
✅ SQL에 익숙한 팀
✅ 대규모 프로젝트

예: 검색 기능, 통계 리포트, 복잡한 비즈니스 로직
```

#### 실전 예시

**요구사항**: 회원 검색 (이름, 나이 범위, 정렬 순서 - 모두 선택 사항)

**Spring Data JDBC (복잡함)**:
```java
// 모든 경우의 수를 메서드로 만들어야 함
List<Member> findByName(String name);
List<Member> findByAgeBetween(int min, int max);
List<Member> findByNameAndAgeBetween(String name, int min, int max);
// ... 조합이 늘어날수록 메서드 폭발!
```

**MyBatis (간단함)**:
```xml
<select id="search">
    SELECT * FROM member
    <where>
        <!--    <>태그 안에서는 #{} 이 아닌 바로 접근이 가능하다.     -->
        <if test="name != null">AND name LIKE #{name}</if>
        <if test="minAge != null">AND age >= #{minAge}</if>
        <if test="maxAge != null">AND age <= #{maxAge}</if>
    </where>
    <if test="orderBy != null">
        ORDER BY ${orderBy} ${direction}
    </if>
</select>
```

---

### 3.3.4 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    // MyBatis Spring Boot Starter
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.5'
    
    // H2 Database (내장 DB, 테스트용)
    runtimeOnly 'com.h2database:h2'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter-test:3.0.5'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 |
|-------|------|
| `mybatis-spring-boot-starter` | MyBatis를 Spring Boot에서 쉽게 사용하도록 통합 |
| `h2` | 내장형 데이터베이스 (애플리케이션 재시작 시 초기화) |

**H2 Database의 특징**:
- 애플리케이션에 **내장**되어 실행
- **메모리 기반** (재시작 시 데이터 초기화)
- **테스트 및 개발 환경**에 적합
- 별도 DB 서버 설치 불필요
- H2도 데이터베이스이므로 **JDBC Driver 필요** (h2 의존성이 Driver 포함)

---

### 3.3.5 설정 파일

**application.properties**:
```properties
spring.application.name=mybatisSample

# ========================================
# MyBatis 설정
# ========================================
# SQL이 작성된 XML 파일 위치
mybatis.mapper-locations=classpath:mapper/**/*.xml

# 스네이크 케이스 → 카멜 케이스 자동 변환
mybatis.configuration.map-underscore-to-camel-case=true

# ========================================
# H2 Database 초기화
# ========================================
# schema.sql, data.sql 자동 실행
spring.sql.init.mode=always
spring.sql.init.encoding=utf-8
```

#### 설정 설명

| 속성 | 설명 |
|-----|------|
| `mybatis.mapper-locations` | SQL Mapper XML 파일 경로 (`src/main/resources/mapper/` 하위 모든 XML) |
| `map-underscore-to-camel-case` | DB 컬럼 `user_name` → Java 필드 `userName` 자동 매핑 |
| `spring.sql.init.mode` | 애플리케이션 시작 시 초기화 스크립트 실행 (H2 테스트용) |

---

### 3.3.6 프로젝트 구조

```
src/main/java/com/example/mybatisSample/
├─ mapper/              # Mapper 인터페이스
│  ├─ MemberMapper.java
│  └─ ArticleMapper.java
├─ model/               # 도메인 모델 (Entity)
│  ├─ Member.java
│  └─ Article.java
└─ MyBatisApplication.java

src/main/resources/
├─ mapper/              # SQL Mapper XML
│  └─ MemberMapper.xml
├─ schema.sql           # 테이블 생성 SQL
├─ data.sql             # 초기 데이터 SQL
└─ application.properties
```

---

### 3.3.7 모델 클래스 (Model)

#### Member 클래스

**Member.java**:
```java
package com.example.mybatisSample.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### Article 클래스

**Article.java**:
```java
package com.example.mybatisSample.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    private Long id;
    private String title;
    private String description;
    private Date created;
    private Date updated;
    private Long memberId;
}
```

#### Spring Data JDBC와의 차이
#### 클래스의 정체성

| 프레임워크 | 클래스 역할 | 비유 |
|----------|-----------|------|
| **Spring Data JDBC** | **테이블 + 그릇** | 설계도 = 건물 |
| **MyBatis** | **그릇만** | 창고에서 물건 꺼내서 상자에 담기 |

---

#### Spring Data JDBC - "클래스 = 테이블"

```java
@Table  // ① 테이블 선언 + ② 결과 담는 그릇 (이중 역할!)
public class Member {
    @Id
    private Long id;
    private String name;
}
```

**특징**:
```
클래스 ←→ 테이블 (완전히 동일시)

- 클래스 구조 = 테이블 구조
- 클래스 변경 → 테이블 변경 필요
- 테이블 변경 → 클래스 변경 필요
```

**문제 발생**:
- ❌ **연관관계 표현 제한**: `@ManyToOne`, `@OneToMany` 부족
- ❌ **동기화 필요**: 테이블 ↔ 클래스 항상 일치해야 함
---

#### MyBatis - "클래스 = SQL 결과 담는 그릇"

```java
// 애노테이션 없음! 순수 그릇!
public class Member {
    private Long id;
    private String name;
}
```

```xml
<select id="selectAll" resultType="Member">
    SELECT id, name FROM member
</select>
```

**특징**:
```
SQL 실행 → ResultSet → 클래스(그릇)

- 테이블과 클래스 독립적
- SQL이 테이블 결정
- 클래스는 결과만 담음
```

**문제 해결**:
- ✅ **연관관계 자유**: SQL로 JOIN 마음대로
- ✅ **동기화 불필요**: 테이블 ↔ 클래스 독립적
- ✅ **필요한 컬럼만**: SELECT id, name만 가능

---

#### 비교표

| 항목 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **클래스 정체성** | 테이블 그 자체 | SQL 결과 그릇 |
| **테이블 매핑** | `@Table` 필수 | 애노테이션 불필요 |
| **테이블-클래스 관계** | 완전히 동일해야 함 | 독립적 |
| **연관관계** | ❌ 제한적 | ✅ SQL로 자유롭게 |
| **테이블 변경 시** | ❌ 클래스도 변경 | ✅ SQL만 변경 |
| **클래스 변경 시** | ❌ 테이블도 변경 | ✅ 영향 없음 |
| **동기화 문제** | ❌ 항상 발생 | ✅ 없음 |

---

#### 실전 예시

##### 시나리오: 테이블에 phone 컬럼 추가

**데이터베이스**:
```sql
ALTER TABLE member ADD COLUMN phone VARCHAR(20);
```

**Spring Data JDBC**:
```java
@Table
public class Member {
    @Id private Long id;
    private String name;
    private String phone;  // ❌ 필수 추가! (안 하면 문제)
}
```

**MyBatis**:
```java
// ✅ 클래스 그대로 사용 가능!
public class Member {
    private Long id;
    private String name;
    // phone 없어도 됨!
}
```

```xml
<!-- ✅ 필요할 때만 SELECT -->
<select id="selectAll" resultType="Member">
    SELECT id, name FROM member  <!-- phone 안 가져와도 OK -->
</select>

<!-- phone 필요한 경우만 별도 쿼리 -->
<select id="selectWithPhone" resultType="MemberWithPhone">
    SELECT id, name, phone FROM member
</select>
```

---

##### 시나리오: Member-Order 연관관계

**Spring Data JDBC**:
```java
@Table
public class Member {
    @Id private Long id;
    private String name;
    
    // ❌ 연관관계 표현이 제한적
    // private List<Order> orders;
}
```

**MyBatis**:
```java
// 그냥 그릇!
public class Member {
    private Long id;
    private String name;
}

public class MemberWithOrders {
    private Long id;
    private String name;
    private List<Order> orders;  // ✅ 자유롭게 구성
}
```

```xml
<!-- ✅ SQL로 자유롭게 JOIN -->
<select id="selectMemberWithOrders" resultType="MemberWithOrders">
    SELECT 
        m.id, m.name,
        o.id as order_id, o.product_name
    FROM member m
    LEFT JOIN orders o ON m.id = o.member_id
    WHERE m.id = #{id}
</select>
```

---

#### 핵심 요약

**Spring Data JDBC**:
```
@Table = "나는 member 테이블이면서 동시에 그릇이야!"

장점: 간단한 CRUD 자동화
단점: 테이블 = 클래스 (강제), 연관관계 약함, 동기화 필요
```

**MyBatis**:
```
클래스 = "나는 그냥 그릇이야! 테이블은 SQL이 결정해!"

장점: 테이블-클래스 독립, 연관관계 자유, 복잡한 쿼리 강력
단점: SQL 직접 작성 필요
```

**결론**:
- Spring Data JDBC의 **한계 (연관관계, 동기화)**는 MyBatis에서 **애초에 발생하지 않음**
- 하지만 MyBatis는 모든 SQL을 직접 작성해야 하는 번거로움 존재


### 3.3.8 Mapper 인터페이스

#### @Mapper 애노테이션

**역할**: 이 인터페이스가 MyBatis의 SQL 매핑 인터페이스임을 선언

```java
@Mapper  // MyBatis가 인식
public interface MemberMapper {
    List<Member> selectAll();
}
```

**Spring의 처리**:
```
1. @Mapper 스캔
2. 프록시 객체 자동 생성 (구현체)
3. 스프링 빈으로 등록
4. 다른 클래스에서 주입 가능
```

**Spring Data JDBC와 비교**:

| 프레임워크 | 애노테이션 | 역할 |
|----------|-----------|------|
| Spring Data JDBC | `@Repository` | 데이터 접근 계층 |
| MyBatis | `@Mapper` | SQL 매핑 인터페이스 |

> **공통점**: 둘 다 인터페이스만 정의하면 Spring이 구현체를 자동 생성!

---

### 3.3.9 XML 기반 SQL 매핑

#### MemberMapper 인터페이스

**MemberMapper.java**:
```java
package com.example.mybatisSample.mapper;

import com.example.mybatisSample.model.Member;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Optional;

@Mapper
public interface MemberMapper {
    List<Member> selectAll();
    Optional<Member> selectById(@Param("id") Long id);
    Optional<Member> selectByEmail(@Param("email") String email);
    List<Member> selectAllOrderByAgeAsc();
    List<Member> selectAllOrderBy(@Param("order") String order, @Param("dir") String dir);
    List<Member> selectByNameLike(@Param("name") String name);
    int selectCount();
    int insert(@Param("member") Member member);
    int update(@Param("member") Member member);
    int delete(@Param("member") Member member);
    int deleteById(@Param("id") Long id);
    int deleteAll();
}
```

#### @Param 애노테이션

**역할**: 메서드 매개변수에 이름을 부여하여 XML/애노테이션 SQL에서 참조

```java
Optional<Member> selectByEmail(@Param("email") String email);
                               ─────────────
                                     ↓
                               XML에서 #{email}로 참조
```

**사용 예시**:
```java
// 단일 파라미터
selectById(@Param("id") Long id)
// XML: #{id}

// 객체 파라미터
insert(@Param("member") Member member)
// XML: #{member.name}, #{member.email}

// 복수 파라미터
selectAllOrderBy(@Param("order") String order, @Param("dir") String dir)
// XML: #{order}, #{dir}
```

---

### 3.3.10 MemberMapper.xml

**src/main/resources/mapper/MemberMapper.xml**:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.mybatisSample.mapper.MemberMapper">

    <!-- 전체 조회 -->
    <select id="selectAll" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member
    </select>

    <!-- ID로 조회 -->
    <select id="selectById" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE id = #{id}
    </select>

    <!-- 이메일로 조회 -->
    <select id="selectByEmail" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE email = #{email}
    </select>

    <!-- 나이 오름차순 정렬 -->
    <select id="selectAllOrderByAgeAsc" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member ORDER BY age ASC
    </select>

    <!-- 동적 정렬 -->
    <select id="selectAllOrderBy" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member ORDER BY ${order} ${dir}
    </select>

    <!-- 이름 LIKE 검색 -->
    <select id="selectByNameLike" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE name LIKE #{name}
    </select>

    <!-- 개수 조회 -->
    <select id="selectCount" resultType="int">
        SELECT COUNT(*) FROM member
    </select>

    <!-- 삽입 (자동 생성 키 반환) -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="member.id" keyColumn="id">
        INSERT INTO member(name, email, age) 
        VALUES (#{member.name}, #{member.email}, #{member.age})
    </insert>

    <!-- 수정 -->
    <update id="update">
        UPDATE member 
        SET name = #{member.name}, email = #{member.email}, age = #{member.age} 
        WHERE id = #{member.id}
    </update>

    <!-- 삭제 (객체) -->
    <delete id="delete">
        DELETE FROM member WHERE id = #{member.id}
    </delete>

    <!-- 삭제 (ID) -->
    <delete id="deleteById">
        DELETE FROM member WHERE id = #{id}
    </delete>

    <!-- 전체 삭제 -->
    <delete id="deleteAll">
        DELETE FROM member
    </delete>

</mapper>
```

---

### 3.3.11 XML 태그 상세 설명

#### 기본 구조

| 태그 | 역할 | 필수 속성 |
|-----|------|----------|
| `<mapper>` | 루트 태그 | `namespace` |
| `<select>` | SELECT 쿼리 | `id`, `resultType` |
| `<insert>` | INSERT 쿼리 | `id` |
| `<update>` | UPDATE 쿼리 | `id` |
| `<delete>` | DELETE 쿼리 | `id` |

#### namespace

```xml
<mapper namespace="com.example.mybatisSample.mapper.MemberMapper">
```

**역할**: 이 XML이 어떤 Mapper 인터페이스와 연결될지 지정

**매핑 과정**:
```
1. MyBatis가 @Mapper 인터페이스 스캔
2. namespace와 인터페이스 경로 비교
3. 일치하면 XML과 인터페이스 연결
4. 메서드 호출 시 id와 일치하는 SQL 실행
```

#### id 속성

```xml
<select id="selectAll">
```

**역할**: Mapper 인터페이스의 메서드 이름과 **정확히 일치**해야 함

```java
// 인터페이스
List<Member> selectAll();

// XML
<select id="selectAll">  // 메서드명과 동일!
```

#### resultType

```xml
<select id="selectAll" resultType="com.example.mybatisSample.model.Member">
```

**역할**: SQL 실행 결과를 어떤 Java 타입으로 매핑할지 지정

**타입별 사용**:
```xml
<!-- 단일 객체 -->
<select resultType="com.example.mybatisSample.model.Member">

<!-- 리스트 (요소 타입 지정) -->
<select resultType="com.example.mybatisSample.model.Member">

<!-- 기본 타입 -->
<select resultType="int">
<select resultType="String">
<select resultType="Long">
```

---

### 3.3.12 파라미터 바인딩

#### #{} vs ${}

| 문법 | 설명 | SQL 변환 | 사용 |
|-----|------|---------|------|
| `#{파라미터}` | **PreparedStatement** (권장) | `?`로 치환 | 값 바인딩 |
| `${파라미터}` | **Statement** (주의) | 문자열 직접 삽입 | 테이블명, 컬럼명 |

#### #{} (권장) ⭐

```xml
<select id="selectById">
    SELECT * FROM member WHERE id = #{id}
</select>
```

**변환 과정**:
```
1. SQL: SELECT * FROM member WHERE id = ?
2. PreparedStatement 사용
3. id 값을 안전하게 바인딩
```

**장점**:
- ✅ **SQL Injection 방지**
- ✅ 자동 타입 변환
- ✅ null 처리 안전

#### ${} (주의!)

```xml
<select id="selectAllOrderBy">
    SELECT * FROM member ORDER BY ${order} ${dir}
</select>
```

**변환 과정**:
```
1. order = "name", dir = "ASC"
2. SQL: SELECT * FROM member ORDER BY name ASC
3. 문자열 직접 치환
```

**주의사항**:
- ❌ **SQL Injection 위험**
- ❌ 사용자 입력값에 사용 금지
- ✅ 테이블명, 컬럼명, ORDER BY 절에만 사용

**안전한 사용 예시**:
```java
// 컨트롤러에서 값 검증
String order = "name";  // 화이트리스트 검증
if (!List.of("name", "age", "email").contains(order)) {
    throw new IllegalArgumentException("잘못된 정렬 기준");
}
```

---

### 3.3.13 자동 생성 키 처리

#### useGeneratedKeys

```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="member.id" keyColumn="id">
    INSERT INTO member(name, email, age) 
    VALUES (#{member.name}, #{member.email}, #{member.age})
</insert>
```

#### 속성 설명

| 속성 | 역할 |
|-----|------|
| `useGeneratedKeys="true"` | DB가 자동 생성한 키(AUTO_INCREMENT)를 가져옴 |
| `keyColumn="id"` | DB 테이블의 자동 생성 키 컬럼명 |
| `keyProperty="member.id"` | 생성된 키 값을 저장할 Java 객체 필드 |

#### 동작 과정

```java
Member member = Member.builder()
                      .name("홍혜창")
                      .email("test@example.com")
                      .age(25)
                      .build();

System.out.println(member.getId());  // null

memberMapper.insert(member);  // INSERT 실행

System.out.println(member.getId());  // 5 (DB에서 생성된 ID)
```

**내부 동작**:
```
1. INSERT SQL 실행
2. DB가 id = 5 자동 생성
3. MyBatis가 생성된 5를 가져옴
4. member.setId(5) 자동 호출
5. member 객체 재사용 가능
```

#### useGeneratedKeys 생략 시

```xml
<!-- useGeneratedKeys 없음 -->
<insert id="insert">
    INSERT INTO member(name, email, age) VALUES (#{member.name}, #{member.email}, #{member.age})
</insert>
```

```java
Member member = Member.builder().name("홍혜창").build();
memberMapper.insert(member);

System.out.println(member.getId());  // null (ID가 채워지지 않음)
```

**결과**:
- DB에는 레코드 정상 생성 (AUTO_INCREMENT 작동)
- Java 객체에는 ID가 채워지지 않음

#### 사용 시나리오

| 상황 | useGeneratedKeys 설정 | 이유 |
|-----|---------------------|------|
| **ID 재사용 필요** | ✅ 필수 | 생성된 ID로 후속 작업 필요 |
| **ID 재사용 불필요** | ❌ 생략 가능 | 단순 INSERT만 수행 |

**예시**:
```java
// 시나리오: 회원 가입 후 환영 이메일 발송
Member member = new Member("홍혜창", "test@example.com", 25);
memberMapper.insert(member);  // useGeneratedKeys="true"

// 생성된 ID로 환영 이메일 발송
emailService.sendWelcome(member.getId(), member.getEmail());
```

---

### 3.3.14 애노테이션 기반 SQL 매핑

#### ArticleMapper 인터페이스

**ArticleMapper.java**:
```java
package com.example.mybatisSample.mapper;

import com.example.mybatisSample.model.Article;
import org.apache.ibatis.annotations.*;

import java.util.List;
import java.util.Optional;

@Mapper
public interface ArticleMapper {
    
    @Select("SELECT * FROM article")
    List<Article> selectAll();
    
    @Select("SELECT * FROM article WHERE id = #{id}")
    Optional<Article> selectById(@Param("id") Long id);
    
    @Insert("INSERT INTO article(title, description, created, updated, member_id) " +
            "VALUES (#{article.title}, #{article.description}, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, #{article.memberId})")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "article.id")
    int insert(@Param("article") Article article);
    
    @Update("UPDATE article SET title = #{title}, description = #{description}, updated = CURRENT_TIMESTAMP WHERE id = #{id}")
    int update(@Param("id") Long id, @Param("title") String title, @Param("description") String description);
    
    @Delete("DELETE FROM article WHERE id = #{id}")
    int deleteById(@Param("id") Long id);
}
```

#### 애노테이션 종류

| 애노테이션 | 역할 | SQL 종류 |
|-----------|------|----------|
| `@Select` | SELECT 쿼리 | 조회 |
| `@Insert` | INSERT 쿼리 | 삽입 |
| `@Update` | UPDATE 쿼리 | 수정 |
| `@Delete` | DELETE 쿼리 | 삭제 |
| `@Options` | 추가 옵션 (자동 생성 키 등) | INSERT |

#### XML vs 애노테이션 비교

**XML 방식**:
```xml
<!-- MemberMapper.xml -->
<select id="selectAll" resultType="Member">
    SELECT * FROM member
</select>
```

**애노테이션 방식**:
```java
// ArticleMapper.java
@Select("SELECT * FROM article")
List<Article> selectAll();
```

#### 언제 어떤 방식을 사용할까?

| 상황 | XML | 애노테이션 |
|-----|-----|-----------|
| **단순한 쿼리** | ❌ | ✅ 권장 |
| **복잡한 쿼리** | ✅ 권장 | ❌ |
| **동적 SQL** | ✅ 권장 | ❌ |
| **SQL 재사용** | ✅ 권장 | ❌ |
| **빠른 프로토타이핑** | ❌ | ✅ 권장 |

**실무 권장**:
- 복잡한 쿼리, 동적 SQL → **XML**
- 단순한 CRUD → **애노테이션**

---

### 3.3.15 컬럼명과 필드명 불일치 해결

#### 문제 상황

**데이터베이스**:
```sql
CREATE TABLE article (
    id BIGINT,
    title VARCHAR(255),
    content VARCHAR(1000),  -- Java 필드는 'description'
    member_id BIGINT
);
```

**Java 클래스**:
```java
public class Article {
    private Long id;
    private String title;
    private String description;  // DB 컬럼은 'content'
    private Long memberId;
}
```

#### 해결 방법

##### 방법 1: application.properties 설정 (권장) ⭐

```properties
mybatis.configuration.map-underscore-to-camel-case=true
```

**자동 변환**:
```
DB: member_id  → Java: memberId
DB: created_at → Java: createdAt
DB: user_name  → Java: userName
```

**장점**:
- ✅ 전역 설정 (한 번만 작성)
- ✅ 스네이크 케이스 ↔ 카멜 케이스 자동 변환
- ✅ 대부분의 불일치 문제 해결

**한계**:
- ❌ `content` ↔ `description` 같은 완전히 다른 이름은 해결 못 함

##### 방법 2: SQL AS 키워드 (선택적)

```sql
SELECT id, title, content AS description, member_id 
FROM article
```

**적용**:
```java
@Select("SELECT id, title, content AS description, member_id FROM article")
List<Article> selectAll();
```

**장점**:
- ✅ 간단한 경우 빠르게 해결

**단점**:
- ❌ 모든 SELECT 문에 반복 작성
- ❌ 유지보수 어려움

##### 방법 3: `<resultMap>` (완전한 제어) ⭐

**XML**:
```xml
<resultMap id="articleResult" type="com.example.mybatisSample.model.Article">
    <result column="content" property="description"/>
    <result column="member_id" property="memberId"/>
</resultMap>

<select id="selectAll" resultMap="articleResult">
    SELECT * FROM article
</select>

<select id="selectById" resultMap="articleResult">
    SELECT * FROM article WHERE id = #{id}
</select>
```

**재사용 가능**:
- 한 번 정의하면 여러 쿼리에서 `resultMap="articleResult"` 참조

**애노테이션**:
```java
@Results(id = "articleResult", value = {
    @Result(column = "content", property = "description"),
    @Result(column = "member_id", property = "memberId")
})
@Select("SELECT * FROM article")
List<Article> selectAll();

@ResultMap("articleResult")  // 재사용
@Select("SELECT * FROM article WHERE id = #{id}")
Optional<Article> selectById(@Param("id") Long id);
```

**사용 시점**:
- 첫 번째 쿼리: `@Results`로 정의
- 이후 쿼리: `@ResultMap`으로 재사용

**장점**:
- ✅ 완전한 커스텀 매핑 가능
- ✅ 재사용 가능
- ✅ 복잡한 매핑 처리 가능

**단점**:
- ❌ 코드가 길어짐

#### 권장 순서

```
1. map-underscore-to-camel-case=true (대부분 해결)
   ↓
2. 안 되면 AS 키워드 (간단한 경우)
   ↓
3. 여전히 안 되면 <resultMap> (복잡한 경우)
```

---

### 3.3.16 애플리케이션 실행

#### MyBatisApplication 클래스

**MyBatisApplication.java**:
```java
package com.example.mybatisSample;

import com.example.mybatisSample.mapper.ArticleMapper;
import com.example.mybatisSample.mapper.MemberMapper;
import com.example.mybatisSample.model.Article;
import com.example.mybatisSample.model.Member;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Slf4j
@RequiredArgsConstructor
@Component
public class MyBatisApplication implements ApplicationRunner {
    
    private final ArticleMapper articleMapper;
    private final MemberMapper memberMapper;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        
        // 1. 회원 수 조회
        int count = memberMapper.selectCount();
        log.info("count: {}", count);

        // 2. 이메일로 회원 조회
        Member member = memberMapper.selectByEmail("hyechang@spring.ac.kr")
                                     .orElseThrow();
        log.info("member: {}", member);

        // 3. 게시글 작성
        Article article = Article.builder()
                                 .title("제목입니다.")
                                 .description("내용입니다.")
                                 .memberId(member.getId())
                                 .build();
        
        int insert = articleMapper.insert(article);
        log.info("insert: {}", insert);
        log.info("생성된 게시글 ID: {}", article.getId());  // 자동 생성된 ID 출력
    }
}
```

#### 메인 클래스

**MybatisSampleApplication.java**:
```java
package com.example.mybatisSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MybatisSampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(MybatisSampleApplication.class, args);
    }
}
```

---

### 3.3.17 실행 결과 및 로그

#### 실행 결과 로그 출력

```
 :: Spring Boot ::                (v3.5.6)

2025-10-15T12:56:13.692+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : Starting MybatisSampleApplication using Java 21.0.8 with PID 32404 (C:\Users\ghddm\Desktop\SpringBoot\mybatisSample\build\classes\java\main started by ghddm in C:\Users\ghddm\Desktop\SpringBoot\mybatisSample)
2025-10-15T12:56:13.698+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : No active profile set, falling back to 1 default profile: "default"
2025-10-15T12:56:15.404+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-10-15T12:56:15.834+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection conn0: url=jdbc:h2:mem:daa4c2b0-93b6-4052-8dca-ecd1ca6e5774 user=SA
2025-10-15T12:56:15.839+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-10-15T12:56:16.510+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : Started MybatisSampleApplication in 4.122 seconds (process running for 5.349)
2025-10-15T12:56:16.571+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : count: 4
2025-10-15T12:56:16.581+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : member: Member(id=1, name=홍혜창, email=hyechang@spring.ac.kr, age=10)
2025-10-15T12:56:16.589+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : insert: 1
2025-10-15T12:56:16.599+09:00  INFO 32404 --- [mybatisSample] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2025-10-15T12:56:16.603+09:00  INFO 32404 --- [mybatisSample] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
```

---

### 3.3.18 Spring Data JDBC vs MyBatis 최종 비교

#### 코드 비교

**Spring Data JDBC**:
```java
// Repository 인터페이스
public interface MemberRepository extends CrudRepository<Member, Long> {
    List<Member> findByEmail(String email);  // 메서드 이름으로 자동 생성
    
    @Query("SELECT * FROM member WHERE name LIKE :name")  // 복잡한 쿼리는 @Query
    List<Member> searchByName(@Param("name") String name);
}
```

**MyBatis**:
```java
// Mapper 인터페이스
@Mapper
public interface MemberMapper {
    Optional<Member> selectByEmail(@Param("email") String email);
    List<Member> searchByName(@Param("name") String name);
}
```

```xml
<!-- SQL은 XML에 분리 -->
<select id="selectByEmail">
    SELECT * FROM member WHERE email = #{email}
</select>

<select id="searchByName">
    SELECT * FROM member WHERE name LIKE #{name}
</select>
```

#### 특징 비교

| 특징 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **SQL 자동 생성** | ✅ 메서드 이름 규칙 | ❌ 항상 직접 작성 |
| **SQL 위치** | Java 코드 내부 | **XML 파일 분리** ⭐ |
| **동적 SQL** | 제한적 | **강력한 지원** ⭐ |
| **복잡한 쿼리** | 어려움 | **매우 유리** ⭐ |
| **코드 양** | 적음 | 중간 (XML) |
| **학습 곡선** | 낮음 | 중간 |
| **SQL 제어** | 제한적 | **완전한 제어** ⭐ |
| **가독성** | 중간 | **높음** (SQL 분리) ⭐ |
| **테스트** | 쉬움 | 중간 |

---

### 3.3.19 MyBatis의 장단점

#### 장점

**1. SQL에 대한 완전한 제어** ⭐
```xml
<!-- 복잡한 JOIN도 자유롭게 -->
<select id="selectWithMember">
    SELECT a.*, m.name as member_name
    FROM article a
    INNER JOIN member m ON a.member_id = m.id
    WHERE a.created > #{startDate}
    ORDER BY a.created DESC
</select>
```

**2. 동적 SQL 강력** ⭐
```xml
<select id="search">
    SELECT * FROM member
    <where>
        <if test="name != null">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="minAge != null">
            AND age >= #{minAge}
        </if>
        <if test="maxAge != null">
            AND age <= #{maxAge}
        </if>
    </where>
    <if test="orderBy != null">
        ORDER BY ${orderBy} ${direction}
    </if>
</select>
```

**3. SQL 분리로 가독성 향상** ⭐
```
Java 코드: 비즈니스 로직만
XML 파일: SQL만

→ 관심사의 분리 (Separation of Concerns)
```

**4. 성능 최적화 용이**
- 필요한 컬럼만 선택 가능
- 복잡한 서브쿼리, WITH절 자유롭게 사용
- 인덱스 힌트 등 DB 특화 기능 활용

**5. SQL에 익숙한 팀에 적합**
- DBA가 작성한 최적화된 SQL 그대로 사용
- 기존 SQL 자산 재활용 가능

#### 단점

**1. 보일러플레이트 증가**
```java
// 메서드마다 SQL 작성 필요
@Select("SELECT * FROM member")
List<Member> selectAll();

@Select("SELECT * FROM member WHERE id = #{id}")
Optional<Member> selectById(@Param("id") Long id);
```

**2. 단순 CRUD도 직접 작성**
```xml
<!-- Spring Data JDBC는 자동인데... -->
<select id="findById">SELECT * FROM member WHERE id = #{id}</select>
<insert id="insert">INSERT INTO member(...) VALUES(...)</insert>
<update id="update">UPDATE member SET ... WHERE id = #{id}</update>
<delete id="delete">DELETE FROM member WHERE id = #{id}</delete>
```

**3. XML 파일 관리 부담**
- 인터페이스와 XML 파일 동기화 필요
- 메서드명 오타 시 런타임 에러

**4. 타입 안전성 부족**
```xml
<!-- 컴파일 시점에 오류 발견 못 함 -->
<select id="selectById">
    SELECT * FROM member WHERE id = #{idx}  <!-- id가 아니라 idx? -->
</select>
```

---

### 3.3.20 핵심 정리

#### MyBatis의 3가지 핵심

**1. SQL 중심 접근**
```
개발자: SQL 작성에 집중
MyBatis: JDBC 보일러플레이트 제거
```

**2. XML 분리**
```
Java: 비즈니스 로직
XML: SQL
→ 관심사의 분리
```

**3. 동적 SQL**
```
<if>, <choose>, <foreach> 등으로
조건에 따라 SQL 동적 생성
```





