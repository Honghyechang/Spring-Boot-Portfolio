# 03_데이터베이스_연동하기

<!--
# 첫 작성 (3.1 JDBC)
docs: [Ch03] 데이터베이스 연동 - JDBC 추가

# 다음 업데이트 (3.2, 3.3 추가)
docs: [Ch03] 데이터베이스 연동 - Spring Data JDBC, MyBatis 추가

# 마지막 완료 (3.4, 3.5 추가)
docs: [Ch03] 데이터베이스 연동 - JPA, MongoDB 추가 및 완료

-->

## 📌 학습 목표
스프링부트에서 데이터베이스에 접근하는 다양한 방법을 이해하고, 각 방식의 특징과 사용법을 익힌다.

---

## 목차

- [3.1 JDBC](#31-jdbc)
- [3.2 Spring Data JDBC](#32-spring-data-jdbc) 
- [3.3 MyBatis](#33-mybatis) 
- [3.4 JPA](#34-jpa) 
- [3.5 MongoDB](#35-mongodb) 

---

## 3.1 JDBC

### 3.1.1 JDBC란?

**JDBC (Java Database Connectivity)** 는 Java 애플리케이션에서 데이터베이스에 접근하기 위한 **표준 API**입니다.

#### JDBC의 구성 요소

```
[Java 애플리케이션]
      ↓
[JDBC API] ← Java가 제공하는 표준 인터페이스
      ↓
[JDBC Driver] ← 각 DB 벤더가 제공하는 구현체
      ↓
[데이터베이스 (MySQL, Oracle, PostgreSQL 등)]
```

| 구성 요소 | 제공자 | 역할 |
|----------|-------|------|
| **JDBC API** | Java (Oracle) | 데이터베이스 접근을 위한 표준 인터페이스 정의 |
| **JDBC Driver** | 각 DB 벤더 (MySQL, Oracle 등) | JDBC API의 실제 구현체 |
| **데이터베이스** | DB 벤더 | 실제 데이터 저장 및 관리 |

#### JDBC Driver의 역할

**JDBC Driver**는 Java 애플리케이션과 특정 데이터베이스 간의 **통신을 담당하는 브리지(다리)** 역할을 합니다.

- MySQL JDBC Driver: `mysql-connector-j`
- PostgreSQL JDBC Driver: `postgresql`
- Oracle JDBC Driver: `ojdbc`

**비유**:
```
JDBC API = USB 규격 (표준 인터페이스)
JDBC Driver = USB 케이블 (제조사별 구현)
데이터베이스 = USB 장치
```

#### 왜 JDBC가 필요한가?

**문제 상황**:
- 데이터베이스마다 통신 방식이 다름
- MySQL, Oracle, PostgreSQL 등 각각 다른 방식으로 접근

**JDBC의 해결**:
- **표준화된 인터페이스 제공**
- 개발자는 JDBC API만 사용
- 데이터베이스 변경 시 Driver만 교체하면 됨

```java
// MySQL이든 Oracle이든 코드는 동일!
Connection conn = DriverManager.getConnection(url, user, password);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM member");
```

---

### 3.1.2 데이터베이스 초기 설정

#### DBeaver를 통한 데이터 초기화

**실습 환경**:
- 데이터베이스: MySQL 8.4
- 관리 도구: DBeaver Community 25.2.2
- 데이터베이스명: `mydb`
- 사용자: `myuser` / 비밀번호: `mypass`

#### SQL 스크립트

```sql
-- ========================================
-- 1. 데이터베이스 생성
-- ========================================
-- mydb라는 이름의 데이터베이스 공간을 생성합니다.
-- IF NOT EXISTS: 이미 존재하면 생략 (에러 방지)
CREATE DATABASE IF NOT EXISTS mydb;

-- ========================================
-- 2. 사용자 생성 및 인증
-- ========================================
-- myuser 계정을 생성합니다.
-- @'%': 모든 호스트(IP)에서 접속 허용
-- IDENTIFIED BY 'mypass': 비밀번호를 mypass로 설정
CREATE USER IF NOT EXISTS 'myuser'@'%' IDENTIFIED BY 'mypass';

-- ========================================
-- 3. 권한 부여
-- ========================================
-- myuser가 mydb 데이터베이스의 모든 객체(테이블, 뷰 등)에 대해
-- 모든 권한(SELECT, INSERT, UPDATE, DELETE, CREATE, DROP 등)을 가지도록 설정
GRANT ALL ON mydb.* TO 'myuser'@'%';

-- ========================================
-- 4. 데이터베이스 선택
-- ========================================
USE mydb;

-- ========================================
-- 5. 테이블 생성
-- ========================================
CREATE TABLE IF NOT EXISTS member(
    id INTEGER AUTO_INCREMENT PRIMARY KEY,  -- 자동 증가 기본키
    name VARCHAR(128) NOT NULL,             -- 이름 (필수)
    email VARCHAR(256) NOT NULL,            -- 이메일 (필수)
    age INTEGER                             -- 나이 (선택)
);

-- ========================================
-- 6. 데이터 삽입
-- ========================================
INSERT INTO member(name, email, age) VALUES ('김우현', 'kimwoo@spring.co.kr', 10);
INSERT INTO member(name, email, age) VALUES ('홍혜창', 'hyechang@spring.co.kr', 20);
INSERT INTO member(name, email, age) VALUES ('윤서준', 'Seojunyoon@spring.co.kr', 22);
INSERT INTO member(name, email, age) VALUES ('김민수', 'minsusu@spring.co.kr', 30);

-- ========================================
-- 7. 데이터 조회 (확인)
-- ========================================
SELECT * FROM member;
```

#### SQL 명령어 설명

| 명령어 | 역할 | 설명 |
|-------|------|------|
| `CREATE DATABASE` | 데이터베이스 생성 | 데이터를 저장할 논리적 공간 생성 |
| `CREATE USER` | 사용자 계정 생성 | 데이터베이스 접속 계정 생성 |
| `GRANT` | 권한 부여 | 특정 사용자에게 DB 작업 권한 부여 |
| `USE` | 데이터베이스 선택 | 작업할 데이터베이스 지정 |
| `CREATE TABLE` | 테이블 생성 | 데이터를 저장할 테이블 구조 정의 |
| `INSERT INTO` | 데이터 삽입 | 테이블에 레코드 추가 |
| `SELECT` | 데이터 조회 | 테이블의 데이터 검색 |

#### 데이터 확인

```
+----+----------+-------------------------+------+
| id | name     | email                   | age  |
+----+----------+-------------------------+------+
|  1 | 김우현   | kimwoo@spring.co.kr     |   10 |
|  2 | 홍혜창   | hyechang@spring.co.kr   |   20 |
|  3 | 윤서준   | Seojunyoon@spring.co.kr |   22 |
|  4 | 김민수   | minsusu@spring.co.kr    |   30 |
+----+----------+-------------------------+------+
```

---

### 3.1.3 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    
    // MySQL JDBC Driver
    implementation 'com.mysql:mysql-connector-j:9.2.0'
    
    // Lombok (코드 자동 생성)
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 |
|-------|------|
| `spring-boot-starter` | 스프링부트 기본 기능 |
| `mysql-connector-j:9.2.0` | **MySQL JDBC Driver** (핵심!) |
| `lombok` | Getter, Setter 등 자동 생성 |

> ⚠️ **중요**: `mysql-connector-j`를 추가해야 MySQL과 통신할 수 있는 JDBC Driver가 프로젝트에 포함됩니다!

**JDBC Driver 포함 확인**:
```
프로젝트 구조
└─ External Libraries
   └─ com.mysql:mysql-connector-j:9.2.0
      └─ com.mysql.cj.jdbc.Driver ← JDBC Driver 클래스
```

---

### 3.1.4 엔티티 클래스 작성

**Member.java**:
```java
package kr.ac.hansung.cse.databasesample;

import lombok.*;

/**
 * Member 엔티티 클래스
 * - 데이터베이스의 member 테이블과 매핑되는 Java 객체
 * - Lombok을 사용하여 반복 코드 최소화
 */
@AllArgsConstructor  // 모든 필드를 매개변수로 받는 생성자 자동 생성
@ToString            // toString() 메서드 자동 생성
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### Lombok 애노테이션

| 애노테이션 | 생성 코드 |
|-----------|----------|
| `@AllArgsConstructor` | `public Member(Long id, String name, String email, Integer age) { ... }` |
| `@ToString` | `public String toString() { return "Member(id=1, name=김우현, ...)"; }` |

---

### 3.1.5 JDBC를 사용한 데이터베이스 연동

#### 전체 코드

**DatabaseSampleApplication.java**:
```java
package kr.ac.hansung.cse.databasesample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.sql.*;

@SpringBootApplication
public class DatabaseSampleApplication {

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        
        SpringApplication.run(DatabaseSampleApplication.class, args);

        // ========================================
        // 1. JDBC Driver 로딩
        // ========================================
        /*
         * Class.forName()의 역할:
         * - JDBC Driver 클래스를 JVM 메모리에 로드
         * - 로드된 Driver는 DriverManager에 자동 등록됨
         * - DriverManager가 MySQL 접속 방법을 알게 됨
         * 
         * "com.mysql.cj.jdbc.Driver":
         * - mysql-connector-j 라이브러리에 포함된 MySQL JDBC Driver 클래스
         * - 이 클래스가 JDBC API를 실제로 구현함
         * 
         * 참고: JDBC 4.0 이후로는 자동 로딩되지만, 명시적 표현을 위해 작성
         */
        Class.forName("com.mysql.cj.jdbc.Driver");

        // ========================================
        // 2. 데이터베이스 연결
        // ========================================
        /*
         * DriverManager.getConnection()의 역할:
         * - 실제 데이터베이스와의 연결(Connection) 객체 생성
         * 
         * 첫 번째 매개변수 (JDBC URL):
         * "jdbc:mysql://localhost:3306/mydb"
         *  ──── ───── ───────── ──── ────
         *   │     │       │       │     └─ 데이터베이스 이름
         *   │     │       │       └─ 포트 번호 (MySQL 기본: 3306)
         *   │     │       └─ 서버 주소 (localhost = 내 컴퓨터)
         *   │     └─ 데이터베이스 종류 (MySQL)
         *   └─ JDBC 프로토콜
         * 
         * 두 번째 매개변수: 사용자 이름 (myuser)
         * 세 번째 매개변수: 비밀번호 (mypass)
         */
        Connection connection = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/mydb",
            "myuser",
            "mypass"
        );

        // ========================================
        // 3. SQL 쿼리 준비
        // ========================================
        /*
         * PreparedStatement의 역할:
         * - SQL 쿼리를 데이터베이스에 미리 전송
         * - 실행 가능한 상태로 준비 (컴파일)
         * - SQL Injection 방지 (매개변수 바인딩 시)
         * 
         * "select * from member":
         * - member 테이블의 모든 컬럼(*), 모든 행 조회
         */
        PreparedStatement preparedStatement = connection.prepareStatement(
            "select * from member"
        );

        // ========================================
        // 4. 쿼리 실행
        // ========================================
        /*
         * executeQuery()의 역할:
         * - SELECT 쿼리 실행 (데이터 조회)
         * - 결과를 ResultSet 객체로 반환
         * 
         * ResultSet:
         * - 쿼리 결과를 담고 있는 객체
         * - 커서(cursor)를 사용하여 한 행씩 접근
         */
        ResultSet resultSet = preparedStatement.executeQuery();

        // ========================================
        // 5. 결과 처리
        // ========================================
        /*
         * while (resultSet.next()):
         * - 다음 행으로 커서 이동
         * - 더 이상 행이 없으면 false 반환 (반복 종료)
         * 
         * resultSet.getLong("id"):
         * - 현재 행의 "id" 컬럼 값을 Long 타입으로 가져옴
         * 
         * resultSet.getString("name"):
         * - 현재 행의 "name" 컬럼 값을 String 타입으로 가져옴
         * 
         * resultSet.getInt("age"):
         * - 현재 행의 "age" 컬럼 값을 Integer 타입으로 가져옴
         */
        while (resultSet.next()) {
            Member member = new Member(
                resultSet.getLong("id"),
                resultSet.getString("name"),
                resultSet.getString("email"),
                resultSet.getInt("age")
            );
            System.out.println(member);
        }

        // ========================================
        // 6. 연결 종료
        // ========================================
        /*
         * connection.close()의 역할:
         * - 데이터베이스 연결 해제
         * - 리소스(메모리, 네트워크) 반환
         * - 반드시 호출해야 함 (리소스 누수 방지)
         * 
         * 권장: try-with-resources 사용
         */
        connection.close();
    }
}
```

#### 실행 결과

```
Member(id=1, name=김우현, email=kimwoo@spring.co.kr, age=10)
Member(id=2, name=홍혜창, email=hyechang@spring.co.kr, age=20)
Member(id=3, name=윤서준, email=Seojunyoon@spring.co.kr, age=22)
Member(id=4, name=김민수, email=minsusu@spring.co.kr, age=30)
```

---

### 3.1.6 JDBC 동작 과정 상세 분석

#### 1단계: Driver 로딩

```java
Class.forName("com.mysql.cj.jdbc.Driver");
```

**내부 동작**:
```
1. JVM이 "com.mysql.cj.jdbc.Driver" 클래스 파일 로드
2. Driver 클래스의 static 초기화 블록 실행
3. Driver 객체가 DriverManager에 자동 등록
4. DriverManager: "MySQL과 통신하는 방법을 알게 되었다!"
```


#### 2단계: Connection 생성

```java
Connection connection = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "myuser",
    "mypass"
);
```

**내부 동작**:
```
1. DriverManager가 등록된 Driver들을 순회
2. URL이 "jdbc:mysql"로 시작 → MySQL Driver 선택
3. MySQL Driver가 실제 연결 시도
   - TCP 소켓 연결 (localhost:3306)
   - 인증 확인 (myuser/mypass)
   - mydb 데이터베이스 선택
4. Connection 객체 반환
```

**Connection 객체의 역할**:
- 데이터베이스와의 **세션(Session)** 을 나타냄
- 이 연결을 통해 SQL을 실행하고 결과를 받음

#### 3단계: Statement 생성 및 실행

```java
PreparedStatement preparedStatement = connection.prepareStatement(
    "select * from member"
);
ResultSet resultSet = preparedStatement.executeQuery();
```

**내부 동작**:
```
1. SQL 문자열을 MySQL 서버로 전송
2. MySQL이 SQL을 파싱(분석)하고 실행 계획 수립
3. 쿼리 실행
4. 결과를 ResultSet으로 반환
   (네트워크를 통해 Java 애플리케이션으로 전송)
```

#### 4단계: 결과 처리

```java
while (resultSet.next()) {
    // 데이터 읽기
}
```

**ResultSet의 구조**:
```
커서 위치 (처음에는 첫 행 이전)
    ↓
[Before First] ← resultSet.next() 호출 전
[Row 1] id=1, name=김우현, ...  ← resultSet.next() → true
[Row 2] id=2, name=홍혜창, ...  ← resultSet.next() → true
[Row 3] id=3, name=윤서준, ...  ← resultSet.next() → true
[Row 4] id=4, name=김민수, ...  ← resultSet.next() → true
[After Last] ← resultSet.next() → false (반복 종료)
```

---

### 3.1.7 JDBC의 문제점

#### 문제 1: 반복적인 코드

```java
// 매번 작성해야 하는 코드
Connection conn = DriverManager.getConnection(...);
PreparedStatement stmt = conn.prepareStatement(...);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
    // 매핑 코드
}
conn.close();
```

#### 문제 2: 수동 매핑

```java
// 컬럼과 객체 필드를 수동으로 매핑
Member member = new Member(
    rs.getLong("id"),
    rs.getString("name"),
    rs.getString("email"),
    rs.getInt("age")
);
```

#### 문제 3: 리소스 관리

```java
// close()를 깜빡하면 리소스 누수!
connection.close();  // 반드시 호출해야 함
```

#### 문제 4: 예외 처리

```java
// 체크 예외(Checked Exception) 처리 필요
throws ClassNotFoundException, SQLException
```

**이러한 문제들을 해결하기 위해 등장한 것이:**
- Spring Data JDBC (3.2)
- MyBatis (3.3)
- JPA (3.4)

---


## 3.2 Spring Data JDBC

### 3.2.1 Spring Data JDBC란?

**Spring Data JDBC**는 JDBC의 반복적인 코드를 제거하고, 개발자가 **비즈니스 로직에만 집중**할 수 있도록 도와주는 추상화 레이어입니다.

#### JDBC의 문제점을 해결하는 방법

| 문제점 | JDBC | Spring Data JDBC |
|-------|------|-----------------|
| Driver 로딩 | `Class.forName()` 필요 | 자동 처리 |
| Connection 관리 | 매번 생성/종료 | **커넥션 풀** 자동 관리 |
| SQL 작성 | 직접 작성 | 메서드 이름으로 자동 생성 |
| 결과 매핑 | `ResultSet` 수동 매핑 | 객체 자동 매핑 |
| 예외 처리 | Checked Exception | Runtime Exception |
| 리소스 정리 | 수동 `close()` | 자동 정리 |

> ⚠️ **중요**: Spring Data JDBC는 JDBC Driver를 사용하지 않는 것이 아닙니다! MySQL Connector 같은 JDBC Driver를 **더 편리하게 사용**하도록 감싸주는 역할을 합니다.

#### Spring Data JDBC의 핵심 개념

```
[개발자]
    ↓ (Repository 인터페이스만 정의)
[Spring Data JDBC]
    ↓ (보일러플레이트 코드 자동 생성)
[JDBC Driver (mysql-connector-j)]
    ↓
[MySQL 데이터베이스]
```

**보일러플레이트 코드(Boilerplate Code)**: 반복적으로 작성해야 하는 지루한 코드

---

### 3.2.2 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    // Spring Data JDBC (핵심!)
    implementation 'org.springframework.boot:spring-boot-starter-data-jdbc'
    
    // MySQL JDBC Driver (여전히 필요!)
    runtimeOnly 'com.mysql:mysql-connector-j'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 | 필수 여부 |
|-------|------|----------|
| `spring-boot-starter-data-jdbc` | Spring Data JDBC 기능 제공 | ✅ 필수 |
| `mysql-connector-j` | MySQL과 통신하는 JDBC Driver | ✅ 필수 |
| `lombok` | 코드 간소화 | 권장 |

> **핵심**: `spring-boot-starter-data-jdbc`는 JDBC를 대체하는 것이 아니라, JDBC를 더 쉽게 사용하도록 도와주는 도구입니다!

---

### 3.2.3 데이터베이스 연결 설정

#### application.properties

**src/main/resources/application.properties**:
```properties
spring.application.name=springdatajbc

# ========================================
# 데이터베이스 연결 설정 (DataSource)
# ========================================
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass

# ========================================
# JDBC 로그 레벨 설정 (디버깅용)
# ========================================
logging.level.org.springframework.jdbc=DEBUG
```

#### 설정 항목 설명

| 속성 | 설명 | 예시 값 |
|-----|------|---------|
| `spring.datasource.url` | 데이터베이스 연결 URL | `jdbc:mysql://localhost:3306/mydb` |
| `spring.datasource.username` | 데이터베이스 사용자 이름 | `myuser` |
| `spring.datasource.password` | 데이터베이스 비밀번호 | `mypass` |
| `logging.level.org.springframework.jdbc` | JDBC 실행 로그 레벨 | `DEBUG` (SQL 쿼리 확인용) |

#### JDBC vs Spring Data JDBC 설정 비교

**JDBC (이전)**:
```java
// 매번 코드로 작성
Class.forName("com.mysql.cj.jdbc.Driver");
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "myuser",
    "mypass"
);
```

**Spring Data JDBC (현재)**:
```properties
# 설정 파일에 한 번만 작성
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
```

> **장점**: 설정 파일만 수정하면 모든 코드에 자동 적용! 환경별(개발/운영) 설정 파일 분리 가능!

---

### 3.2.4 엔티티 클래스 작성

#### Member 엔티티

**Member.java**:
```java
package com.example.springdatajbc;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.Id;
import org.springframework.data.relational.core.mapping.Table;

@Table
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Member {
    
    @Id
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### 애노테이션 설명

##### @Table

**역할**: 이 클래스가 데이터베이스 테이블과 매핑됨을 선언

**자동 매핑 규칙**:
- 클래스 이름 → 테이블 이름 (카멜 케이스 → 스네이크 케이스)
- `Member` 클래스 → `member` 테이블
- `HyechangMember` 클래스 → `hyechang_member` 테이블

**명시적 지정**:
```java
@Table("custom_table_name")  // 테이블 이름이 규칙과 다를 때
public class Member { ... }
```

**테이블 매핑 과정**:
```
[Java 클래스]           [데이터베이스]
Member 클래스     →     member 테이블
├─ id (Long)      →     id (BIGINT)
├─ name (String)  →     name (VARCHAR)
├─ email (String) →     email (VARCHAR)
└─ age (Integer)  →     age (INT)
```

##### @Id

**역할**: Primary Key(기본 키) 필드 지정

```java
@Id
private Long id;
```

- Spring Data JDBC가 이 필드를 기준으로 레코드 식별
- `save()` 시 `id`가 `null`이면 INSERT, 값이 있으면 UPDATE
- 자동 생성(AUTO_INCREMENT)된 값을 자동으로 받아옴

##### @Column (선택 사항)

**역할**: 필드명과 컬럼명이 다를 때 매핑

```java
@Column("user_name")
private String name;  // name 필드 → user_name 컬럼
```

**기본 매핑 규칙**:
- 필드명과 컬럼명이 같으면 생략 가능
- 카멜 케이스 → 스네이크 케이스 자동 변환
- `userName` → `user_name`

##### Lombok 애노테이션

| 애노테이션 | 생성 코드 |
|-----------|----------|
| `@Data` | `@Getter` + `@Setter` + `@ToString` + `@EqualsAndHashCode` + `@RequiredArgsConstructor` |
| `@Builder` | 빌더 패턴 코드 생성 |
| `@AllArgsConstructor` | 모든 필드를 매개변수로 받는 생성자 |
| `@NoArgsConstructor` | 기본 생성자 (매개변수 없음) |

---

### 3.2.5 Repository 인터페이스 작성

#### MemberRepository 인터페이스

**MemberRepository.java**:
```java
package com.example.springdatajbc;

import org.springframework.data.jdbc.repository.query.Query;
import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface MemberRepository extends CrudRepository<Member, Long> {
    
    // 메서드 이름 기반 쿼리 (자동 생성)
    List<Member> findByName(String name);
    List<Member> findByEmail(String email);
    List<Member> findByNameContaining(String name);
    
    // 조건 결합
    List<Member> findByEmailAndName(String email, String name);
    List<Member> findByEmailOrName(String email, String name);
    
    // 비교 연산
    List<Member> findByAgeGreaterThan(int age);
    List<Member> findByAgeLessThan(int age);
    List<Member> findByAgeBetween(int min, int max);
    
    // 커스텀 쿼리 (직접 작성)
    @Query("SELECT * FROM member WHERE name = :username AND age >= :max")
    List<Member> hyechangQuery(String username, int max);
}
```

---

### 3.2.6 Repository 핵심 개념

#### 1. @Repository와 빈 생성

**@Repository의 정체**:
```java
@Repository
public interface MemberRepository extends CrudRepository<Member, Long> {
    // 인터페이스인데 어떻게 빈 객체가 되는가?
}
```

**@Repository = @Component의 특수한 형태**:

| 애노테이션 | 역할 | 계층 |
|-----------|------|------|
| `@Component` | 범용 스프링 빈 | - |
| `@Repository` | 데이터 접근 계층 | Persistence Layer |
| `@Service` | 비즈니스 로직 계층 | Service Layer |
| `@Controller` | 프레젠테이션 계층 | Presentation Layer |

> **핵심**: 모두 `@Component`이지만, **역할을 명확히 하기 위해** 세분화된 것입니다!

#### 2. 인터페이스가 빈 객체가 되는 원리 (프록시 패턴)

**문제**: 인터페이스는 객체를 만들 수 없는데?

**해결**: Spring이 **프록시 객체**를 자동 생성!

```
애플리케이션 시작 시:

1. Spring이 @Repository를 발견
2. MemberRepository 인터페이스 분석
3. 이 인터페이스를 구현하는 클래스를 런타임에 자동 생성 (프록시)
4. 프록시 객체를 빈으로 등록
5. 다른 곳에서 주입 시 프록시 객체 제공
```

**프록시 객체의 역할**:
```java
// Spring이 런타임에 자동으로 생성하는 코드 (개념적 표현)
public class MemberRepositoryImpl implements MemberRepository {
    
    @Override
    public <S extends Member> S save(S entity) {
        // entity.getId()가 null이면 INSERT
        // entity.getId()가 있으면 UPDATE
        // SQL 자동 생성 및 실행
    }
    
    @Override
    public Optional<Member> findById(Long id) {
        // SELECT * FROM member WHERE id = ? 실행
        // ResultSet → Member 객체 자동 매핑
    }
    
    // 기타 메서드들도 자동 구현...
}
```

#### 3. CrudRepository의 제네릭

```java
public interface MemberRepository extends CrudRepository<Member, Long>
                                                        ────────  ────
                                                        엔티티    PK 타입
```

**제네릭 의미**:
- `<Member, Long>`: "Member 엔티티를 다루며, Primary Key는 Long 타입"
- Spring이 이 정보를 바탕으로 SQL 자동 생성

#### 4. CrudRepository 기본 메서드

**자동으로 제공되는 메서드**:

| 메서드 | 설명 | 생성 SQL |
|-------|------|----------|
| `save(entity)` | 저장 또는 수정 | `INSERT` 또는 `UPDATE` |
| `findById(id)` | ID로 조회 | `SELECT * FROM member WHERE id = ?` |
| `findAll()` | 전체 조회 | `SELECT * FROM member` |
| `existsById(id)` | 존재 여부 확인 | `SELECT COUNT(*) FROM member WHERE id = ?` |
| `count()` | 전체 개수 | `SELECT COUNT(*) FROM member` |
| `deleteById(id)` | ID로 삭제 | `DELETE FROM member WHERE id = ?` |
| `delete(entity)` | 엔티티 삭제 | `DELETE FROM member WHERE id = ?` |
| `deleteAll()` | 전체 삭제 | `DELETE FROM member` |

**save()의 동작 원리**:
```java
Member member = new Member();
member.setName("홍혜창");
memberRepository.save(member);  // id가 null → INSERT

member.setAge(30);
memberRepository.save(member);  // id가 있음 → UPDATE
```

---

### 3.2.7 쿼리 메서드 (Query Method)

#### 메서드 이름 기반 쿼리 생성

Spring Data JDBC는 **메서드 이름을 분석**하여 자동으로 SQL을 생성합니다.

#### 기본 구조

```
find...By... + 조건필드 + 비교연산자
 │    │        │          │
 │    │        │          └─ GreaterThan, LessThan 등
 │    │        └─ Name, Email, Age 등 (엔티티 필드명)
 │    └─ 조건 시작
 └─ 조회 작업 (find, get, read 모두 동일)
```

#### 주요 키워드

##### 1. 필드 일치

```java
List<Member> findByName(String name);
// SQL: SELECT * FROM member WHERE name = ?

List<Member> findByEmail(String email);
// SQL: SELECT * FROM member WHERE email = ?
```

##### 2. 조건 결합 (AND, OR)

```java
// AND 조건 (모두 만족)
List<Member> findByEmailAndName(String email, String name);
// SQL: SELECT * FROM member WHERE email = ? AND name = ?

// OR 조건 (하나라도 만족)
List<Member> findByEmailOrName(String email, String name);
// SQL: SELECT * FROM member WHERE email = ? OR name = ?
```

##### 3. 문자열 검색

```java
// 포함 (LIKE '%...%')
List<Member> findByNameContaining(String name);
// SQL: SELECT * FROM member WHERE name LIKE %?%

// 시작 (LIKE '...%')
List<Member> findByNameStartingWith(String name);
// SQL: SELECT * FROM member WHERE name LIKE ?%

// 끝 (LIKE '%...')
List<Member> findByNameEndingWith(String name);
// SQL: SELECT * FROM member WHERE name LIKE %?
```

##### 4. 비교 연산

```java
// 보다 큼 (>)
List<Member> findByAgeGreaterThan(int age);
// SQL: SELECT * FROM member WHERE age > ?

// 보다 작음 (<)
List<Member> findByAgeLessThan(int age);
// SQL: SELECT * FROM member WHERE age < ?

// 이상 (>=)
List<Member> findByAgeGreaterThanEqual(int age);
// SQL: SELECT * FROM member WHERE age >= ?

// 이하 (<=)
List<Member> findByAgeLessThanEqual(int age);
// SQL: SELECT * FROM member WHERE age <= ?

// 범위 (BETWEEN)
List<Member> findByAgeBetween(int min, int max);
// SQL: SELECT * FROM member WHERE age BETWEEN ? AND ?
```

##### 5. NULL 체크

```java
// NULL인 경우
List<Member> findByEmailIsNull();
// SQL: SELECT * FROM member WHERE email IS NULL

// NULL이 아닌 경우
List<Member> findByEmailIsNotNull();
// SQL: SELECT * FROM member WHERE email IS NOT NULL
```

##### 6. 정렬 (OrderBy)

```java
// 오름차순
List<Member> findByNameOrderByAgeAsc(String name);
// SQL: SELECT * FROM member WHERE name = ? ORDER BY age ASC

// 내림차순
List<Member> findByNameOrderByAgeDesc(String name);
// SQL: SELECT * FROM member WHERE name = ? ORDER BY age DESC
```

##### 7. 개수 제한

```java
// 첫 번째 결과
Member findFirstByName(String name);
// SQL: SELECT * FROM member WHERE name = ? LIMIT 1

// 상위 N개
List<Member> findTop3ByOrderByAgeDesc();
// SQL: SELECT * FROM member ORDER BY age DESC LIMIT 3
```

#### 쿼리 메서드 키워드 정리표

| 키워드 | SQL | 예시 |
|-------|-----|------|
| `And` | `AND` | `findByNameAndEmail` |
| `Or` | `OR` | `findByNameOrEmail` |
| `Containing` | `LIKE %?%` | `findByNameContaining` |
| `StartingWith` | `LIKE ?%` | `findByNameStartingWith` |
| `EndingWith` | `LIKE %?` | `findByNameEndingWith` |
| `GreaterThan` | `>` | `findByAgeGreaterThan` |
| `LessThan` | `<` | `findByAgeLessThan` |
| `Between` | `BETWEEN` | `findByAgeBetween` |
| `IsNull` | `IS NULL` | `findByEmailIsNull` |
| `IsNotNull` | `IS NOT NULL` | `findByEmailIsNotNull` |
| `OrderBy...Asc` | `ORDER BY ... ASC` | `findByNameOrderByAgeAsc` |
| `OrderBy...Desc` | `ORDER BY ... DESC` | `findByNameOrderByAgeDesc` |
| `First` | `LIMIT 1` | `findFirstByName` |
| `Top3` | `LIMIT 3` | `findTop3ByOrderByAge` |

---

### 3.2.8 커스텀 쿼리 (@Query)

#### @Query 애노테이션

**복잡한 쿼리는 직접 작성**:

```java
@Query("SELECT * FROM member WHERE name = :username AND age >= :max")
List<Member> hyechangQuery(String username, int max);
```

#### 파라미터 바인딩

**`:변수명` 형식으로 바인딩**:

```java
@Query("SELECT * FROM member WHERE name = :username AND age >= :max")
List<Member> hyechangQuery(String username, int max);
                          ────────────  ────
                                │          └─ :max와 매핑
                                └─ :username과 매핑
```

#### @Query 사용 시나리오

| 상황 | 메서드 이름 | @Query |
|-----|-----------|--------|
| 단순 조건 | ✅ 권장 | ❌ 불필요 |
| 복잡한 JOIN | ❌ 불가능 | ✅ 필수 |
| 집계 함수 (SUM, AVG) | ❌ 제한적 | ✅ 권장 |
| 성능 최적화 필요 | ❌ 제한적 | ✅ 권장 |

**예시**:
```java
// 집계 쿼리
@Query("SELECT AVG(age) FROM member")
Double getAverageAge();

// JOIN 쿼리
@Query("SELECT m.* FROM member m JOIN orders o ON m.id = o.member_id WHERE o.status = :status")
List<Member> findMembersWithOrderStatus(String status);
```

---

### 3.2.9 애플리케이션 실행 코드

#### SpringJdbcApplication 클래스

**SpringJdbcApplication.java**:
```java
package com.example.springdatajbc;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

import java.util.Iterator;
import java.util.List;
import java.util.Optional;

@Component
@Slf4j
@RequiredArgsConstructor
public class SpringJdbcApplication implements ApplicationRunner {

    private final MemberRepository memberRepository;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 1. 데이터 생성 (Builder 패턴)
        Member member = Member.builder()
                              .name("hyechang")
                              .email("test@hyechang.ac.kr")
                              .age(25)
                              .build();
        
        // 2. 저장 (INSERT)
        memberRepository.save(member);

        // 3. 수정 (UPDATE)
        member.setAge(35);
        memberRepository.save(member);

        // 4. ID로 조회
        Optional<Member> getm = memberRepository.findById(1L);
        if (getm.isPresent()) {
            log.info(getm.get().toString());
        }

        // 5. 전체 조회
        Iterable<Member> iterable = memberRepository.findAll();
        Iterator<Member> iterator = iterable.iterator();
        while (iterator.hasNext()) {
            log.info(iterator.next().toString());
        }

        // 6. 커스텀 쿼리 메서드
        List<Member> members = memberRepository.findByAgeGreaterThan(3);
        log.info("--- findByAgeGreaterThan(3) 결과 시작 (총 {}개) ---", members.size());
        for (Member m : members) {
            log.info(m.toString());
        }
        log.info("--- findByAgeGreaterThan(3) 결과 종료 ---");
    }
}
```

---

### 3.2.10 주요 개념 상세 분석

#### 1. @RequiredArgsConstructor + final

**의존성 주입 방식**:

```java
@Component
@RequiredArgsConstructor
public class SpringJdbcApplication {
    
    private final MemberRepository memberRepository;
    // final = 반드시 초기화되어야 함
}
```

**내부 동작**:
```java
// Lombok이 자동 생성하는 코드
public SpringJdbcApplication(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
}
```

**Spring의 DI 과정**:
```
1. @Component 스캔 → SpringJdbcApplication 클래스 발견
2. 생성자 발견 (MemberRepository 필요)
3. 스프링 컨테이너에서 MemberRepository 빈 검색
4. 검색된 빈(프록시 객체)을 생성자에 주입
5. SpringJdbcApplication 빈 생성 완료
```

#### 2. ApplicationRunner 인터페이스

**역할**: 애플리케이션 시작 직후 자동 실행

```
애플리케이션 시작 순서:

1. @SpringBootApplication 실행
2. 컴포넌트 스캔 및 빈 생성
3. 의존성 주입
4. ApplicationRunner 구현체의 run() 자동 실행 ← 여기!
5. 애플리케이션 정상 구동
```

**사용 목적**:
- 초기 데이터 삽입
- 데이터베이스 마이그레이션
- 시스템 초기화 작업
- 테스트 데이터 생성

#### 3. save()의 동작 원리

```java
Member member = Member.builder().name("hyechang").age(25).build();
memberRepository.save(member);  // ① INSERT
// 이 시점에서 member.getId()에 자동 생성된 ID 할당됨

member.setAge(35);
memberRepository.save(member);  // ② UPDATE
```

**내부 판단 로직**:
```
save() 호출 시:

if (entity.getId() == null) {
    // INSERT
    INSERT INTO member (name, email, age) VALUES (?, ?, ?)
    // 자동 생성된 ID를 entity.setId()로 설정
} else {
    // UPDATE
    UPDATE member SET name=?, email=?, age=? WHERE id=?
}
```

#### 4. Optional 처리

```java
Optional<Member> getm = memberRepository.findById(1L);
if (getm.isPresent()) {
    log.info(getm.get().toString());
}
```

**Optional을 사용하는 이유**:
- `null` 체크를 명시적으로 강제
- `NullPointerException` 방지

**더 나은 방식**:
```java
memberRepository.findById(1L)
                .ifPresent(member -> log.info(member.toString()));

// 또는
Member member = memberRepository.findById(1L)
                                 .orElse(new Member());  // 없으면 기본값

// 또는
Member member = memberRepository.findById(1L)
                                 .orElseThrow(() -> new RuntimeException("회원 없음"));
```

---

### 3.2.11 커넥션 풀 (Connection Pool)

#### 커넥션 풀이란?

**문제 상황 (JDBC 직접 사용 시)**:
```java
// 요청 1
Connection conn1 = DriverManager.getConnection(...);  // 연결 생성 (느림!)
// 쿼리 실행
conn1.close();  // 연결 종료

// 요청 2
Connection conn2 = DriverManager.getConnection(...);  // 또 연결 생성 (느림!)
// 쿼리 실행
conn2.close();  // 또 연결 종료
```

**문제점**:
- 매번 DB 연결 생성/종료 → **시간 소요** (네트워크 통신, 인증 등)
- 동시 요청 많을 시 → **성능 저하**

**해결책: 커넥션 풀**

```
[커넥션 풀]
├─ Connection 1 (미리 생성, 대기 중)
├─ Connection 2 (미리 생성, 대기 중)
├─ Connection 3 (미리 생성, 대기 중)
└─ Connection 4 (미리 생성, 대기 중)

요청 시:
1. 풀에서 빌려옴 (빠름!)
2. 쿼리 실행
3. 풀에 반납 (close()가 아님!)
```

#### 커넥션 풀의 동작 원리

**1. 애플리케이션 시작 시**:

```
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
↓
Spring Boot가 이 설정을 읽고
↓
HikariCP (기본 커넥션 풀) 초기화
↓
mydb에 Connection 10개 미리 생성 (기본값)
↓
풀에 저장하고 대기
```

**2. Repository 메서드 호출 시**:

```java
memberRepository.save(member);
↓
Spring Data JDBC가 내부적으로:
1. 커넥션 풀에서 Connection 빌려옴 (대기 중인 것 사용)
2. SQL 실행: INSERT INTO member ...
3. Connection을 풀에 반납 (close()가 아님!)
```

**3. 애플리케이션 종료 시**:

```
애플리케이션 종료 시작
↓
Spring이 자동으로 커넥션 풀 종료
↓
풀의 모든 Connection들을 DB에 반환
↓
실제 연결 종료
```

#### 커넥션 풀 설정

**application.properties**:
```properties
# HikariCP 커넥션 풀 설정
spring.datasource.hikari.maximum-pool-size=10      # 최대 커넥션 수
spring.datasource.hikari.minimum-idle=5            # 최소 유지 커넥션 수
spring.datasource.hikari.connection-timeout=20000  # 커넥션 대기 시간 (ms)
spring.datasource.hikari.idle-timeout=300000       # 유휴 커넥션 유지 시간 (ms)
```

| 설정 | 설명 | 기본값 |
|-----|------|--------|
| `maximum-pool-size` | 풀이 유지할 최대 커넥션 수 | 10 |
| `minimum-idle` | 항상 유지할 최소 커넥션 수 | `maximum-pool-size`와 동일 |
| `connection-timeout` | 커넥션을 못 얻을 때 대기 시간 | 30000ms (30초) |
| `idle-timeout` | 사용하지 않는 커넥션 제거 시간 | 600000ms (10분) |

#### 커넥션 풀 동작 시나리오

**시나리오 1: 정상 상황**

```
초기 상태: 풀에 10개 커넥션 대기 중

요청 1: save() 호출
  ├─ 커넥션 1 빌려옴 (풀: 9개 남음)
  ├─ INSERT 실행
  └─ 커넥션 1 반납 (풀: 10개)

요청 2: findAll() 호출
  ├─ 커넥션 2 빌려옴 (풀: 9개 남음)
  ├─ SELECT 실행
  └─ 커넥션 2 반납 (풀: 10개)
```

**시나리오 2: 동시 요청 많은 경우**

```
풀: 10개 커넥션

동시에 15개 요청 발생
  ├─ 10개 요청: 즉시 커넥션 할당 ✅
  └─ 5개 요청: 대기 ⏳
      └─ connection-timeout(30초) 내에 반납되면 ✅
      └─ 30초 초과 시 에러 발생 ❌
```

#### JDBC vs 커넥션 풀 비교

| 항목 | JDBC 직접 사용 | 커넥션 풀 |
|-----|---------------|----------|
| 연결 생성 | 매번 생성 (느림) | 미리 생성 (빠름) |
| 연결 종료 | 매번 종료 | 풀에 반납 (재사용) |
| 성능 | 나쁨 | 좋음 ⭐ |
| 리소스 관리 | 수동 | 자동 ⭐ |
| 동시 요청 처리 | 비효율적 | 효율적 ⭐ |

#### 핵심 정리

**커넥션 풀의 3가지 핵심**:

1. **미리 생성**: 애플리케이션 시작 시 Connection들을 미리 만들어 둠
2. **재사용**: `close()`가 실제 종료가 아니라 풀에 반납 (다시 사용 가능)
3. **자동 관리**: Spring이 빌리기/반납 모두 자동 처리

**개발자가 신경 쓸 것**:
- ❌ Connection 생성/종료: Spring이 자동 처리
- ❌ 커넥션 풀 관리: HikariCP가 자동 처리
- ✅ 적절한 풀 크기 설정: 트래픽에 맞게 조정

**연결 대상**:
- 테이블이 아니라 **데이터베이스(`mydb`)** 에 연결
- 하나의 Connection으로 여러 테이블 작업 가능

---

### 3.2.12 메인 애플리케이션

**SpringdatajbcApplication.java**:
```java
package com.example.springdatajbc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class SpringdatajbcApplication {

    public static void main(String[] args) {
        SpringApplication.run(SpringdatajbcApplication.class, args);
    }
}
```

**실행 순서**:
```
1. main() 메서드 실행
2. @SpringBootApplication 처리
   ├─ 컴포넌트 스캔
   ├─ 자동 설정
   └─ 빈 생성
3. application.properties 읽기
   └─ 커넥션 풀 초기화 (DB 연결 10개 생성)
4. @Repository 인터페이스 발견
   └─ 프록시 객체 생성 및 빈 등록
5. @Component 발견
   └─ SpringJdbcApplication 빈 생성 및 의존성 주입
6. ApplicationRunner 구현체 실행
   └─ run() 메서드 호출
7. 애플리케이션 구동 완료
```

---



### 3.2.13 JDBC vs Spring Data JDBC 최종 비교

#### 코드 비교

**JDBC (3.1)**:
```java
// 1. Driver 로딩
Class.forName("com.mysql.cj.jdbc.Driver");

// 2. Connection 생성
Connection conn = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb", "myuser", "mypass"
);

// 3. Statement 생성
PreparedStatement stmt = conn.prepareStatement("SELECT * FROM member");

// 4. 쿼리 실행
ResultSet rs = stmt.executeQuery();

// 5. 결과 매핑
while (rs.next()) {
    Member member = new Member(
        rs.getLong("id"),
        rs.getString("name"),
        rs.getString("email"),
        rs.getInt("age")
    );
    System.out.println(member);
}

// 6. 리소스 정리
conn.close();
```

**Spring Data JDBC (3.2)**:
```java
// 설정 파일 (한 번만)
// spring.datasource.url=jdbc:mysql://localhost:3306/mydb

// Repository 인터페이스 (선언만)
public interface MemberRepository extends CrudRepository<Member, Long> {
    List<Member> findByAgeGreaterThan(int age);
}

// 사용
List<Member> members = memberRepository.findAll();
members.forEach(System.out::println);
```

**코드 라인 수**: 25줄 → 3줄 (약 88% 감소!)

#### 장단점 비교

| 특징 | JDBC | Spring Data JDBC |
|-----|------|-----------------|
| **코드 양** | 많음 ❌ | 적음 ✅ |
| **반복 코드** | 많음 ❌ | 없음 ✅ |
| **학습 곡선** | 낮음 ✅ | 중간 |
| **유연성** | 높음 ✅ | 중간 |
| **성능 최적화** | 쉬움 ✅ | 제한적 |
| **생산성** | 낮음 ❌ | 높음 ✅ |
| **커넥션 관리** | 수동 ❌ | 자동 ✅ |
| **SQL 가시성** | 명확 ✅ | 숨겨짐 (로그로 확인) |

---

### 3.2.14 Spring Data JDBC의 한계

#### 한계 1: 복잡한 연관관계

**문제**:
```java
// Member - Order 관계 (1:N)
// Spring Data JDBC에서는 복잡함
@Table
public class Member {
    @Id
    private Long id;
    private String name;
    
    // @ManyToOne 같은 애노테이션이 제한적
}
```
테이블과의 연관관계를 표현할 수 없다.

**해결**: JPA 사용 (3.4에서 학습) @Entity 와 @ManyToOne , @ManyToMany 등등 사용이 가능

#### 한계 2: DDL 자동 생성
DDL 자동 생성 미지원
Spring Data JDBC는 JPA의 핵심 편의 기능 중 하나인 DDL(Data Definition Language) 자동 생성 기능을 지원하지 않음


| 명령어 | 역할 | 
|-----|------|
| **CREATE TABLE** |테이블 생성 |
| **ALTER TABLE** | 테이블 수정|
| **DROP TABLE** | 테이블 삭제 |
| **TRUNCATE TABLE** | 테이블 데이터 삭제 |


📌 문제 상황 (수동 작업 필요)
자바 엔티티에 새로운 필드를 추가하더라도, 데이터베이스 테이블에는 수동으로 SQL을 작성하여 반영해야 합니다.

```java


// Java 엔티티에 필드 추가
@Table
public class Member {
    @Id
    private Long id;
    private String name;
    // ...
    private String phone;  // 👈 새로 추가!
}

```
SQL

- ❌ Spring Data JDBC는 이 부분을 자동으로 처리하지 않음!
- 테이블에 컬럼을 수동으로 추가해야 함!
ALTER TABLE member ADD COLUMN phone VARCHAR(255);
결과: 엔티티 수정 시 SQL을 직접 작성해야 하므로 테이블과 엔티티 불일치 가능성이 높아지고 개발 속도가 저하!

**해결**: JPA 사용 (3.4에서 학습) : JPA는 설정 파일을 통해 애플리케이션 시작 시 엔티티를 분석하여 자동으로 DDL을 실행합니다.
```
application.properties
spring.jpa.hibernate.ddl-auto=update
```


## 3.3 MyBatis

### 3.3.1 MyBatis란?

**MyBatis**는 SQL 중심의 데이터베이스 연동 프레임워크로, **개발자가 작성한 SQL과 Java 객체를 매핑**하는 데 특화되어 있습니다.

#### 핵심 개념

```
[개발자]
    ↓ (SQL 직접 작성)
[MyBatis]
    ↓ (JDBC 코드 자동 생성 및 결과 매핑)
[JDBC Driver]
    ↓
[데이터베이스]
```

**MyBatis의 역할**:
- 개발자: SQL만 작성
- MyBatis: Connection, PreparedStatement, ResultSet 등 **JDBC 보일러플레이트 코드 자동 처리**
- 결과를 Java 객체로 자동 매핑

---

### 3.3.2 Spring Data JDBC vs MyBatis

#### 근본적인 차이

| 특징 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **철학** | 도메인(객체) 중심 | **SQL 중심** ⭐ |
| **SQL 작성** | 메서드 이름 자동 생성 + @Query | **항상 직접 작성** (XML 또는 애노테이션) |
| **SQL 위치** | 인라인(@Query 내부) | **별도 XML 파일** (분리) |
| **동적 SQL** | 제한적 | **강력한 지원** ⭐ |
| **복잡한 쿼리** | 어려움 | **매우 유리** ⭐ |
| **성능 최적화** | 제한적 | **세밀한 제어 가능** ⭐ |
| **학습 곡선** | 낮음 | 중간 |
| **코드 양** | 적음 | 중간 (XML 작성) |

#### 왜 MyBatis를 사용하는가?

**Spring Data JDBC + @Query의 한계**:

```java
// Spring Data JDBC
@Query("SELECT * FROM member WHERE " +
       "(:name IS NULL OR name LIKE %:name%) AND " +
       "(:minAge IS NULL OR age >= :minAge) AND " +
       "(:maxAge IS NULL OR age <= :maxAge)")
List<Member> search(@Param("name") String name, 
                    @Param("minAge") Integer minAge,
                    @Param("maxAge") Integer maxAge);
```

**문제점**:
- ❌ SQL이 Java 문자열 안에 있어 가독성 저하
- ❌ 복잡한 동적 쿼리 작성 어려움
- ❌ SQL 문법 검증 불가 (컴파일 시점)
- ❌ SQL이 길어질수록 유지보수 어려움

**MyBatis의 해결**:

```xml
<!-- XML 파일에 SQL 분리 -->
<select id="search" resultType="Member">
    SELECT * FROM member
    <where>
        <if test="name != null">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="minAge != null">
            AND age >= #{minAge}
        </if>
        <if test="maxAge != null">
            AND age <= #{maxAge}
        </if>
    </where>
</select>
```

**장점**:
- ✅ SQL이 독립된 파일로 분리 (가독성 향상)
- ✅ **동적 SQL** 작성 용이 (`<if>`, `<choose>`, `<foreach>` 등)
- ✅ SQL 재사용 가능 (`<include>`)
- ✅ 조건에 따라 쿼리 자체가 변경 가능
- ✅ 복잡한 JOIN, 서브쿼리에 강함

---

### 3.3.3 MyBatis vs Spring Data JDBC 사용 시나리오

#### Spring Data JDBC 적합한 경우

```
✅ 단순한 CRUD 작업
✅ 단일 테이블 조회/수정
✅ 메서드 이름으로 자동 생성 가능한 쿼리
✅ 간단한 조건 검색

예: findByName(), findByAgeGreaterThan()
```

#### MyBatis 적합한 경우

```
✅ 복잡한 JOIN (3개 이상 테이블)
✅ 동적 SQL (조건에 따라 쿼리 변경)
✅ 복잡한 집계 쿼리 (GROUP BY, HAVING)
✅ 성능 최적화가 중요한 쿼리
✅ SQL에 익숙한 팀
✅ 대규모 프로젝트

예: 검색 기능, 통계 리포트, 복잡한 비즈니스 로직
```

#### 실전 예시

**요구사항**: 회원 검색 (이름, 나이 범위, 정렬 순서 - 모두 선택 사항)

**Spring Data JDBC (복잡함)**:
```java
// 모든 경우의 수를 메서드로 만들어야 함
List<Member> findByName(String name);
List<Member> findByAgeBetween(int min, int max);
List<Member> findByNameAndAgeBetween(String name, int min, int max);
// ... 조합이 늘어날수록 메서드 폭발!
```

**MyBatis (간단함)**:
```xml
<select id="search">
    SELECT * FROM member
    <where>
        <!--    <>태그 안에서는 #{} 이 아닌 바로 접근이 가능하다.     -->
        <if test="name != null">AND name LIKE #{name}</if>
        <if test="minAge != null">AND age >= #{minAge}</if>
        <if test="maxAge != null">AND age <= #{maxAge}</if>
    </where>
    <if test="orderBy != null">
        ORDER BY ${orderBy} ${direction}
    </if>
</select>
```

---

### 3.3.4 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    // MyBatis Spring Boot Starter
    implementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter:3.0.5'
    
    // H2 Database (내장 DB, 테스트용)
    runtimeOnly 'com.h2database:h2'
    
    // Lombok
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.mybatis.spring.boot:mybatis-spring-boot-starter-test:3.0.5'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 |
|-------|------|
| `mybatis-spring-boot-starter` | MyBatis를 Spring Boot에서 쉽게 사용하도록 통합 |
| `h2` | 내장형 데이터베이스 (애플리케이션 재시작 시 초기화) |

**H2 Database의 특징**:
- 애플리케이션에 **내장**되어 실행
- **메모리 기반** (재시작 시 데이터 초기화)
- **테스트 및 개발 환경**에 적합
- 별도 DB 서버 설치 불필요
- H2도 데이터베이스이므로 **JDBC Driver 필요** (h2 의존성이 Driver 포함)

---

### 3.3.5 설정 파일

**application.properties**:
```properties
spring.application.name=mybatisSample

# ========================================
# MyBatis 설정
# ========================================
# SQL이 작성된 XML 파일 위치
mybatis.mapper-locations=classpath:mapper/**/*.xml

# 스네이크 케이스 → 카멜 케이스 자동 변환
mybatis.configuration.map-underscore-to-camel-case=true

# ========================================
# H2 Database 초기화
# ========================================
# schema.sql, data.sql 자동 실행
spring.sql.init.mode=always
spring.sql.init.encoding=utf-8
```

#### 설정 설명

| 속성 | 설명 |
|-----|------|
| `mybatis.mapper-locations` | SQL Mapper XML 파일 경로 (`src/main/resources/mapper/` 하위 모든 XML) |
| `map-underscore-to-camel-case` | DB 컬럼 `user_name` → Java 필드 `userName` 자동 매핑 |
| `spring.sql.init.mode` | 애플리케이션 시작 시 초기화 스크립트 실행 (H2 테스트용) |

---

### 3.3.6 프로젝트 구조

```
src/main/java/com/example/mybatisSample/
├─ mapper/              # Mapper 인터페이스
│  ├─ MemberMapper.java
│  └─ ArticleMapper.java
├─ model/               # 도메인 모델 (Entity)
│  ├─ Member.java
│  └─ Article.java
└─ MyBatisApplication.java

src/main/resources/
├─ mapper/              # SQL Mapper XML
│  └─ MemberMapper.xml
├─ schema.sql           # 테이블 생성 SQL
├─ data.sql             # 초기 데이터 SQL
└─ application.properties
```

---

### 3.3.7 모델 클래스 (Model)

#### Member 클래스

**Member.java**:
```java
package com.example.mybatisSample.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### Article 클래스

**Article.java**:
```java
package com.example.mybatisSample.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    private Long id;
    private String title;
    private String description;
    private Date created;
    private Date updated;
    private Long memberId;
}
```

#### Spring Data JDBC와의 차이
#### 클래스의 정체성

| 프레임워크 | 클래스 역할 | 비유 |
|----------|-----------|------|
| **Spring Data JDBC** | **테이블 + 그릇** | 설계도 = 건물 |
| **MyBatis** | **그릇만** | 창고에서 물건 꺼내서 상자에 담기 |

---

#### Spring Data JDBC - "클래스 = 테이블"

```java
@Table  // ① 테이블 선언 + ② 결과 담는 그릇 (이중 역할!)
public class Member {
    @Id
    private Long id;
    private String name;
}
```

**특징**:
```
클래스 ←→ 테이블 (완전히 동일시)

- 클래스 구조 = 테이블 구조
- 클래스 변경 → 테이블 변경 필요
- 테이블 변경 → 클래스 변경 필요
```

**문제 발생**:
- ❌ **연관관계 표현 제한**: `@ManyToOne`, `@OneToMany` 부족
- ❌ **동기화 필요**: 테이블 ↔ 클래스 항상 일치해야 함
---

#### MyBatis - "클래스 = SQL 결과 담는 그릇"

```java
// 애노테이션 없음! 순수 그릇!
public class Member {
    private Long id;
    private String name;
}
```

```xml
<select id="selectAll" resultType="Member">
    SELECT id, name FROM member
</select>
```

**특징**:
```
SQL 실행 → ResultSet → 클래스(그릇)

- 테이블과 클래스 독립적
- SQL이 테이블 결정
- 클래스는 결과만 담음
```

**문제 해결**:
- ✅ **연관관계 자유**: SQL로 JOIN 마음대로
- ✅ **동기화 불필요**: 테이블 ↔ 클래스 독립적
- ✅ **필요한 컬럼만**: SELECT id, name만 가능

---

#### 비교표

| 항목 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **클래스 정체성** | 테이블 그 자체 | SQL 결과 그릇 |
| **테이블 매핑** | `@Table` 필수 | 애노테이션 불필요 |
| **테이블-클래스 관계** | 완전히 동일해야 함 | 독립적 |
| **연관관계** | ❌ 제한적 | ✅ SQL로 자유롭게 |
| **테이블 변경 시** | ❌ 클래스도 변경 | ✅ SQL만 변경 |
| **클래스 변경 시** | ❌ 테이블도 변경 | ✅ 영향 없음 |
| **동기화 문제** | ❌ 항상 발생 | ✅ 없음 |

---

#### 실전 예시

##### 시나리오: 테이블에 phone 컬럼 추가

**데이터베이스**:
```sql
ALTER TABLE member ADD COLUMN phone VARCHAR(20);
```

**Spring Data JDBC**:
```java
@Table
public class Member {
    @Id private Long id;
    private String name;
    private String phone;  // ❌ 필수 추가! (안 하면 문제)
}
```

**MyBatis**:
```java
// ✅ 클래스 그대로 사용 가능!
public class Member {
    private Long id;
    private String name;
    // phone 없어도 됨!
}
```

```xml
<!-- ✅ 필요할 때만 SELECT -->
<select id="selectAll" resultType="Member">
    SELECT id, name FROM member  <!-- phone 안 가져와도 OK -->
</select>

<!-- phone 필요한 경우만 별도 쿼리 -->
<select id="selectWithPhone" resultType="MemberWithPhone">
    SELECT id, name, phone FROM member
</select>
```

---

##### 시나리오: Member-Order 연관관계

**Spring Data JDBC**:
```java
@Table
public class Member {
    @Id private Long id;
    private String name;
    
    // ❌ 연관관계 표현이 제한적
    // private List<Order> orders;
}
```

**MyBatis**:
```java
// 그냥 그릇!
public class Member {
    private Long id;
    private String name;
}

public class MemberWithOrders {
    private Long id;
    private String name;
    private List<Order> orders;  // ✅ 자유롭게 구성
}
```

```xml
<!-- ✅ SQL로 자유롭게 JOIN -->
<select id="selectMemberWithOrders" resultType="MemberWithOrders">
    SELECT 
        m.id, m.name,
        o.id as order_id, o.product_name
    FROM member m
    LEFT JOIN orders o ON m.id = o.member_id
    WHERE m.id = #{id}
</select>
```

---

#### 핵심 요약

**Spring Data JDBC**:
```
@Table = "나는 member 테이블이면서 동시에 그릇이야!"

장점: 간단한 CRUD 자동화
단점: 테이블 = 클래스 (강제), 연관관계 약함, 동기화 필요
```

**MyBatis**:
```
클래스 = "나는 그냥 그릇이야! 테이블은 SQL이 결정해!"

장점: 테이블-클래스 독립, 연관관계 자유, 복잡한 쿼리 강력
단점: SQL 직접 작성 필요
```

**결론**:
- Spring Data JDBC의 **한계 (연관관계, 동기화)**는 MyBatis에서 **애초에 발생하지 않음**
- 하지만 MyBatis는 모든 SQL을 직접 작성해야 하는 번거로움 존재


### 3.3.8 Mapper 인터페이스

#### @Mapper 애노테이션

**역할**: 이 인터페이스가 MyBatis의 SQL 매핑 인터페이스임을 선언

```java
@Mapper  // MyBatis가 인식
public interface MemberMapper {
    List<Member> selectAll();
}
```

**Spring의 처리**:
```
1. @Mapper 스캔
2. 프록시 객체 자동 생성 (구현체)
3. 스프링 빈으로 등록
4. 다른 클래스에서 주입 가능
```

**Spring Data JDBC와 비교**:

| 프레임워크 | 애노테이션 | 역할 |
|----------|-----------|------|
| Spring Data JDBC | `@Repository` | 데이터 접근 계층 |
| MyBatis | `@Mapper` | SQL 매핑 인터페이스 |

> **공통점**: 둘 다 인터페이스만 정의하면 Spring이 구현체를 자동 생성!

---

### 3.3.9 XML 기반 SQL 매핑

#### MemberMapper 인터페이스

**MemberMapper.java**:
```java
package com.example.mybatisSample.mapper;

import com.example.mybatisSample.model.Member;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Param;

import java.util.List;
import java.util.Optional;

@Mapper
public interface MemberMapper {
    List<Member> selectAll();
    Optional<Member> selectById(@Param("id") Long id);
    Optional<Member> selectByEmail(@Param("email") String email);
    List<Member> selectAllOrderByAgeAsc();
    List<Member> selectAllOrderBy(@Param("order") String order, @Param("dir") String dir);
    List<Member> selectByNameLike(@Param("name") String name);
    int selectCount();
    int insert(@Param("member") Member member);
    int update(@Param("member") Member member);
    int delete(@Param("member") Member member);
    int deleteById(@Param("id") Long id);
    int deleteAll();
}
```

#### @Param 애노테이션

**역할**: 메서드 매개변수에 이름을 부여하여 XML/애노테이션 SQL에서 참조

```java
Optional<Member> selectByEmail(@Param("email") String email);
                               ─────────────
                                     ↓
                               XML에서 #{email}로 참조
```

**사용 예시**:
```java
// 단일 파라미터
selectById(@Param("id") Long id)
// XML: #{id}

// 객체 파라미터
insert(@Param("member") Member member)
// XML: #{member.name}, #{member.email}

// 복수 파라미터
selectAllOrderBy(@Param("order") String order, @Param("dir") String dir)
// XML: #{order}, #{dir}
```

---

### 3.3.10 MemberMapper.xml

**src/main/resources/mapper/MemberMapper.xml**:
```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.example.mybatisSample.mapper.MemberMapper">

    <!-- 전체 조회 -->
    <select id="selectAll" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member
    </select>

    <!-- ID로 조회 -->
    <select id="selectById" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE id = #{id}
    </select>

    <!-- 이메일로 조회 -->
    <select id="selectByEmail" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE email = #{email}
    </select>

    <!-- 나이 오름차순 정렬 -->
    <select id="selectAllOrderByAgeAsc" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member ORDER BY age ASC
    </select>

    <!-- 동적 정렬 -->
    <select id="selectAllOrderBy" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member ORDER BY ${order} ${dir}
    </select>

    <!-- 이름 LIKE 검색 -->
    <select id="selectByNameLike" resultType="com.example.mybatisSample.model.Member">
        SELECT * FROM member WHERE name LIKE #{name}
    </select>

    <!-- 개수 조회 -->
    <select id="selectCount" resultType="int">
        SELECT COUNT(*) FROM member
    </select>

    <!-- 삽입 (자동 생성 키 반환) -->
    <insert id="insert" useGeneratedKeys="true" keyProperty="member.id" keyColumn="id">
        INSERT INTO member(name, email, age) 
        VALUES (#{member.name}, #{member.email}, #{member.age})
    </insert>

    <!-- 수정 -->
    <update id="update">
        UPDATE member 
        SET name = #{member.name}, email = #{member.email}, age = #{member.age} 
        WHERE id = #{member.id}
    </update>

    <!-- 삭제 (객체) -->
    <delete id="delete">
        DELETE FROM member WHERE id = #{member.id}
    </delete>

    <!-- 삭제 (ID) -->
    <delete id="deleteById">
        DELETE FROM member WHERE id = #{id}
    </delete>

    <!-- 전체 삭제 -->
    <delete id="deleteAll">
        DELETE FROM member
    </delete>

</mapper>
```

---

### 3.3.11 XML 태그 상세 설명

#### 기본 구조

| 태그 | 역할 | 필수 속성 |
|-----|------|----------|
| `<mapper>` | 루트 태그 | `namespace` |
| `<select>` | SELECT 쿼리 | `id`, `resultType` |
| `<insert>` | INSERT 쿼리 | `id` |
| `<update>` | UPDATE 쿼리 | `id` |
| `<delete>` | DELETE 쿼리 | `id` |

#### namespace

```xml
<mapper namespace="com.example.mybatisSample.mapper.MemberMapper">
```

**역할**: 이 XML이 어떤 Mapper 인터페이스와 연결될지 지정

**매핑 과정**:
```
1. MyBatis가 @Mapper 인터페이스 스캔
2. namespace와 인터페이스 경로 비교
3. 일치하면 XML과 인터페이스 연결
4. 메서드 호출 시 id와 일치하는 SQL 실행
```

#### id 속성

```xml
<select id="selectAll">
```

**역할**: Mapper 인터페이스의 메서드 이름과 **정확히 일치**해야 함

```java
// 인터페이스
List<Member> selectAll();

// XML
<select id="selectAll">  // 메서드명과 동일!
```

#### resultType

```xml
<select id="selectAll" resultType="com.example.mybatisSample.model.Member">
```

**역할**: SQL 실행 결과를 어떤 Java 타입으로 매핑할지 지정

**타입별 사용**:
```xml
<!-- 단일 객체 -->
<select resultType="com.example.mybatisSample.model.Member">

<!-- 리스트 (요소 타입 지정) -->
<select resultType="com.example.mybatisSample.model.Member">

<!-- 기본 타입 -->
<select resultType="int">
<select resultType="String">
<select resultType="Long">
```

---

### 3.3.12 파라미터 바인딩

#### #{} vs ${}

| 문법 | 설명 | SQL 변환 | 사용 |
|-----|------|---------|------|
| `#{파라미터}` | **PreparedStatement** (권장) | `?`로 치환 | 값 바인딩 |
| `${파라미터}` | **Statement** (주의) | 문자열 직접 삽입 | 테이블명, 컬럼명 |

#### #{} (권장) ⭐

```xml
<select id="selectById">
    SELECT * FROM member WHERE id = #{id}
</select>
```

**변환 과정**:
```
1. SQL: SELECT * FROM member WHERE id = ?
2. PreparedStatement 사용
3. id 값을 안전하게 바인딩
```

**장점**:
- ✅ **SQL Injection 방지**
- ✅ 자동 타입 변환
- ✅ null 처리 안전

#### ${} (주의!)

```xml
<select id="selectAllOrderBy">
    SELECT * FROM member ORDER BY ${order} ${dir}
</select>
```

**변환 과정**:
```
1. order = "name", dir = "ASC"
2. SQL: SELECT * FROM member ORDER BY name ASC
3. 문자열 직접 치환
```

**주의사항**:
- ❌ **SQL Injection 위험**
- ❌ 사용자 입력값에 사용 금지
- ✅ 테이블명, 컬럼명, ORDER BY 절에만 사용

**안전한 사용 예시**:
```java
// 컨트롤러에서 값 검증
String order = "name";  // 화이트리스트 검증
if (!List.of("name", "age", "email").contains(order)) {
    throw new IllegalArgumentException("잘못된 정렬 기준");
}
```

---

### 3.3.13 자동 생성 키 처리

#### useGeneratedKeys

```xml
<insert id="insert" useGeneratedKeys="true" keyProperty="member.id" keyColumn="id">
    INSERT INTO member(name, email, age) 
    VALUES (#{member.name}, #{member.email}, #{member.age})
</insert>
```

#### 속성 설명

| 속성 | 역할 |
|-----|------|
| `useGeneratedKeys="true"` | DB가 자동 생성한 키(AUTO_INCREMENT)를 가져옴 |
| `keyColumn="id"` | DB 테이블의 자동 생성 키 컬럼명 |
| `keyProperty="member.id"` | 생성된 키 값을 저장할 Java 객체 필드 |

#### 동작 과정

```java
Member member = Member.builder()
                      .name("홍혜창")
                      .email("test@example.com")
                      .age(25)
                      .build();

System.out.println(member.getId());  // null

memberMapper.insert(member);  // INSERT 실행

System.out.println(member.getId());  // 5 (DB에서 생성된 ID)
```

**내부 동작**:
```
1. INSERT SQL 실행
2. DB가 id = 5 자동 생성
3. MyBatis가 생성된 5를 가져옴
4. member.setId(5) 자동 호출
5. member 객체 재사용 가능
```

#### useGeneratedKeys 생략 시

```xml
<!-- useGeneratedKeys 없음 -->
<insert id="insert">
    INSERT INTO member(name, email, age) VALUES (#{member.name}, #{member.email}, #{member.age})
</insert>
```

```java
Member member = Member.builder().name("홍혜창").build();
memberMapper.insert(member);

System.out.println(member.getId());  // null (ID가 채워지지 않음)
```

**결과**:
- DB에는 레코드 정상 생성 (AUTO_INCREMENT 작동)
- Java 객체에는 ID가 채워지지 않음

#### 사용 시나리오

| 상황 | useGeneratedKeys 설정 | 이유 |
|-----|---------------------|------|
| **ID 재사용 필요** | ✅ 필수 | 생성된 ID로 후속 작업 필요 |
| **ID 재사용 불필요** | ❌ 생략 가능 | 단순 INSERT만 수행 |

**예시**:
```java
// 시나리오: 회원 가입 후 환영 이메일 발송
Member member = new Member("홍혜창", "test@example.com", 25);
memberMapper.insert(member);  // useGeneratedKeys="true"

// 생성된 ID로 환영 이메일 발송
emailService.sendWelcome(member.getId(), member.getEmail());
```

---

### 3.3.14 애노테이션 기반 SQL 매핑

#### ArticleMapper 인터페이스

**ArticleMapper.java**:
```java
package com.example.mybatisSample.mapper;

import com.example.mybatisSample.model.Article;
import org.apache.ibatis.annotations.*;

import java.util.List;
import java.util.Optional;

@Mapper
public interface ArticleMapper {
    
    @Select("SELECT * FROM article")
    List<Article> selectAll();
    
    @Select("SELECT * FROM article WHERE id = #{id}")
    Optional<Article> selectById(@Param("id") Long id);
    
    @Insert("INSERT INTO article(title, description, created, updated, member_id) " +
            "VALUES (#{article.title}, #{article.description}, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP, #{article.memberId})")
    @Options(useGeneratedKeys = true, keyColumn = "id", keyProperty = "article.id")
    int insert(@Param("article") Article article);
    
    @Update("UPDATE article SET title = #{title}, description = #{description}, updated = CURRENT_TIMESTAMP WHERE id = #{id}")
    int update(@Param("id") Long id, @Param("title") String title, @Param("description") String description);
    
    @Delete("DELETE FROM article WHERE id = #{id}")
    int deleteById(@Param("id") Long id);
}
```

#### 애노테이션 종류

| 애노테이션 | 역할 | SQL 종류 |
|-----------|------|----------|
| `@Select` | SELECT 쿼리 | 조회 |
| `@Insert` | INSERT 쿼리 | 삽입 |
| `@Update` | UPDATE 쿼리 | 수정 |
| `@Delete` | DELETE 쿼리 | 삭제 |
| `@Options` | 추가 옵션 (자동 생성 키 등) | INSERT |

#### XML vs 애노테이션 비교

**XML 방식**:
```xml
<!-- MemberMapper.xml -->
<select id="selectAll" resultType="Member">
    SELECT * FROM member
</select>
```

**애노테이션 방식**:
```java
// ArticleMapper.java
@Select("SELECT * FROM article")
List<Article> selectAll();
```

#### 언제 어떤 방식을 사용할까?

| 상황 | XML | 애노테이션 |
|-----|-----|-----------|
| **단순한 쿼리** | ❌ | ✅ 권장 |
| **복잡한 쿼리** | ✅ 권장 | ❌ |
| **동적 SQL** | ✅ 권장 | ❌ |
| **SQL 재사용** | ✅ 권장 | ❌ |
| **빠른 프로토타이핑** | ❌ | ✅ 권장 |

**실무 권장**:
- 복잡한 쿼리, 동적 SQL → **XML**
- 단순한 CRUD → **애노테이션**

---

### 3.3.15 컬럼명과 필드명 불일치 해결

#### 문제 상황

**데이터베이스**:
```sql
CREATE TABLE article (
    id BIGINT,
    title VARCHAR(255),
    content VARCHAR(1000),  -- Java 필드는 'description'
    member_id BIGINT
);
```

**Java 클래스**:
```java
public class Article {
    private Long id;
    private String title;
    private String description;  // DB 컬럼은 'content'
    private Long memberId;
}
```

#### 해결 방법

##### 방법 1: application.properties 설정 (권장) ⭐

```properties
mybatis.configuration.map-underscore-to-camel-case=true
```

**자동 변환**:
```
DB: member_id  → Java: memberId
DB: created_at → Java: createdAt
DB: user_name  → Java: userName
```

**장점**:
- ✅ 전역 설정 (한 번만 작성)
- ✅ 스네이크 케이스 ↔ 카멜 케이스 자동 변환
- ✅ 대부분의 불일치 문제 해결

**한계**:
- ❌ `content` ↔ `description` 같은 완전히 다른 이름은 해결 못 함

##### 방법 2: SQL AS 키워드 (선택적)

```sql
SELECT id, title, content AS description, member_id 
FROM article
```

**적용**:
```java
@Select("SELECT id, title, content AS description, member_id FROM article")
List<Article> selectAll();
```

**장점**:
- ✅ 간단한 경우 빠르게 해결

**단점**:
- ❌ 모든 SELECT 문에 반복 작성
- ❌ 유지보수 어려움

##### 방법 3: `<resultMap>` (완전한 제어) ⭐

**XML**:
```xml
<resultMap id="articleResult" type="com.example.mybatisSample.model.Article">
    <result column="content" property="description"/>
    <result column="member_id" property="memberId"/>
</resultMap>

<select id="selectAll" resultMap="articleResult">
    SELECT * FROM article
</select>

<select id="selectById" resultMap="articleResult">
    SELECT * FROM article WHERE id = #{id}
</select>
```

**재사용 가능**:
- 한 번 정의하면 여러 쿼리에서 `resultMap="articleResult"` 참조

**애노테이션**:
```java
@Results(id = "articleResult", value = {
    @Result(column = "content", property = "description"),
    @Result(column = "member_id", property = "memberId")
})
@Select("SELECT * FROM article")
List<Article> selectAll();

@ResultMap("articleResult")  // 재사용
@Select("SELECT * FROM article WHERE id = #{id}")
Optional<Article> selectById(@Param("id") Long id);
```

**사용 시점**:
- 첫 번째 쿼리: `@Results`로 정의
- 이후 쿼리: `@ResultMap`으로 재사용

**장점**:
- ✅ 완전한 커스텀 매핑 가능
- ✅ 재사용 가능
- ✅ 복잡한 매핑 처리 가능

**단점**:
- ❌ 코드가 길어짐

#### 권장 순서

```
1. map-underscore-to-camel-case=true (대부분 해결)
   ↓
2. 안 되면 AS 키워드 (간단한 경우)
   ↓
3. 여전히 안 되면 <resultMap> (복잡한 경우)
```

---

### 3.3.16 애플리케이션 실행

#### MyBatisApplication 클래스

**MyBatisApplication.java**:
```java
package com.example.mybatisSample;

import com.example.mybatisSample.mapper.ArticleMapper;
import com.example.mybatisSample.mapper.MemberMapper;
import com.example.mybatisSample.model.Article;
import com.example.mybatisSample.model.Member;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Slf4j
@RequiredArgsConstructor
@Component
public class MyBatisApplication implements ApplicationRunner {
    
    private final ArticleMapper articleMapper;
    private final MemberMapper memberMapper;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        
        // 1. 회원 수 조회
        int count = memberMapper.selectCount();
        log.info("count: {}", count);

        // 2. 이메일로 회원 조회
        Member member = memberMapper.selectByEmail("hyechang@spring.ac.kr")
                                     .orElseThrow();
        log.info("member: {}", member);

        // 3. 게시글 작성
        Article article = Article.builder()
                                 .title("제목입니다.")
                                 .description("내용입니다.")
                                 .memberId(member.getId())
                                 .build();
        
        int insert = articleMapper.insert(article);
        log.info("insert: {}", insert);
        log.info("생성된 게시글 ID: {}", article.getId());  // 자동 생성된 ID 출력
    }
}
```

#### 메인 클래스

**MybatisSampleApplication.java**:
```java
package com.example.mybatisSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class MybatisSampleApplication {

    public static void main(String[] args) {
        SpringApplication.run(MybatisSampleApplication.class, args);
    }
}
```

---

### 3.3.17 실행 결과 및 로그

#### 실행 결과 로그 출력

```
 :: Spring Boot ::                (v3.5.6)

2025-10-15T12:56:13.692+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : Starting MybatisSampleApplication using Java 21.0.8 with PID 32404 (C:\Users\ghddm\Desktop\SpringBoot\mybatisSample\build\classes\java\main started by ghddm in C:\Users\ghddm\Desktop\SpringBoot\mybatisSample)
2025-10-15T12:56:13.698+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : No active profile set, falling back to 1 default profile: "default"
2025-10-15T12:56:15.404+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2025-10-15T12:56:15.834+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.pool.HikariPool        : HikariPool-1 - Added connection conn0: url=jdbc:h2:mem:daa4c2b0-93b6-4052-8dca-ecd1ca6e5774 user=SA
2025-10-15T12:56:15.839+09:00  INFO 32404 --- [mybatisSample] [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2025-10-15T12:56:16.510+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.m.MybatisSampleApplication           : Started MybatisSampleApplication in 4.122 seconds (process running for 5.349)
2025-10-15T12:56:16.571+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : count: 4
2025-10-15T12:56:16.581+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : member: Member(id=1, name=홍혜창, email=hyechang@spring.ac.kr, age=10)
2025-10-15T12:56:16.589+09:00  INFO 32404 --- [mybatisSample] [           main] c.e.mybatisSample.MyBatisApplication     : insert: 1
2025-10-15T12:56:16.599+09:00  INFO 32404 --- [mybatisSample] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown initiated...
2025-10-15T12:56:16.603+09:00  INFO 32404 --- [mybatisSample] [ionShutdownHook] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Shutdown completed.
```

---

### 3.3.18 Spring Data JDBC vs MyBatis 최종 비교

#### 코드 비교

**Spring Data JDBC**:
```java
// Repository 인터페이스
public interface MemberRepository extends CrudRepository<Member, Long> {
    List<Member> findByEmail(String email);  // 메서드 이름으로 자동 생성
    
    @Query("SELECT * FROM member WHERE name LIKE :name")  // 복잡한 쿼리는 @Query
    List<Member> searchByName(@Param("name") String name);
}
```

**MyBatis**:
```java
// Mapper 인터페이스
@Mapper
public interface MemberMapper {
    Optional<Member> selectByEmail(@Param("email") String email);
    List<Member> searchByName(@Param("name") String name);
}
```

```xml
<!-- SQL은 XML에 분리 -->
<select id="selectByEmail">
    SELECT * FROM member WHERE email = #{email}
</select>

<select id="searchByName">
    SELECT * FROM member WHERE name LIKE #{name}
</select>
```

#### 특징 비교

| 특징 | Spring Data JDBC | MyBatis |
|-----|-----------------|---------|
| **SQL 자동 생성** | ✅ 메서드 이름 규칙 | ❌ 항상 직접 작성 |
| **SQL 위치** | Java 코드 내부 | **XML 파일 분리** ⭐ |
| **동적 SQL** | 제한적 | **강력한 지원** ⭐ |
| **복잡한 쿼리** | 어려움 | **매우 유리** ⭐ |
| **코드 양** | 적음 | 중간 (XML) |
| **학습 곡선** | 낮음 | 중간 |
| **SQL 제어** | 제한적 | **완전한 제어** ⭐ |
| **가독성** | 중간 | **높음** (SQL 분리) ⭐ |
| **테스트** | 쉬움 | 중간 |

---

### 3.3.19 MyBatis의 장단점

#### 장점

**1. SQL에 대한 완전한 제어** ⭐
```xml
<!-- 복잡한 JOIN도 자유롭게 -->
<select id="selectWithMember">
    SELECT a.*, m.name as member_name
    FROM article a
    INNER JOIN member m ON a.member_id = m.id
    WHERE a.created > #{startDate}
    ORDER BY a.created DESC
</select>
```

**2. 동적 SQL 강력** ⭐
```xml
<select id="search">
    SELECT * FROM member
    <where>
        <if test="name != null">
            AND name LIKE CONCAT('%', #{name}, '%')
        </if>
        <if test="minAge != null">
            AND age >= #{minAge}
        </if>
        <if test="maxAge != null">
            AND age <= #{maxAge}
        </if>
    </where>
    <if test="orderBy != null">
        ORDER BY ${orderBy} ${direction}
    </if>
</select>
```

**3. SQL 분리로 가독성 향상** ⭐
```
Java 코드: 비즈니스 로직만
XML 파일: SQL만

→ 관심사의 분리 (Separation of Concerns)
```

**4. 성능 최적화 용이**
- 필요한 컬럼만 선택 가능
- 복잡한 서브쿼리, WITH절 자유롭게 사용
- 인덱스 힌트 등 DB 특화 기능 활용

**5. SQL에 익숙한 팀에 적합**
- DBA가 작성한 최적화된 SQL 그대로 사용
- 기존 SQL 자산 재활용 가능

#### 단점

**1. 보일러플레이트 증가**
```java
// 메서드마다 SQL 작성 필요
@Select("SELECT * FROM member")
List<Member> selectAll();

@Select("SELECT * FROM member WHERE id = #{id}")
Optional<Member> selectById(@Param("id") Long id);
```

**2. 단순 CRUD도 직접 작성**
```xml
<!-- Spring Data JDBC는 자동인데... -->
<select id="findById">SELECT * FROM member WHERE id = #{id}</select>
<insert id="insert">INSERT INTO member(...) VALUES(...)</insert>
<update id="update">UPDATE member SET ... WHERE id = #{id}</update>
<delete id="delete">DELETE FROM member WHERE id = #{id}</delete>
```

**3. XML 파일 관리 부담**
- 인터페이스와 XML 파일 동기화 필요
- 메서드명 오타 시 런타임 에러

**4. 타입 안전성 부족**
```xml
<!-- 컴파일 시점에 오류 발견 못 함 -->
<select id="selectById">
    SELECT * FROM member WHERE id = #{idx}  <!-- id가 아니라 idx? -->
</select>
```

---

### 3.3.20 핵심 정리

#### MyBatis의 3가지 핵심

**1. SQL 중심 접근**
```
개발자: SQL 작성에 집중
MyBatis: JDBC 보일러플레이트 제거
```

**2. XML 분리**
```
Java: 비즈니스 로직
XML: SQL
→ 관심사의 분리
```

**3. 동적 SQL**
```
<if>, <choose>, <foreach> 등으로
조건에 따라 SQL 동적 생성
```



## 3.4 JPA

### 3.4.1 JPA (Java Persistence API)란?

**JPA**는 Java 애플리케이션에서 **객체와 데이터베이스 테이블을 매핑**하고 관리하는 **표준 인터페이스**입니다.

#### ORM (Object-Relational Mapping) - 핵심 개념

지금까지 배운 데이터베이스 접근 방식들과 JPA의 근본적인 차이는 **기준이 무엇인가**입니다.

| 방식 | 기준 | 접근 방법 |
|-----|------|----------|
| **JDBC** | 테이블 중심 | 테이블 구조 → SQL 작성 → 결과를 객체로 변환 |
| **Spring Data JDBC** | 테이블 중심 | 테이블과 객체 동기화 필수 |
| **MyBatis** | SQL 중심 | 최적화된 SQL 작성 → 결과를 객체로 매핑 |
| **JPA** | **객체 중심** | 객체 설계 → 매핑 정의 → SQL 자동 생성 |

**ORM의 철학**:
```
개발자: 객체(Object)를 설계하고 관리
    ↓
JPA: 객체와 테이블의 관계(Relational) 정의
    ↓
Hibernate: 매핑(Mapping) 기반 SQL 자동 생성 및 실행
    ↓
Database: 테이블에서 데이터 저장/조회
```

**핵심**: 테이블을 생각하지 않고 **객체만 생각**하면 된다!

---

#### JPA, Hibernate, Spring Data JPA의 관계

**문제**: JPA는 인터페이스일 뿐 구현체가 아닙니다.

**해결 방법**:

| 계층 | 역할 | 제공자 |
|-----|------|--------|
| **JPA (표준 인터페이스)** | ORM의 표준 명세 정의 | Oracle (Java 표준) |
| **Hibernate** | JPA의 실제 구현체 | 오픈소스 프로젝트 |
| **Spring Data JPA** | Hibernate를 Spring에서 쉽게 사용하도록 통합 | Spring |

**구조**:
```
개발자
  ↓
Spring Data JPA (편의 계층)
  ↓
Hibernate (구현체)
  ↓
JPA (표준 인터페이스)
  ↓
JDBC Driver
  ↓
Database
```

---

### 3.4.2 프로젝트 설정

#### 의존성 (build.gradle)

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    runtimeOnly 'com.mysql:mysql-connector-j'
    
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

**주요 의존성**:
- `spring-boot-starter-data-jpa`: Spring Data JPA + Hibernate 통합
- `mysql-connector-j`: MySQL JDBC Driver (JPA는 JDBC를 기반으로 동작)

---

#### 설정 파일 (application.properties)

```properties
spring.application.name=jpaHibernateSample

# 데이터베이스 연결 (MySQL)
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass

# DDL 관리 전략
spring.jpa.hibernate.ddl-auto=create

# SQL 로깅 활성화 (개발용)
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.highlight_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true
```

#### 설정 파일 상세 설명

##### `spring.jpa.hibernate.ddl-auto` - DDL 관리 전략

이 속성은 **Hibernate**의 기능으로, 애플리케이션 시작 시 엔티티 정의와 데이터베이스 스키마를 **어떻게 동기화**할지 결정합니다.

| 전략 | 동작 | 용도 |
|-----|------|------|
| **`create`** | 시작 시 기존 테이블 삭제(`DROP`) → 엔티티 기반 새로 생성(`CREATE`) | 개발 초기, 테스트 환경 |
| **`create-drop`** | `create`와 동일하게 생성 후, 애플리케이션 정상 종료 시 테이블 삭제 | 단위 테스트, 통합 테스트 |
| **`update`** | 기존 테이블 유지하며 엔티티와의 차이점만 반영 (컬럼 추가는 함, 삭제는 안 함) | 개발 환경 (데이터 유지) |
| **`validate`** | 데이터베이스 스키마와 엔티티 검증만 수행, DDL 작업 없음 | 스테이징, 운영 환경 |
| **`none`** | DDL 작업 완전히 수행 안 함 | 운영 환경 |

**운영 환경에서 `validate` 또는 `none` 사용 이유**:
```
운영 중인 데이터베이스는 고객 데이터, 거래 기록 등 매우 중요한 정보를 담고 있습니다.
자동 스키마 변경은 예측 불가능한 문제를 일으킬 수 있으므로,
테이블 구조를 개발자가 Migration 툴로 수동 관리합니다.
```

---

##### SQL 로깅 설정

```properties
spring.jpa.show-sql=true                          # SQL 출력 활성화
spring.jpa.properties.hibernate.format_sql=true   # SQL 줄바꿈 및 들여쓰기
spring.jpa.properties.hibernate.highlight_sql=true # 색상 강조 (IDE 지원 시)
spring.jpa.properties.hibernate.use_sql_comments=true # 쿼리 주석 추가
```

**목적**: 생성된 SQL을 보기 좋게 출력하여 **디버깅 및 테스트 효율성 향상**

---

### 3.4.3 엔티티 클래스 (Entity) - 가장 중요!

#### Member 엔티티

```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(
    name = "vip_table",
    indexes = {
        @Index(name = "idx_name", columnList = "display_name, age"),
        @Index(name = "idx_email", columnList = "primary_contact")
    }
)
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
public class Member {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "display_name", length = 2048, nullable = false, unique = true)
    private String name;
    
    @Column(name = "primary_contact")
    private String email;
    
    private Integer age;
    
    @Transient
    private String address;
}
```

---

#### 핵심 어노테이션 상세 설명

##### `@Entity` - 테이블 매핑 선언

```java
@Entity
public class Member { ... }
```

| 항목 | 설명 |
|-----|------|
| **역할** | 이 Java 클래스가 데이터베이스 테이블과 매핑되는 **엔티티(Entity)**임을 JPA에 선언 |
| **의미** | 클래스의 인스턴스 하나 = 테이블의 한 레코드(행) |
| **자동 처리** | Hibernate가 이 클래스를 기반으로 테이블 자동 생성 (DDL 설정에 따라) |

**Spring Data JDBC와의 비교**:

| 항목 | Spring Data JDBC | JPA |
|-----|-----------------|-----|
| **매핑 선언** | `@Table` | `@Entity` |
| **테이블 생성** | 스키마 자동 생성 미지원 | **DDL 자동 생성** ⭐ |
| **테이블-클래스 동기화** | 수동 (매번 일치시켜야 함) | **자동** (엔티티 기준) |
| **연관관계 표현** | 제한적 | **강력한 지원** ⭐ |

---

##### `@Table` - 테이블 상세 매핑

```java
@Table(
    name = "vip_table",
    indexes = {
        @Index(name = "idx_name", columnList = "display_name, age")
    }
)
```

| 속성 | 역할 |
|-----|------|
| **`name`** | 엔티티가 매핑될 테이블의 실제 이름 (생략 시 클래스 이름 사용) |
| **`indexes`** | 테이블에 생성할 인덱스 목록 |

##### `@Index` - 인덱스 정의

```java
@Index(name = "idx_name", columnList = "display_name, age")
```

| 속성 | 값 | 의미 |
|-----|-----|------|
| **`name`** | `"idx_name"` | DB에 생성될 인덱스의 이름 (관리 목적) |
| **`columnList`** | `"display_name, age"` | 인덱스를 구성할 **DB 컬럼명** (Java 필드명 아님!) |

**⚠️ 주의**: columnList에는 **반드시 `@Column(name="...")에 지정한 DB 컬럼명**을 사용해야 합니다.

**잘못된 예**:
```java
@Index(name = "idx_name", columnList = "name, age")  // ❌ Java 필드명 사용
```

**올바른 예**:
```java
@Index(name = "idx_name", columnList = "display_name, age")  // ✅ DB 컬럼명 사용
```

---

##### `@Id` - 기본 키 지정

```java
@Id
private Long id;
```

| 항목 | 설명 |
|-----|------|
| **역할** | 해당 필드를 데이터베이스 **기본 키(Primary Key)**로 지정 |
| **의미** | 각 레코드를 유일하게 식별하는 필드 |
| **필수** | 모든 `@Entity`는 반드시 하나의 `@Id`를 가져야 함 |

---

##### `@GeneratedValue` - ID 생성 전략

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

**역할**: 기본 키 값이 **자동으로 생성되는 방식**을 지정합니다.

| 전략 | `GenerationType` | ID 생성 주체 | 동작 순서 |
|-----|-----------------|-----------|---------|
| **IDENTITY** | `IDENTITY` | 데이터베이스 | 1. INSERT 실행 2. DB가 ID 생성 3. ID를 객체에 반영 |
| **SEQUENCE** | `SEQUENCE` | 데이터베이스 | 1. ID 미리 요청 2. ID를 객체에 반영 3. INSERT 실행 |
| **TABLE** | `TABLE` | JPA/애플리케이션 | 1. 관리 테이블 조회 2. ID 생성 3. INSERT 실행 |
| **AUTO** | `AUTO` | JPA (DB에 맞춰 선택) | DB 종류에 따라 `IDENTITY` 또는 `SEQUENCE` 자동 선택 |

**각 전략의 특징**:

- **IDENTITY**: MySQL, PostgreSQL에서 주로 사용. 간단하지만 ID 즉시 확보 불가
- **SEQUENCE**: Oracle, PostgreSQL에서 주로 사용. 배치 처리 최적화 가능
- **AUTO** (권장): 개발자가 DB 종류를 신경 쓸 필요 없음

**save() 호출 후 ID 자동 반영 예시**:

```java
Member member = Member.builder()
                      .name("혜창")
                      .email("hyechang@spring.ac.kr")
                      .age(20)
                      .build();

System.out.println(member.getId());  // null (아직 저장 안 됨)

memberRepository.save(member);       // INSERT 실행, ID 자동 생성 및 반영

System.out.println(member.getId());  // 1 (DB가 자동 생성한 ID 포함)
```

---

##### `@Column` - 컬럼 상세 매핑

```java
@Column(name = "display_name", length = 2048, nullable = false, unique = true)
private String name;
```

| 속성 | 값 | 역할 |
|-----|-----|------|
| **`name`** | `"display_name"` | Java 필드명과 DB 컬럼명을 다르게 지정 (Java: `name` → DB: `display_name`) |
| **`length`** | `2048` | VARCHAR 컬럼의 최대 길이 (생략 시 기본값 255) |
| **`nullable`** | `false` | `NOT NULL` 제약조건 (NULL 값 허용 안 함) |
| **`unique`** | `true` | `UNIQUE` 제약조건 (중복 값 허용 안 함) |

**생략 시 기본 동작**:
```java
private String email;  // @Column 생략

// 기본 매핑:
// - DB 컬럼명: email (필드명과 동일)
// - nullable: true (NULL 허용)
// - length: 255 (VARCHAR 기본값)
```

---

##### `@Transient` - 데이터베이스 매핑 제외

```java
@Transient
private String address;
```

| 항목 | 설명 |
|-----|------|
| **역할** | 해당 필드를 데이터베이스 매핑에서 제외 |
| **의미** | DB 테이블에 컬럼이 생성되지 않음 |
| **용도** | 임시 값, 계산된 값, 세션 정보 등 **메모리에만 필요한 데이터** |

**동작**:
```java
member.setAddress("서울시 강남구");  // 메모리에만 저장됨
memberRepository.save(member);      // address는 INSERT에 포함되지 않음

Member loaded = memberRepository.findById(1L).orElse(null);
System.out.println(loaded.getAddress());  // null (DB에서 로드한 것이므로)
```

---

#### 생성되는 DDL (SQL)

위 Member 엔티티로부터 자동 생성되는 테이블:

```sql
CREATE TABLE vip_table (
    age INTEGER,
    id BIGINT NOT NULL AUTO_INCREMENT,
    display_name VARCHAR(2048) NOT NULL,
    primary_contact VARCHAR(255),
    PRIMARY KEY (id),
    UNIQUE KEY (display_name),
    INDEX idx_name (display_name, age),
    INDEX idx_email (primary_contact)
) ENGINE=InnoDB;
```

---

### 3.4.4 JPA Auditing (리스너) - 자동 시간 기록

#### 개념

**리스너(Listener)**는 특정 **이벤트(Event)**가 발생하면 미리 정의된 **액션(Action)**을 자동으로 수행하는 메커니즘입니다.

**엔티티의 생명주기 이벤트**:

| 이벤트 | 시점 | 예시 |
|-------|------|------|
| **Persist** | 객체가 처음 저장될 때 | `save()` 호출 |
| **Update** | 객체가 변경될 때 | `save()` 재호출 |
| **Remove** | 객체가 삭제될 때 | `delete()` 호출 |

**JPA Auditing**: `Persist`와 `Update` 이벤트에 반응하여 **생성 시간, 수정 시간을 자동 기록**

---

#### 단계 1: Auditing 활성화 (메인 애플리케이션)

```java
package com.example.jpaHibernateSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

@SpringBootApplication
@EnableJpaAuditing
public class JpaHibernateSampleApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(JpaHibernateSampleApplication.class, args);
    }
}
```

**`@EnableJpaAuditing`의 역할**: 스프링에게 "엔티티 생명주기 이벤트를 감시하겠다"는 선언

---

#### 단계 2: 엔티티에 리스너 부착

```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
import java.time.LocalDateTime;

@Entity
@EntityListeners(AuditingEntityListener.class)
public class Article {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String content;
    
    @CreatedDate
    private LocalDateTime created;
    
    @LastModifiedDate
    private LocalDateTime updated;
}
```

| 어노테이션 | 역할 |
|-----------|------|
| **`@EntityListeners`** | "이 엔티티의 생명주기 이벤트를 `AuditingEntityListener`에게 전달하라" |
| **`@CreatedDate`** | Persist 이벤트 시 **현재 시각**을 자동 기록 (이후 변경 안 함) |
| **`@LastModifiedDate`** | Persist 이벤트와 Update 이벤트 시 **현재 시각**을 자동 기록 (매번 갱신) |

---

#### Auditing 동작 원리

```
1. @EnableJpaAuditing 활성화
   ↓
2. @EntityListeners(AuditingEntityListener.class) 감시 시작
   ↓
3. articleRepository.save(newArticle) 호출 (Persist 이벤트)
   ↓
4. AuditingEntityListener가 이벤트 감지
   ↓
5. @CreatedDate 필드에 현재 시각 주입
5. @LastModifiedDate 필드에 현재 시각 주입
   ↓
6. INSERT SQL 실행 (시간 정보 포함)
   ↓
7. 나중에 article.setTitle("변경") 후 save() 호출 (Update 이벤트)
   ↓
8. @LastModifiedDate만 갱신, @CreatedDate는 유지
   ↓
9. UPDATE SQL 실행
```

**예시**:

```java
Article article = Article.builder()
                         .title("첫 글")
                         .content("내용")
                         .build();

articleRepository.save(article);
// created: 2025-01-15 10:30:45
// updated: 2025-01-15 10:30:45

// 일주일 후...
article.setTitle("제목 수정");
articleRepository.save(article);
// created: 2025-01-15 10:30:45 (변경 안 됨)
// updated: 2025-01-22 14:15:20 (갱신됨)
```

---

### 3.4.5 Repository 인터페이스

#### MemberRepository

```java
package com.example.jpaHibernateSample.repository;

import com.example.jpaHibernateSample.Member;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    // 기본 CRUD 메서드는 JpaRepository가 제공
    // 필요에 따라 커스텀 메서드 추가
}
```

#### Spring Data JPA가 제공하는 기본 메서드

| 메서드 | 반환 타입 | 역할 |
|-------|---------|------|
| `save(entity)` | `T` | INSERT 또는 UPDATE |
| `findById(id)` | `Optional<T>` | ID로 조회 |
| `findAll()` | `List<T>` | 전체 조회 |
| `existsById(id)` | `boolean` | 존재 여부 확인 |
| `count()` | `long` | 전체 개수 |
| `deleteById(id)` | `void` | ID로 삭제 |
| `delete(entity)` | `void` | 엔티티 삭제 |
| `deleteAll()` | `void` | 전체 삭제 |

**코드 작성 없이 모두 자동 구현!**

---

#### MySQL vs H2 - 코드 변경 필요 없음!

**H2 사용 시**:
```gradle
runtimeOnly 'com.h2database:h2'
```

```properties
# spring.datasource.url 설정 불필요 (자동 생성)
# 자동으로 메모리 DB 사용
spring.jpa.hibernate.ddl-auto=create-drop
```

**MySQL 사용 시**:
```gradle
runtimeOnly 'com.mysql:mysql-connector-j'
```

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=myuser
spring.datasource.password=mypass
spring.jpa.hibernate.ddl-auto=create
```

**중요**: 설정 파일과 의존성만 변경하면 된다! **엔티티 코드는 그대로!**

---

### 3.4.6 기본 애플리케이션 실행

```java
package com.example.jpaHibernateSample;

import com.example.jpaHibernateSample.repository.MemberRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;

@Component
@RequiredArgsConstructor
@Slf4j
public class JpaApplication implements ApplicationRunner {
    
    private final MemberRepository memberRepository;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        memberRepository.save(
            Member.builder()
                  .name("hyechang")
                  .email("hyechang@spring.ac.kr")
                  .age(20)
                  .build()
        );
        
        memberRepository.save(
            Member.builder()
                  .name("woohyun")
                  .email("woohyun@spring.ac.kr")
                  .age(25)
                  .build()
        );
    }
}
```

**결과** (DBeaver에서 확인):
```
id | display_name | primary_contact          | age
1  | hyechang     | hyechang@spring.ac.kr    | 20
2  | woohyun      | woohyun@spring.ac.kr     | 25
```

**핵심**: **SQL을 한 줄도 작성하지 않았는데 데이터가 저장됨!** 이것이 JPA의 가장 큰 장점입니다.

---

### 3.4.7 쿼리 메서드 (Query Method)

Spring Data JPA는 **메서드 이름을 분석**하여 자동으로 JPQL을 생성하고 실행합니다. (Spring Data JDBC와 규칙이 동일합니다)

#### 기본 규칙

| 패턴 | 예시 | 생성되는 JPQL |
|-----|------|-------------|
| `findBy<필드>` | `findByName(String name)` | `select m from Member m where m.name = :name` |
| `findBy<필드>And<필드>` | `findByNameAndAge(String name, int age)` | `where m.name = :name and m.age = :age` |
| `findBy<필드>Or<필드>` | `findByNameOrEmail(String name, String email)` | `where m.name = :name or m.email = :email` |
| `findBy<필드>GreaterThan` | `findByAgeGreaterThan(int age)` | `where m.age > :age` |
| `findBy<필드>LessThan` | `findByAgeLessThan(int age)` | `where m.age < :age` |
| `findBy<필드>Between` | `findByAgeBetween(int min, int max)` | `where m.age between :min and :max` |
| `findBy<필드>Containing` | `findByNameContaining(String part)` | `where m.name like %:part%` |
| `findBy<필드>StartingWith` | `findByNameStartingWith(String prefix)` | `where m.name like :prefix%` |
| `findBy<필드>IsNull` | `findByEmailIsNull()` | `where m.email is null` |
| `findBy<필드>OrderBy<필드>Asc` | `findByAgeGreaterThanOrderByNameAsc(int age)` | `where m.age > :age order by m.name asc` |

#### MemberRepository 예시

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    List<Member> findByName(String name);
    
    List<Member> findByNameAndAge(String name, int age);
    
    List<Member> findByAgeGreaterThan(int age);
    
    List<Member> findByNameContaining(String name);
    
    List<Member> findByAgeBetween(int min, int max);
    
    Member findFirstByOrderByIdDesc();
}
```

---

### 3.4.8 정렬 (Sort)

#### 문제: 메서드 이름에 정렬 조건을 하드코딩?

```java
// 이런 식으로 만들어야 하나?
List<Member> findByAgeGreaterThanOrderByNameAsc(int age);
List<Member> findByAgeGreaterThanOrderByNameDesc(int age);
List<Member> findByAgeGreaterThanOrderByAgeAsc(int age);
// ... 모든 조합을 만들어야 함 ❌
```

#### 해결: Sort 객체로 동적 정렬

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    List<Member> findByAgeGreaterThan(int age, Sort sort);
    
    List<Member> findByNameContaining(String name, Sort sort);
}
```

#### Sort 객체 생성 및 사용

**방법 1: Sort.Order 배열 (다중 정렬 기준, 명시적)**

```java
Sort sort = Sort.by(
    Sort.Order.asc("name"),   // 1차: name 오름차순
    Sort.Order.desc("age")    // 2차: age 내림차순
);

List<Member> members = memberRepository.findByAgeGreaterThan(20, sort);
```

**방법 2: Sort.Direction과 properties (단일 방향)**

```java
Sort sort = Sort.by(
    Sort.Direction.DESC,  // 모든 필드를 내림차순으로
    "age", "name"         // age → name 순서로 정렬
);

List<Member> members = memberRepository.findByNameContaining("hyechang", sort);
```

**Sort 생성 요약**:
```java
// 정적 팩토리 메서드 Sort.by()를 사용
Sort sort = Sort.by(Sort.Order... orders);

// Sort.Order 생성
Sort.Order.asc("fieldName");    // 오름차순
Sort.Order.desc("fieldName");   // 내림차순
```

---

### 3.4.9 페이지네이션 (Pageable)

#### 문제: 전체 데이터를 한 번에 조회?

클라이언트 앱에서 수백만 개의 데이터를 한 번에 보여줄 수는 없습니다. **페이지 단위**로 나누어 전달하는 것이 효율적입니다.

#### 해결: Pageable 객체

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    Page<Member> findByNameContaining(String name, Pageable pageable);
}
```

#### Pageable 객체 생성

```java
// PageRequest.of(페이지번호, 페이지크기, 정렬정보)
Pageable pageable = PageRequest.of(0, 20, Sort.by(Sort.Direction.DESC, "id"));

Page<Member> page = memberRepository.findByNameContaining("hyechang", pageable);
```

#### Page 객체가 제공하는 정보

```java
page.getContent();          // List<Member> - 현재 페이지의 실제 데이터
page.getTotalElements();    // long - 조건을 만족하는 전체 데이터 개수
page.getTotalPages();       // int - 전체 페이지 수
page.getNumber();           // int - 현재 페이지 번호 (0부터 시작)
page.getSize();             // int - 페이지당 데이터 개수
page.hasNext();             // boolean - 다음 페이지 존재 여부
page.hasPrevious();         // boolean - 이전 페이지 존재 여부
page.isFirst();             // boolean - 첫 페이지인지 여부
page.isLast();              // boolean - 마지막 페이지인지 여부
```

**사용 예시**:

```java
Pageable pageable = PageRequest.of(0, 10);  // 첫 번째 페이지, 10개 항목
Page<Member> page = memberRepository.findAll(pageable);

System.out.println("전체 데이터: " + page.getTotalElements());
System.out.println("전체 페이지: " + page.getTotalPages());
System.out.println("현재 페이지: " + page.getNumber());
System.out.println("데이터 개수: " + page.getContent().size());

page.getContent().forEach(member -> System.out.println(member));
```

---

### 3.4.10 동적 쿼리 (Example)

#### 문제: 모든 검색 조건 조합의 메서드 필요?

```java
// 이름만 검색
List<Member> findByName(String name);

// 나이만 검색
List<Member> findByAge(int age);

// 이름과 나이
List<Member> findByNameAndAge(String name, int age);

// 이름, 나이, 이메일
List<Member> findByNameAndAgeAndEmail(String name, int age, String email);

// ... 모든 조합을 작성해야 함 ❌
```

#### 해결: Example 객체 (동적 조건)

```java
@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    // Example을 받는 기본 메서드는 JpaRepository가 제공함
    <S extends Member> List<S> findAll(Example<Member> example);
}
```

#### Example 사용 방법

```java
// 1단계: 검색 조건이 담긴 엔티티 객체 생성 (probe)
Member probe = Member.builder()
                     .name("hyechang")
                     .age(20)
                     .build();

// 2단계: 매칭 방식 정의
ExampleMatcher matcher = ExampleMatcher.matchingAll();  // AND 조건

// 3단계: Example 생성
Example<Member> example = Example.of(probe, matcher);

// 4단계: 쿼리 실행
List<Member> results = memberRepository.findAll(example);
```

#### ExampleMatcher 옵션

| 메서드 | 조건 | 설명 |
|-------|------|------|
| `matchingAll()` | AND | probe의 모든 필드가 일치해야 함 (기본값) |
| `matchingAny()` | OR | probe의 필드 중 하나라도 일치하면 됨 |

**예시**:

```java
// AND 조건: name이 "hyechang" AND age가 20
Member probe = Member.builder().name("hyechang").age(20).build();
ExampleMatcher matcher = ExampleMatcher.matchingAll();
List<Member> results = memberRepository.findAll(Example.of(probe, matcher));

// OR 조건: name이 "hyechang" OR age가 20
ExampleMatcher matcher = ExampleMatcher.matchingAny();
List<Member> results = memberRepository.findAll(Example.of(probe, matcher));
```

#### Example의 한계

**지원하지 않는 기능**:
- 크기 비교 (`>`, `<`, `>=`, `<=`)
- LIKE 패턴 (기본 LIKE는 지원, 상세한 패턴 설정은 제한적)

**복잡한 조건이 필요하면 JPQL 사용**

---

### 3.4.11 JPQL (Java Persistence Query Language) - 가장 중요!

#### JPQL이란?

**JPQL**은 SQL과 유사하지만, **데이터베이스 테이블이 아닌 Java 엔티티 객체를 대상**으로 작성하는 쿼리 언어입니다.

| 항목 | SQL | JPQL |
|-----|-----|------|
| **대상** | 테이블, 컬럼 | 엔티티 클래스, 필드 |
| **쿼리 예** | `SELECT * FROM member WHERE name = ?` | `SELECT m FROM Member m WHERE m.name = :name` |
| **DB 의존성** | 높음 (DB 방언이 다르면 수정 필요) | 낮음 (JPQL은 동일, Hibernate가 DB별 SQL로 변환) |

**핵심**: 테이블을 생각하지 말고 **엔티티 객체**를 생각해야 합니다!

---

#### JPQL 문법 기본 규칙

##### 1. 엔티티 이름과 별칭

```java
// ✅ 올바른 방식
@Query("SELECT m FROM Member m WHERE m.name = :name")
Member findByName(@Param("name") String name);

// ❌ 잘못된 방식 (테이블 이름 사용)
@Query("SELECT * FROM member WHERE name = :name")

// ❌ 잘못된 방식 (별칭 없음)
@Query("SELECT Member FROM Member WHERE Member.name = :name")
```

**규칙**:
- 엔티티 이름은 **대소문자 구분** (`Member` ≠ `member`)
- **반드시 별칭 사용** (예: `Member m`) - AS는 생략 가능 (`Member as m`)

##### 2. 필드 참조

```java
@Query("SELECT m.name, m.email FROM Member m")  // 필드 사용
@Query("SELECT m FROM Member m")                 // 엔티티 전체 사용
```

---

#### JPQL 반환 타입 규칙 (가장 헷갈리는 부분!)

JPQL의 SELECT 절에 **무엇을 선택하느냐**에 따라 반환 타입이 결정됩니다.

##### 패턴 1: 엔티티 전체 반환

```java
@Query("SELECT m FROM Member m WHERE m.id = :id")
Member findByIdJpql(@Param("id") Long id);

@Query("SELECT m FROM Member m")
List<Member> findAllJpql();
```

**동작**:
```
SELECT m    → Member 엔티티 전체 선택
결과: Member 객체 또는 List<Member>
```

---

##### 패턴 2: 필드 목록 반환 (Object[] 배열)

```java
@Query("SELECT m.name, m.email, m.age FROM Member m")
List<Object[]> findMemberInfo();
```

**동작**:
```
SELECT m.name, m.email, m.age
       ↓       ↓        ↓
     [0]     [1]     [2]

결과: List<Object[]>
각 요소: Object[] = {이름, 이메일, 나이}

사용:
List<Object[]> results = findMemberInfo();
for (Object[] row : results) {
    String name = (String) row[0];
    String email = (String) row[1];
    int age = (int) row[2];
}
```

---

##### 패턴 3: DTO 객체로 직접 변환 (NEW 연산자)

```java
// DTO 클래스 정의 (반드시 생성자 필요)
public class MemberDto {
    public MemberDto(String name, String email, int age) {
        this.name = name;
        this.email = email;
        this.age = age;
    }
}

// JPQL - NEW 연산자 사용
@Query("SELECT new com.example.jpaHibernateSample.MemberDto(m.name, m.email, m.age) FROM Member m")
List<MemberDto> findMemberDtos();
```

**규칙**:
- DTO 클래스는 **생성자의 파라미터 순서**와 **JPQL SELECT 항목 순서**가 정확히 일치해야 함
- 패키지명.클래스명 **전체 경로** 사용

**사용**:
```java
List<MemberDto> results = findMemberDtos();
for (MemberDto dto : results) {
    System.out.println(dto.getName());
    System.out.println(dto.getEmail());
}
```

---

#### JPQL 파라미터 바인딩

```java
// `:이름` 방식 (권장)
@Query("SELECT m FROM Member m WHERE m.name = :name AND m.age = :age")
List<Member> findByNameAndAge(@Param("name") String name, @Param("age") int age);

// `?1, ?2` 위치 방식 (비권장)
@Query("SELECT m FROM Member m WHERE m.name = ?1 AND m.age = ?2")
List<Member> findByNameAndAgePos(String name, int age);
```

**권장 이유**: `:name` 방식이 가독성이 좋고 유지보수가 용이합니다.

---

#### 복잡한 JPQL 분석 (LEFT JOIN, GROUP BY)

```java
@Query("SELECT m.name, m.email, COUNT(a.id) as articleCount " +
       "FROM Member m " +
       "LEFT JOIN Article a ON a.member = m " +
       "GROUP BY m " +
       "ORDER BY articleCount DESC")
List<Object[]> getMembersWithArticleCount();
```

**상세 분석**:

| 부분 | 설명 |
|-----|------|
| **`LEFT JOIN Article a ON a.member = m`** | Member 엔티티(m)를 기준으로 Article 엔티티(a)와 LEFT JOIN. 조건: Article의 member 필드가 현재 Member를 가리킴 |
| **`GROUP BY m`** | Member의 모든 필드(기본키 포함)를 기준으로 그룹화. (SQL의 `GROUP BY m.id`와 동일 의미) |
| **`COUNT(a.id)`** | 각 그룹의 Article 개수를 집계함수로 계산 |
| **`ORDER BY articleCount DESC`** | 게시글 많은 순서대로 내림차순 정렬 |

**반환 데이터 구조**:
```
Object[0] = "hyechang"      (m.name)
Object[1] = "hyechang@..."  (m.email)
Object[2] = 5               (COUNT(a.id) = 게시글 5개)

List<Object[]> = [
    {"hyechang", "hyechang@...", 5},
    {"woohyun", "woohyun@...", 3},
    {"other", "other@...", 1}
]

사용:
for (Object[] row : getMembersWithArticleCount()) {
    String name = (String) row[0];
    String email = (String) row[1];
    long count = (long) row[2];
}
```

---

#### SELECT 절의 규칙 (GROUP BY 사용 시)

JPQL도 SQL과 동일한 규칙을 따릅니다:

**SELECT에 올 수 있는 항목**:
- GROUP BY 기준이 되는 필드: `m.name`, `m.email` (그룹 기준이므로 그대로 사용 가능)
- 집계함수: `COUNT()`, `SUM()`, `AVG()`, `MAX()`, `MIN()` (필수 사용)

**SELECT에 올 수 없는 항목**:
- GROUP BY 기준이 아닌 필드 (예: `a.id` - 집계함수 없이 사용 불가)

---

### 3.4.12 JPQL을 통한 데이터 변경 (UPDATE, DELETE)

#### UPDATE

```java
@Modifying
@Transactional
@Query("UPDATE Member m SET m.age = :age WHERE m.id = :id")
int updateMemberAge(@Param("age") int age, @Param("id") Long id);
```

| 어노테이션 | 역할 |
|-----------|------|
| **`@Modifying`** | 이 쿼리가 SELECT가 아닌 데이터 변경 쿼리(UPDATE/DELETE)임을 선언 |
| **`@Transactional`** | 데이터 변경은 트랜잭션 내에서 실행되어야 하므로 필수 |

**속성** (간단히 알기):
- `clearAutomatically = true`: 쿼리 실행 후 영속성 컨텍스트 초기화
- `flushAutomatically = true`: 쿼리 실행 전 영속성 컨텍스트 동기화

---

#### DELETE

```java
@Modifying
@Transactional
@Query("DELETE FROM Member m WHERE m.age < :age")
int deleteYoungMembers(@Param("age") int age);
```

**반환값**: 영향받은 행의 개수 (int)

```java
int deleted = deleteYoungMembers(18);
System.out.println("삭제된 회원: " + deleted + "명");
```

---

### 3.4.13 Native SQL (네이티브 쿼리)

#### 필요한 경우

JPQL로는 표현 불가능한 데이터베이스 특화 기능이 필요할 때:
- MySQL의 `RAND()`, `GROUP_CONCAT()`
- Oracle의 `ROWNUM`
- 복잡한 윈도우 함수
- 성능 최적화된 특화 SQL

#### 사용 방법

```java
@Query(
    value = "SELECT * FROM member ORDER BY RAND() LIMIT :limit",
    nativeQuery = true
)
List<Member> findRandomMembers(@Param("limit") int limit);
```

| 속성 | 값 | 의미 |
|-----|-----|------|
| **`value`** | SQL 문자열 | 테이블명, 컬럼명 사용 (엔티티 아님) |
| **`nativeQuery`** | `true` | 이 쿼리를 JPQL이 아닌 **네이티브 SQL**로 처리 |

---

#### Native SQL과 JPQL 비교

| 항목 | JPQL | Native SQL |
|-----|------|-----------|
| **대상** | 엔티티, 필드 | 테이블, 컬럼 |
| **쿼리 예** | `SELECT m FROM Member m` | `SELECT * FROM member` |
| **DB 의존성** | 낮음 | 높음 (DB 방언에 따라 수정 필요) |
| **가독성** | 높음 | 낮음 |
| **성능 최적화** | 제한적 | 강력 |
| **특화 기능** | 불가능 | 가능 |

**권장사항**:
- 대부분의 쿼리는 **JPQL 사용**
- 성능이 중요하거나 DB 특화 기능 필요 시만 **Native SQL 사용**

---

### 3.4.14 완전한 Repository 예시

```java
package com.example.jpaHibernateSample.repository;

import com.example.jpaHibernateSample.Member;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
    
    // 1. 쿼리 메서드
    List<Member> findByName(String name);
    
    List<Member> findByNameAndAge(String name, int age);
    
    List<Member> findByAgeGreaterThan(int age);
    
    List<Member> findByNameContaining(String namePart);
    
    // 2. 정렬 사용
    List<Member> findByAgeGreaterThan(int age, org.springframework.data.domain.Sort sort);
    
    // 3. 페이지네이션
    Page<Member> findByNameContaining(String namePart, Pageable pageable);
    
    // 4. JPQL - 조회
    @Query("SELECT m FROM Member m WHERE m.name = :name")
    Optional<Member> findByNameJpql(@Param("name") String name);
    
    // 5. JPQL - 복잡한 쿼리
    @Query("SELECT m.name, COUNT(m.id) FROM Member m GROUP BY m.name")
    List<Object[]> countMembersByName();
    
    // 6. JPQL - UPDATE
    @Modifying
    @Transactional
    @Query("UPDATE Member m SET m.age = :age WHERE m.id = :id")
    int updateAge(@Param("age") int age, @Param("id") Long id);
    
    // 7. Native SQL
    @Query(value = "SELECT * FROM vip_table WHERE age > :age", nativeQuery = true)
    List<Member> findOlderMembers(@Param("age") int age);
}
```

---

### 3.4.15 쿼리 메서드 vs JPQL vs Native SQL 선택 기준

| 상황 | 추천 방법 | 이유 |
|-----|---------|------|
| 단순한 CRUD (findBy, save, delete) | 쿼리 메서드 | 코드 작성 불필요, 가독성 좋음 |
| 단순한 검색 조건 조합 | 쿼리 메서드 | 메서드 이름으로 충분 |
| 복잡한 조건 (JOIN, GROUP BY, 집계) | JPQL | DB 의존성 낮음, 객체 중심 |
| 성능 최적화 필요 | Native SQL | 세밀한 제어 가능 |
| DB 특화 함수 필요 | Native SQL | 불가피한 선택 |

---

### 3.4.16 요약: JPA의 핵심 개념

| 개념 | 설명 |
|-----|------|
| **@Entity** | 엔티티 클래스 선언, DDL 자동 생성 |
| **@Table** | 테이블 매핑, 이름, 인덱스 정의 |
| **@Column** | 컬럼 매핑, 제약조건 정의 |
| **@Id + @GeneratedValue** | 기본 키 자동 생성 |
| **@Transient** | DB 매핑 제외 |
| **JpaRepository** | 기본 CRUD 자동 제공 |
| **쿼리 메서드** | 메서드 이름 기반 쿼리 자동 생성 |
| **Sort + Pageable** | 동적 정렬, 페이지네이션 |
| **@Query + JPQL** | 복잡한 쿼리, 객체 중심 |
| **Native SQL** | DB 특화 SQL, 성능 최적화 |
| **@EnableJpaAuditing** | 자동 시간 기록 (생성, 수정) |

---

## 3.4.17 영속성 컨텍스트 (Persistence Context)

### 3.4.17.1 영속성 컨텍스트란?

**영속성 컨텍스트(Persistence Context)**는 엔티티 객체를 데이터베이스와 연동할 때 사용하는 **캐시 메모리**입니다.

#### 핵심 개념

```
[애플리케이션]
      ↓
[영속성 컨텍스트] ← 엔티티 객체를 캐싱하는 메모리 공간
      ↓
[데이터베이스]
```

**목적**: 데이터베이스 접근 횟수를 줄여서 **성능을 향상**시킵니다.

JPA에서는 메서드 이름으로 쿼리를 생성하든, JPQL로 쿼리를 작성하든 최종적으로 **객체를 SQL로 변환**한 후 데이터베이스에 접근합니다. 이때 영속성 컨텍스트가 **중간 계층**으로 작동하여 불필요한 데이터베이스 접근을 방지합니다.

---

### 3.4.17.2 영속성 컨텍스트의 4가지 이점

#### 1. 1차 캐시 (First Level Cache)

**동작 원리**:
```
조회 요청
    ↓
영속성 컨텍스트에 있는가? 
    ├─ YES: 즉시 반환 (DB 접근 X)
    └─ NO: DB 조회 → 영속성 컨텍스트에 저장 → 반환
```

**예시**:
```java
@Transactional
public void example() {
    Member member1 = memberRepository.findById(1L).orElse(null);  // DB 조회
    Member member2 = memberRepository.findById(1L).orElse(null);  // 1차 캐시에서 반환 (DB 접근 X)
    
    System.out.println(member1 == member2);  // true (동일한 인스턴스)
}
```

**장점**: 같은 트랜잭션 내에서 동일한 엔티티를 여러 번 조회해도 **한 번만 DB에 접근**합니다.

---

#### 2. 변경 감지 (Dirty Checking)

**동작 원리**:
```
1. 엔티티를 영속성 컨텍스트에 저장할 때 "스냅샷" 생성
2. 트랜잭션 커밋 시점에 현재 상태와 스냅샷 비교
3. 변경 사항 감지 시 자동으로 UPDATE 쿼리 생성
4. 변경 사항 없으면 UPDATE 쿼리 생성 안 함
```

**예시**:
```java
@Transactional
public void example() {
    Member member = memberRepository.findById(1L).orElse(null);
    
    // 스냅샷: age=20
    member.setAge(30);  // 현재 상태: age=30
    
    // save() 호출 없이도 자동으로 UPDATE 쿼리 생성!
    // memberRepository.save(member); ← 불필요
    
} // 트랜잭션 종료 시 변경 감지 → UPDATE 실행
```

**변경 사항이 없는 경우**:
```java
@Transactional
public void example() {
    Member member = memberRepository.findById(1L).orElse(null);
    
    // 스냅샷: age=20
    memberRepository.save(member);  // 현재 상태: age=20
    
} // 스냅샷과 동일 → UPDATE 쿼리 생성 안 함 (성능 향상!)
```

---

#### 3. 쓰기 지연 (Transactional Write-Behind)

**동작 원리**:
```
1. save(), delete() 호출 시 즉시 DB에 실행 X
2. SQL을 "쓰기 지연 SQL 저장소"에 모아둠
3. 트랜잭션 커밋 시점에 모든 SQL을 한 번에 DB로 전송 (Flush)
```

**예시**:
```java
@Transactional
public void example() {
    Member m1 = Member.builder().name("혜창").email("hyechang@spring.ac.kr").build();
    Member m2 = Member.builder().name("우현").email("woohyun@spring.ac.kr").build();
    Member m3 = Member.builder().name("서준").email("seojun@spring.ac.kr").build();
    
    memberRepository.save(m1);  // SQL 저장소에 INSERT 예약
    memberRepository.save(m2);  // SQL 저장소에 INSERT 예약
    memberRepository.save(m3);  // SQL 저장소에 INSERT 예약
    
    // 여기까지 DB 접근 0번!
    
} // 트랜잭션 종료 → 3개의 INSERT를 한 번에 실행
```

**장점**: 
- 네트워크 왕복 횟수 감소
- 데이터베이스 성능 향상

---

#### 4. 엔티티 동일성 보장 (Identity)

**동작 원리**:
```
같은 영속성 컨텍스트 내에서 같은 ID로 조회한 엔티티는 
항상 동일한 인스턴스(주소)를 반환
```

**예시**:
```java
@Transactional
public void example() {
    Member m1 = memberRepository.findById(1L).orElse(null);
    Member m2 = memberRepository.findById(1L).orElse(null);
    
    System.out.println(m1 == m2);  // true (동일한 객체)
    System.out.println(m1.equals(m2));  // true
}
```

**@Transactional이 없는 경우**:
```java
public void example() {
    Member m1 = memberRepository.findById(1L).orElse(null);  // 트랜잭션 1 시작 → 종료
    Member m2 = memberRepository.findById(1L).orElse(null);  // 트랜잭션 2 시작 → 종료
    
    System.out.println(m1 == m2);  // false (다른 객체!)
}
```

**핵심**: 엔티티 동일성은 **같은 영속성 컨텍스트 (같은 트랜잭션) 내에서만** 보장됩니다.

---

### 3.4.17.3 영속성 컨텍스트의 생명주기

#### 트랜잭션 기반 동작

영속성 컨텍스트는 **트랜잭션(@Transactional) 기반**으로 생성되고 소멸됩니다.

```
@Transactional 메서드 시작
    ↓
영속성 컨텍스트 생성
    ↓
메서드 내부 작업 (save, find, update...)
    ↓
메서드 종료
    ↓
트랜잭션 커밋 (Flush → Commit)
    ↓
영속성 컨텍스트 종료
```

**예시**:
```java
@Component
@Transactional  // 클래스 레벨 → run() 메서드 전체가 하나의 트랜잭션
public class JpaApplication implements ApplicationRunner {
    
    private final MemberRepository memberRepository;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 영속성 컨텍스트 생성 (트랜잭션 시작)
        
        Member hyechang = Member.builder()
                                .name("hyechang")
                                .email("hyechang@spring.ac.kr")
                                .age(20)
                                .build();
        memberRepository.save(hyechang);
        
        Member woohyun = Member.builder()
                               .name("woohyun")
                               .email("woohyun@spring.ac.kr")
                               .age(25)
                               .build();
        memberRepository.save(woohyun);
        
        // 1차 캐시 활용
        hyechang = memberRepository.findById(hyechang.getId()).orElse(null);
        
        // 변경 감지
        hyechang.setAge(1000);
        
        // 쓰기 지연 (INSERT 2개 + UPDATE 1개가 SQL 저장소에 대기 중)
        
    } // 메서드 종료 → Flush → Commit → 영속성 컨텍스트 종료
}
```

**내부 동작**:
```
1. save(hyechang): INSERT SQL 저장소에 예약
2. save(woohyun): INSERT SQL 저장소에 예약
3. findById(): 1차 캐시에서 반환 (DB 접근 X)
4. setAge(1000): 변경 감지 → UPDATE SQL 저장소에 예약
5. 메서드 종료: Flush (SQL 3개를 한 번에 실행) → Commit
```

---

### 3.4.17.4 Spring Data JPA의 자동 관리

#### 개발자가 관리할 필요 없는 경우

Spring Data JPA를 사용하면 **대부분의 경우 영속성 컨텍스트와 트랜잭션을 자동으로 관리**합니다.

| 작업 | 트랜잭션/영속성 관리 | 비고 |
|-----|---------------------|------|
| **기본 CRUD** (`save`, `findById`, `delete`) | ✅ 자동 적용 | `JpaRepository`에 `@Transactional`이 이미 적용됨 |
| **쿼리 메서드** (`findByName`, `findByAge...`) | ✅ 자동 적용 | Spring Data JPA가 트랜잭션 자동 설정 |
| **`@Query` SELECT** | ✅ 자동 적용 | 조회 쿼리는 자동 처리 |

**자동 관리되는 이유**:
```java
// Spring Data JPA가 내부적으로 생성하는 구현체 (개념적 표현)
@Transactional  // 기본 CRUD 메서드에 자동 적용
public class SimpleJpaRepository<T, ID> implements JpaRepository<T, ID> {
    
    @Override
    public <S extends T> S save(S entity) {
        // 트랜잭션 내에서 실행
        // 영속성 컨텍스트 자동 관리
    }
    
    @Override
    public Optional<T> findById(ID id) {
        // 트랜잭션 내에서 실행
        // 영속성 컨텍스트 자동 관리
    }
}
```

---

#### 개발자가 명시해야 하는 경우

**`@Query`를 사용한 DML (INSERT, UPDATE, DELETE)**을 작성할 때는 **반드시 수동으로 명시**해야 합니다.

```java
@Modifying  // 필수! 이 쿼리가 데이터 변경 작업임을 선언
@Transactional  // 필수! 트랜잭션 시작
@Query("UPDATE Member m SET m.age = :age WHERE m.id = :id")
int updateMemberAge(@Param("age") int age, @Param("id") Long id);
```

**필수 어노테이션**:

| 어노테이션 | 역할 | 필수 여부 |
|-----------|------|----------|
| **`@Transactional`** | 트랜잭션 시작 (영속성 컨텍스트 생성) | ✅ 필수 |
| **`@Modifying`** | 이 쿼리가 데이터 변경(DML)임을 선언 | ✅ 필수 |

---

### 3.4.17.5 @Modifying이 필요한 이유 - 1차 캐시 불일치 문제

#### 문제 상황: 영속성 컨텍스트 우회

`@Query`를 사용한 DML은 **영속성 컨텍스트를 우회**하고 DB에 직접 SQL을 실행합니다.

**시나리오**:

```java
@Transactional
public void problemExample() {
    // 1단계: 조회 (DB: age=20)
    Member m = memberRepository.findById(1L).get();
    // 1차 캐시에 저장: {id=1, name="혜창", age=20}
    
    // 2단계: @Query UPDATE 실행 (영속성 컨텍스트 우회!)
    memberRepository.updateMemberAge(1000, 1L);
    // DB: age=1000으로 변경됨
    // 1차 캐시: 여전히 age=20 (변경 안 됨!)
    
    // 3단계: 재조회
    Member m2 = memberRepository.findById(1L).get();
    // 1차 캐시에 있는 age=20 반환 (DB 접근 안 함!)
    
    System.out.println(m2.getAge());  // 20 출력 (실제 DB는 1000인데!)
}
```

**문제 발생**:
```
DB 상태: age=1000
1차 캐시: age=20

→ 심각한 데이터 불일치!
```

---

#### 해결: @Modifying으로 1차 캐시 초기화

```java
@Modifying  // 1차 캐시 초기화 활성화
@Transactional
@Query("UPDATE Member m SET m.age = :age WHERE m.id = :id")
int updateMemberAge(@Param("age") int age, @Param("id") Long id);
```

**@Modifying의 역할**:

| 속성 | 기본값 | 역할 |
|-----|--------|------|
| **`clearAutomatically`** | `true` | 쿼리 실행 **직후** 1차 캐시를 통째로 비움 |
| **`flushAutomatically`** | `false` | 쿼리 실행 **직전** 영속성 컨텍스트를 DB에 동기화 |

**수정된 시나리오**:

```java
@Transactional
public void solutionExample() {
    // 1단계: 조회
    Member m = memberRepository.findById(1L).get();
    // 1차 캐시: {id=1, age=20}
    
    // 2단계: @Modifying이 적용된 UPDATE 실행
    memberRepository.updateMemberAge(1000, 1L);
    // DB: age=1000
    // 1차 캐시: 초기화됨 (비어있음)
    
    // 3단계: 재조회
    Member m2 = memberRepository.findById(1L).get();
    // 1차 캐시가 비어있으므로 DB에서 조회!
    // DB: age=1000 → 1차 캐시에 저장 → 반환
    
    System.out.println(m2.getAge());  // 1000 출력 (정확함!)
}
```

**핵심**: `@Modifying`은 영속성 컨텍스트를 우회한 DML 작업 후 **메모리(1차 캐시)의 오래된 데이터를 강제로 삭제**하여, 다음 조회 시 **항상 DB의 최신 데이터를 읽어오도록 강제**합니다.

---

### 3.4.17.6 @Transactional의 범위 (Scope)

#### 트랜잭션 범위 확장

`@Transactional`은 **가장 바깥쪽**에 선언된 것이 기준이 되며, 그 범위 동안 **하나의 영속성 컨텍스트**가 유지됩니다.

**예시**:

```java
@Component
@Transactional  // 클래스 레벨 → 모든 메서드가 하나의 트랜잭션
public class JpaApplication implements ApplicationRunner {
    
    private final MemberRepository memberRepository;
    
    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 영속성 컨텍스트 생성
        
        Member hyechang = Member.builder()
                                .name("hyechang")
                                .email("hyechang@spring.ac.kr")
                                .age(20)
                                .build();
        memberRepository.save(hyechang);
        
        hyechang = memberRepository.findById(hyechang.getId()).orElse(null);
        // 1차 캐시에서 반환 (DB 접근 X)
        
        hyechang.setAge(1000);
        // 변경 감지 준비
        
        memberRepository.save(hyechang);
        // 이미 영속 상태이므로 변경 감지로 처리
        
        // 모든 작업이 같은 영속성 컨텍스트에서 실행됨!
        
    } // 영속성 컨텍스트 종료 (Flush → Commit)
}
```

**동작 과정**:

```
@Transactional 시작
    ↓
영속성 컨텍스트 생성
    ↓
save(hyechang): INSERT SQL 저장소에 예약
    ↓
findById(): 1차 캐시에서 반환 (DB X)
    ↓
setAge(1000): 변경 감지 → UPDATE SQL 저장소에 예약
    ↓
save(hyechang): 이미 영속 상태 → 변경 감지로 처리 (중복 X)
    ↓
메서드 종료
    ↓
Flush: INSERT 1개 + UPDATE 1개 실행
    ↓
Commit
    ↓
영속성 컨텍스트 종료
```

---

#### 중첩된 트랜잭션의 범위

```java
@Service
public class MemberService {
    
    @Transactional  // 바깥쪽 트랜잭션
    public void outerMethod() {
        Member m = memberRepository.findById(1L).get();
        
        innerMethod();  // 안쪽 트랜잭션
        
        m.setAge(100);
        
    } // 여기서 Commit → 영속성 컨텍스트 종료
    
    @Transactional  // 기본적으로 바깥쪽 트랜잭션에 참여
    public void innerMethod() {
        // outerMethod()의 영속성 컨텍스트를 공유
    }
}
```

**핵심**: 기본적으로 중첩된 `@Transactional`은 **가장 바깥쪽 트랜잭션에 참여**하며, 하나의 영속성 컨텍스트를 공유합니다.

---

### 3.4.17.7 핵심 정리

#### Spring Data JPA 사용 시 영속성 컨텍스트 관리

| 상황 | 개발자 작업 | Spring Data JPA |
|-----|------------|----------------|
| **기본 CRUD** | 아무것도 안 해도 됨 | ✅ 자동으로 `@Transactional` 적용 |
| **쿼리 메서드** | 아무것도 안 해도 됨 | ✅ 자동으로 트랜잭션 관리 |
| **`@Query` SELECT** | 아무것도 안 해도 됨 | ✅ 자동으로 트랜잭션 관리 |
| **`@Query` DML** | ⚠️ `@Transactional` + `@Modifying` 필수 | ❌ 수동으로 명시 필요 |
| **비즈니스 로직 (여러 작업)** | ⚠️ `@Transactional` 권장 | 🟡 Service 계층에서 명시 |

---

#### 영속성 컨텍스트의 4가지 핵심 이점

| 이점 | 설명 | 장점 |
|-----|------|------|
| **1차 캐시** | 같은 트랜잭션 내에서 같은 엔티티 조회 시 DB 접근 X | 성능 향상 |
| **변경 감지** | `setter`만 호출해도 자동으로 UPDATE 쿼리 생성 | 코드 간소화 |
| **쓰기 지연** | SQL을 모아두었다가 커밋 시점에 한 번에 실행 | 성능 향상 |
| **엔티티 동일성** | 같은 ID 조회 시 항상 같은 인스턴스 반환 | 안정성 |

---

## 3.4.18 연관관계 매핑 (Relationship Mapping)

### 3.4.18.1 Spring Data JDBC vs JPA

**Spring Data JDBC의 가장 큰 단점**: 엔티티 간의 **연관관계를 표현할 수 없음**

**JPA의 핵심 기능**: 엔티티 간의 **연관관계를 객체 지향적으로 표현 가능** ⭐

| 기능 | Spring Data JDBC | JPA |
|-----|-----------------|-----|
| **테이블 매핑** | ✅ 지원 | ✅ 지원 |
| **연관관계 매핑** | ❌ 미지원 | ✅ 지원 ⭐ |
| **외래 키 자동 관리** | ❌ 수동 | ✅ 자동 |

---

### 3.4.18.2 JPA 연관관계 종류

JPA는 4가지 연관관계 매핑을 지원합니다.

| 어노테이션 | 관계 | 예시 |
|-----------|------|------|
| **`@OneToOne`** | 일대일 (1:1) | 회원 ↔ 회원카드 |
| **`@OneToMany`** | 일대다 (1:N) | 회원 ↔ 게시글 |
| **`@ManyToOne`** | 다대일 (N:1) | 게시글 ↔ 회원 |
| **`@ManyToMany`** | 다대다 (N:M) | 학생 ↔ 수업 |

---

### 3.4.18.3 연관관계의 주인 (Owner)

#### 개념

**연관관계의 주인**: 외래 키(Foreign Key)를 **실제로 관리하는 엔티티**

**규칙**: **외래 키가 있는 테이블에 매핑된 엔티티가 주인**

```
Member 테이블 (1)          Article 테이블 (N)
─────────────────         ─────────────────────
id (PK)                   id (PK)
name                      title
email                     description
                          member_id (FK) ← 외래 키!
```

**주인 결정**:
- `Article` 테이블에 `member_id` 외래 키가 있음
- **`Article` 엔티티가 연관관계의 주인** ✅

---

#### 주인의 역할

| 항목 | 주인 (Owner) | 주인 아님 (Not Owner) |
|-----|-------------|---------------------|
| **외래 키 관리** | ✅ 가능 (등록/수정/삭제) | ❌ 불가능 (읽기만 가능) |
| **매핑 어노테이션** | `@ManyToOne` | `@OneToMany` |
| **`mappedBy` 속성** | ❌ 사용 안 함 | ✅ 필수 사용 |

---

### 3.4.18.4 예시: Member ↔ Article (1:N 관계)

#### 엔티티 정의

**Article (N쪽 - 연관관계의 주인)**:

```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String description;
    
    @ManyToOne  // 연관관계의 주인 (외래 키 관리)
    private Member member;
}
```

**Member (1쪽 - 연관관계의 주인 아님)**:

```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.util.List;

@Entity
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(
    name = "vip_table",
    indexes = {
        @Index(name = "idx_name", columnList = "display_name, age"),
        @Index(name = "idx_email", columnList = "primary_contact")
    }
)
public class Member {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "display_name", length = 2048, nullable = false, unique = true)
    private String name;
    
    @Column(name = "primary_contact")
    private String email;
    
    private Integer age;
    
    @Transient
    private String address;
    
    @OneToMany(mappedBy = "member")  // 읽기 전용 (주인 아님)
    @ToString.Exclude  // 무한 루프 방지 (toString)
    @JsonIgnore  // 무한 루프 방지 (JSON 직렬화)
    private List<Article> articles;
}
```

---

#### 핵심 요소 설명

##### 1. @ManyToOne (연관관계의 주인)

```java
@ManyToOne
private Member member;
```

**의미**:
- "여러 개(`Many`)의 Article은 하나(`One`)의 Member에 속한다"
- `Article` 테이블에 `member_id` 외래 키 생성
- **이 필드가 외래 키를 실제로 관리**

**생성되는 DDL**:
```sql
CREATE TABLE article (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255),
    description VARCHAR(255),
    member_id BIGINT,  -- 외래 키
    FOREIGN KEY (member_id) REFERENCES vip_table(id)
);
```

---

##### 2. @OneToMany(mappedBy = "member")

```java
@OneToMany(mappedBy = "member")
private List<Article> articles;
```

**의미**:
- "하나(`One`)의 Member는 여러 개(`Many`)의 Article을 가진다"
- **`mappedBy = "member"`**: "나는 주인이 아니며, `Article` 엔티티의 `member` 필드가 주인입니다"
- **읽기 전용 (Read Only)**: 이 필드로는 외래 키를 변경할 수 없음

**`mappedBy`의 역할**:

| 속성값 | 의미 |
|-------|------|
| `"member"` | `Article` 엔티티의 **`member`** 필드가 연관관계의 주인 |

```java
// Article 엔티티 내부
@ManyToOne
private Member member;  // ← mappedBy가 가리키는 필드
```

---

##### 3. @ToString.Exclude (무한 루프 방지 - Lombok)

```java
@ToString.Exclude
private List<Article> articles;
```

**문제 상황**:
```java
Article article = articleRepository.findById(1L).get();
log.info(article.toString());  // StackOverflowError 발생!
```

**무한 루프**:
```
1. Article.toString() 호출
2. member 필드의 toString() 호출
3. Member.toString() 호출
4. articles 필드의


toString() 호출
5. List<Article>의 각 Article.toString() 호출
6. 다시 1번으로 → 무한 반복 → StackOverflowError
```

**해결**:
```java
@ToString.Exclude  // toString() 메서드에서 이 필드 제외
private List<Article> articles;
```

**결과**:
```java
// Member.toString() 실행 시
Member(id=1, name=hyechang, email=hyechang@spring.ac.kr, age=20)
// articles 필드는 출력되지 않음 → 무한 루프 방지
```

---

##### 4. @JsonIgnore (무한 루프 방지 - Jackson)

```java
@JsonIgnore
private List<Article> articles;
```

**문제 상황**:
```java
@RestController
public class MemberController {
    
    @GetMapping("/members/{id}")
    public Member getMember(@PathVariable Long id) {
        return memberRepository.findById(id).get();
        // Member 객체를 JSON으로 변환 시도
    }
}
```

**무한 루프**:
```
1. Member 객체를 JSON으로 변환
2. articles 필드 직렬화 시도
3. List<Article>의 각 Article 직렬화
4. Article의 member 필드 직렬화
5. 다시 Member 직렬화 → 무한 반복 → 서버 오류
```

**해결**:
```java
@JsonIgnore  // JSON 직렬화 시 이 필드 제외
private List<Article> articles;
```

**결과 JSON**:
```json
{
  "id": 1,
  "name": "hyechang",
  "email": "hyechang@spring.ac.kr",
  "age": 20
}
```
- `articles` 필드는 JSON에 포함되지 않음 → 무한 루프 방지

---

#### @ToString.Exclude vs @JsonIgnore 비교

| 어노테이션 | 라이브러리 | 방지 대상 | 발생 시점 |
|-----------|----------|---------|----------|
| **`@ToString.Exclude`** | Lombok | `toString()` 무한 루프 | 로깅, 디버깅 시 |
| **`@JsonIgnore`** | Jackson | JSON 직렬화 무한 루프 | API 응답 시 |

**결론**: 양방향 연관관계에서는 **둘 다 필수**로 사용해야 합니다!

---

### 3.4.18.5 연관관계 사용 예시

#### Repository 정의

**ArticleRepository.java**:
```java
package com.example.jpaHibernateSample.repository;

import com.example.jpaHibernateSample.Article;
import com.example.jpaHibernateSample.Member;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ArticleRepository extends JpaRepository<Article, Long> {
    
    List<Article> findByMember(Member member);
}
```

**MemberRepository.java**:
```java
package com.example.jpaHibernateSample.repository;

import com.example.jpaHibernateSample.Member;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface MemberRepository extends JpaRepository<Member, Long> {
}
```

---

#### 애플리케이션 실행 예시

**JpaApplication.java**:
```java
package com.example.jpaHibernateSample;

import com.example.jpaHibernateSample.repository.ArticleRepository;
import com.example.jpaHibernateSample.repository.MemberRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;
import java.util.List;

@RequiredArgsConstructor
@Slf4j
@Component
public class JpaApplication implements ApplicationRunner {

    private final MemberRepository memberRepository;
    private final ArticleRepository articleRepository;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        
        // 1. Member 생성
        Member hyechang = Member.builder()
                                .name("hyechang")
                                .email("hyechang@spring.ac.kr")
                                .age(20)
                                .build();
        memberRepository.save(hyechang);

        Member woohyun = Member.builder()
                               .name("woohyun")
                               .email("woohyun@spring.ac.kr")
                               .age(20)
                               .build();
        memberRepository.save(woohyun);

        // 2. Article 생성 (연관관계 설정)
        Article article1 = Article.builder()
                                  .title("방학 첫날이다.")
                                  .description("오늘은 열심히 방학 숙제를 해야겠다.")
                                  .member(hyechang)  // 연관관계의 주인이 외래 키 설정
                                  .build();
        articleRepository.save(article1);

        Article article2 = Article.builder()
                                  .title("개학은 언제인가요?")
                                  .description("개학이 언제인지 궁금합니다!!")
                                  .member(woohyun)
                                  .build();
        articleRepository.save(article2);

        Article article3 = Article.builder()
                                  .title("헬스다니실분!")
                                  .description("헬스 같이 하실 분 구합니다.")
                                  .member(hyechang)
                                  .build();
        articleRepository.save(article3);

        // 3. 전체 게시글 조회
        List<Article> lists = articleRepository.findAll();
        for (Article article : lists) {
            log.info(article.toString());
        }

        // 4. 특정 회원의 게시글 조회
        lists = articleRepository.findByMember(hyechang);
        for (Article article : lists) {
            log.info(article.toString());
        }
    }
}
```

---

#### 실행 결과

**생성된 데이터**:

**vip_table (Member)**:
```
id | display_name | primary_contact          | age
1  | hyechang     | hyechang@spring.ac.kr    | 20
2  | woohyun      | woohyun@spring.ac.kr     | 20
```

**article (Article)**:
```
id | title               | description                      | member_id
1  | 방학 첫날이다.       | 오늘은 열심히 방학 숙제를...      | 1
2  | 개학은 언제인가요?   | 개학이 언제인지 궁금합니다!!      | 2
3  | 헬스다니실분!        | 헬스 같이 하실 분 구합니다.       | 1
```

**로그 출력**:
```
Article(id=1, title=방학 첫날이다., description=오늘은 열심히 방학 숙제를..., member=Member(id=1, name=hyechang, email=hyechang@spring.ac.kr, age=20))
Article(id=2, title=개학은 언제인가요?, description=개학이 언제인지 궁금합니다!!, member=Member(id=2, name=woohyun, email=woohyun@spring.ac.kr, age=20))
Article(id=3, title=헬스다니실분!, description=헬스 같이 하실 분 구합니다., member=Member(id=1, name=hyechang, email=hyechang@spring.ac.kr, age=20))

Article(id=1, title=방학 첫날이다., description=오늘은 열심히 방학 숙제를..., member=Member(id=1, name=hyechang, email=hyechang@spring.ac.kr, age=20))
Article(id=3, title=헬스다니실분!, description=헬스 같이 하실 분 구합니다., member=Member(id=1, name=hyechang, email=hyechang@spring.ac.kr, age=20))
```

---

#### 핵심 동작 분석

##### 1. 연관관계 설정 (주인이 외래 키 관리)

```java
Article article1 = Article.builder()
                          .member(hyechang)  // 연관관계의 주인이 설정
                          .build();
articleRepository.save(article1);
```

**생성되는 SQL**:
```sql
INSERT INTO article (title, description, member_id) 
VALUES ('방학 첫날이다.', '오늘은 열심히...', 1);
```

**핵심**: `Article`이 연관관계의 주인이므로, `.member(hyechang)`으로 설정한 값이 **외래 키 `member_id`에 자동으로 저장**됩니다.

---

##### 2. 연관관계를 통한 조회

```java
List<Article> lists = articleRepository.findByMember(hyechang);
```

**생성되는 SQL**:
```sql
SELECT * FROM article WHERE member_id = 1;
```

**결과**: `hyechang` 회원이 작성한 게시글만 조회됩니다.

---

##### 3. 역방향 조회 (주인이 아닌 쪽에서 조회)

```java
Member member = memberRepository.findById(1L).get();
List<Article> articles = member.getArticles();  // 역방향 탐색
```

**생성되는 SQL**:
```sql
SELECT * FROM article WHERE member_id = 1;
```

**핵심**: `@OneToMany(mappedBy = "member")`로 설정했기 때문에, JPA가 자동으로 역방향 조회를 지원합니다.

---

### 3.4.18.6 로딩 전략 (Fetch Type)

#### 기본 로딩 전략 규칙

**외우는 법**: **"Many로 끝나면 지연(Lazy), One으로 끝나면 즉시(Eager)"**

| 어노테이션 | 기본 전략 | 외우는 법 |
|-----------|---------|----------|
| **`@OneToMany`** | **LAZY** (지연) | `Many`로 끝남 → Lazy |
| **`@ManyToMany`** | **LAZY** (지연) | `Many`로 끝남 → Lazy |
| **`@ManyToOne`** | **EAGER** (즉시) | `One`으로 끝남 → Eager |
| **`@OneToOne`** | **EAGER** (즉시) | `One`으로 끝남 → Eager |

---

#### 지연 로딩 (Lazy Loading)

```java
@OneToMany(mappedBy = "member", fetch = FetchType.LAZY)  // 기본값
private List<Article> articles;
```

**동작**:
```
1. Member 조회 시: Member 테이블만 조회 (Article 조회 X)
2. member.getArticles() 호출 시: 그때 Article 테이블 조회
```

**예시**:
```java
Member member = memberRepository.findById(1L).get();
// SQL: SELECT * FROM vip_table WHERE id = 1

List<Article> articles = member.getArticles();  // 이 시점에 조회!
// SQL: SELECT * FROM article WHERE member_id = 1
```

---

#### 즉시 로딩 (Eager Loading)

```java
@ManyToOne(fetch = FetchType.EAGER)  // 기본값
private Member member;
```

**동작**:
```
Article 조회 시: Article + Member를 한 번에 JOIN하여 조회
```

**예시**:
```java
Article article = articleRepository.findById(1L).get();
// SQL: SELECT a.*, m.* FROM article a 
//      LEFT JOIN vip_table m ON a.member_id = m.id 
//      WHERE a.id = 1
```

---

#### 로딩 전략 변경

```java
// 지연 로딩으로 변경 (권장)
@ManyToOne(fetch = FetchType.LAZY)
private Member member;

// 즉시 로딩으로 변경 (비권장)
@OneToMany(mappedBy = "member", fetch = FetchType.EAGER)  // ❌ N+1 문제 발생!
private List<Article> articles;
```

---

#### N+1 문제 ⚠️

**@OneToMany를 EAGER로 설정하면 안 되는 이유**:

```java
// 잘못된 예시
@OneToMany(mappedBy = "member", fetch = FetchType.EAGER)
private List<Article> articles;

// 실행
List<Member> members = memberRepository.findAll();
```

**발생하는 SQL**:
```sql
-- 1번: Member 전체 조회
SELECT * FROM vip_table;  -- 결과: 10명

-- 2~11번: 각 Member마다 Article 조회
SELECT * FROM article WHERE member_id = 1;
SELECT * FROM article WHERE member_id = 2;
SELECT * FROM article WHERE member_id = 3;
...
SELECT * FROM article WHERE member_id = 10;
```

**결과**: **1 + N = 11번의 쿼리 실행** (성능 저하!)

**해결**: `@OneToMany`는 **LAZY 유지** + 필요 시 **Fetch Join** 사용

---

### 3.4.18.7 연관관계 매핑 핵심 정리

#### 연관관계의 주인 규칙

| 항목 | 설명 |
|-----|------|
| **주인 결정** | 외래 키가 있는 테이블에 매핑된 엔티티 |
| **주인의 역할** | 외래 키 등록/수정/삭제 가능 |
| **주인의 어노테이션** | `@ManyToOne`, `@OneToOne` (FK 쪽) |
| **주인 아님** | `@OneToMany`, `@ManyToMany` + `mappedBy` |

---

#### 무한 루프 방지 필수 어노테이션

| 어노테이션 | 라이브러리 | 용도 | 위치 |
|-----------|----------|------|------|
| **`@ToString.Exclude`** | Lombok | `toString()` 무한 루프 방지 | 컬렉션 필드 |
| **`@JsonIgnore`** | Jackson | JSON 직렬화 무한 루프 방지 | 컬렉션 필드 |

**사용 위치**:
```java
@OneToMany(mappedBy = "member")
@ToString.Exclude  // 필수!
@JsonIgnore  // 필수!
private List<Article> articles;
```

---

#### 로딩 전략 권장사항

| 어노테이션 | 기본 전략 | 권장 전략 | 이유 |
|-----------|---------|---------|------|
| **`@OneToMany`** | LAZY | **LAZY 유지** ✅ | N+1 문제 방지 |
| **`@ManyToMany`** | LAZY | **LAZY 유지** ✅ | N+1 문제 방지 |
| **`@ManyToOne`** | EAGER | LAZY 또는 EAGER | 상황에 따라 선택 |
| **`@OneToOne`** | EAGER | LAZY 또는 EAGER | 상황에 따라 선택 |

**핵심**: **`Many`로 끝나는 어노테이션은 항상 LAZY 유지!**

---

### 3.4.18.8 최종 예시 코드 (완전한 형태)

**Member.java** (완전한 형태):
```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import lombok.*;
import com.fasterxml.jackson.annotation.JsonIgnore;
import java.util.List;

@Entity
@Builder
@Data
@AllArgsConstructor
@NoArgsConstructor
@Table(
    name = "vip_table",
    indexes = {
        @Index(name = "idx_name", columnList = "display_name, age"),
        @Index(name = "idx_email", columnList = "primary_contact")
    }
)
public class Member {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(name = "display_name", length = 2048, nullable = false, unique = true)
    private String name;
    
    @Column(name = "primary_contact")
    private String email;
    
    private Integer age;
    
    @Transient
    private String address;
    
    @OneToMany(mappedBy = "member", fetch = FetchType.LAZY)
    @ToString.Exclude
    @JsonIgnore
    private List<Article> articles;
}
```

**Article.java** (완전한 형태):
```java
package com.example.jpaHibernateSample;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class Article {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String description;
    
    @ManyToOne(fetch = FetchType.LAZY)
    private Member member;
}
```

---

## 3.4.19 핵심 요약

### JPA의 3대 핵심 개념

| 개념 | 핵심 내용 |
|-----|----------|
| **1. 영속성 컨텍스트** | 엔티티를 캐싱하여 DB 접근 최소화 (1차 캐시, 변경 감지, 쓰기 지연, 동일성 보장) |
| **2. 연관관계 매핑** | 객체 지향적으로 엔티티 간 관계 표현 (`@OneToMany`, `@ManyToOne` 등) |
| **3. JPQL** | 객체를 대상으로 쿼리 작성 (테이블이 아닌 엔티티 기반) |

---

### Spring Data JPA 사용 시 주의사항

| 상황 | 필수 어노테이션 | 이유 |
|-----|----------------|------|
| **`@Query` DML** | `@Transactional` + `@Modifying` | 영속성 컨텍스트 우회 시 1차 캐시 불일치 방지 |
| **양방향 연관관계** | `@ToString.Exclude` + `@JsonIgnore` | 무한 루프 방지 |
| **`@OneToMany` 사용 시** | `fetch = FetchType.LAZY` 유지 | N+1 문제 방지 |

---

## 3.4.20 QueryDSL - 타입 안전한 동적 쿼리

### 3.4.20.1 QueryDSL이란?

**QueryDSL**은 **쿼리를 자바 코드로 작성**할 수 있게 도와주는 프레임워크입니다.

#### Spring Data JPA의 한계

지금까지 Spring Data JPA에서 쿼리를 작성하는 두 가지 방법을 배웠습니다:

| 방법 | 장점 | 단점 |
|-----|------|------|
| **쿼리 메서드** | 간단한 CRUD 자동화 | 복잡한 조건 → 메서드명 길어짐, 모든 조합 정의 필요 |
| **`@Query` (JPQL)** | 복잡한 쿼리 작성 가능 | **컴파일 시점 오류 검출 불가**, 동적 쿼리 작성 어려움 |

#### JPQL의 문제점

```java
// ❌ 컴파일 시점에 오류를 잡을 수 없음
@Query("SELECT m FROM Member m WHERE m.name = :name")
List<Member> findByName(@Param("name") String name);
```

**문제 상황**:
```
1. Member 엔티티에 name 필드가 없다면?
   → 실행 시점에만 오류 발견 (런타임 에러)

2. 필드명 오타 (name → nema)
   → 컴파일러가 잡아주지 못함

3. 동적 쿼리 작성 시 문자열 조합 복잡
   → 유지보수 어려움
```

---

#### QueryDSL의 해결책

**QueryDSL**은 이러한 문제들을 **메서드 체이닝 방식**으로 해결합니다.

```java
// ✅ 컴파일 시점에 오류 검출 가능
List<Member> members = jpaQueryFactory
    .selectFrom(member)
    .where(member.name.eq("hyechang"))  // name 필드 없으면 컴파일 에러!
    .fetch();
```

**장점**:
- ✅ **타입 안전성 (Type Safety)**: 컴파일 시점에 오류 검출
- ✅ **동적 쿼리 작성 용이**: 조건에 따라 메서드 체이닝
- ✅ **IDE 지원**: 자동완성, 리팩토링 가능
- ✅ **유지보수성**: 필드명 변경 시 자동 반영

---

### 3.4.20.2 QueryDSL vs 다른 방식 비교

| 항목 | 쿼리 메서드 | JPQL (`@Query`) | QueryDSL |
|-----|-----------|----------------|----------|
| **작성 방식** | 메서드 이름 규칙 | 문자열 쿼리 | **자바 코드** ⭐ |
| **컴파일 시 검증** | ❌ 불가능 | ❌ 불가능 | ✅ **가능** ⭐ |
| **동적 쿼리** | ❌ 매우 어려움 | 🟡 가능하나 복잡 | ✅ **매우 쉬움** ⭐ |
| **복잡한 조건** | ❌ 메서드명 길어짐 | ✅ 가능 | ✅ **가능** ⭐ |
| **IDE 지원** | 🟡 제한적 | ❌ 없음 | ✅ **완벽 지원** ⭐ |
| **학습 곡선** | 낮음 | 중간 | 중간 |

---

### 3.4.20.3 QueryDSL의 위치와 역할

#### QueryDSL과 JPA의 관계

**중요**: QueryDSL은 JPA를 **대체하는 것이 아니라 보완**하는 도구입니다.

```
[개발자]
    ↓ (타입 안전한 자바 코드로 쿼리 작성)
[QueryDSL]
    ↓ (JPQL로 변환)
[Spring Data JPA]
    ↓ (SQL로 변환)
[Hibernate (JPA 구현체)]
    ↓ (SQL 실행)
[JDBC Driver]
    ↓
[데이터베이스]
```

**핵심**: QueryDSL은 **JPA의 장점(객체 지향 매핑, 영속성 컨텍스트)을 유지**하면서, **JPQL의 단점(문자열 쿼리)을 보완**합니다.

---

### 3.4.20.4 프로젝트 설정

#### 의존성 추가 (build.gradle)

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    
    // QueryDSL 의존성 (수동 추가 필수!)
    implementation 'com.querydsl:querydsl-jpa:5.0.0:jakarta'
    annotationProcessor 'com.querydsl:querydsl-apt:5.0.0:jakarta'
    annotationProcessor 'jakarta.annotation:jakarta.annotation-api'
    annotationProcessor 'jakarta.persistence:jakarta.persistence-api'
    
    runtimeOnly 'com.h2database:h2'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 | 필수 여부 |
|-------|------|----------|
| **`querydsl-jpa:jakarta`** | QueryDSL을 JPA와 통합하는 핵심 라이브러리 | ✅ 필수 |
| **`querydsl-apt:jakarta`** | **Q-클래스 자동 생성** (Annotation Processor) | ✅ 필수 (가장 중요!) |
| **`jakarta.annotation-api`** | Q-클래스 생성 시 `@Generated` 어노테이션 처리 | ✅ 필수 |
| **`jakarta.persistence-api`** | JPA 표준 어노테이션 처리 | ✅ 필수 |

> ⚠️ **중요**: QueryDSL은 Spring Initializr에서 추가할 수 없으므로 **반드시 수동으로 추가**해야 합니다!

---

#### 설정 파일 (application.properties)

```properties
spring.application.name=queryDslSample

# JPA 디버깅 활성화
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.format_sql=true
spring.jpa.properties.hibernate.highlight_sql=true
spring.jpa.properties.hibernate.use_sql_comments=true
```

**핵심**: QueryDSL은 JPA를 **보완하는 프레임워크**이므로, JPA 설정이 그대로 적용됩니다.

---

### 3.4.20.5 Q-클래스 (Query Class) - 가장 중요!

#### Q-클래스란?

**Q-클래스**는 QueryDSL이 **엔티티 클래스를 기반으로 자동 생성**하는 **쿼리 전용 클래스**입니다.

#### 엔티티 클래스 작성

**Product.java**:
```java
package com.example.queryDslSample;

import jakarta.persistence.*;
import lombok.*;

@Entity
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class Product {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String title;
    private String description;
}
```

---

#### 빌드 후 자동 생성되는 Q-클래스

**프로젝트 빌드**:
```
Gradle → build 또는 IntelliJ → Build Project
```

**생성 위치**:
```
build/generated/sources/annotationProcessor/java/main/
└─ com/example/queryDslSample/
   └─ QProduct.java  ← 자동 생성!
```

**QProduct.java** (자동 생성된 코드):
```java
package com.example.queryDslSample;

import static com.querydsl.core.types.PathMetadataFactory.*;
import com.querydsl.core.types.dsl.*;
import com.querydsl.core.types.PathMetadata;
import javax.annotation.processing.Generated;
import com.querydsl.core.types.Path;

/**
 * QProduct is a Querydsl query type for Product
 */
@Generated("com.querydsl.codegen.DefaultEntitySerializer")
public class QProduct extends EntityPathBase<Product> {

    private static final long serialVersionUID = -859603247L;

    public static final QProduct product = new QProduct("product");  // ← 정적 필드!

    public final StringPath description = createString("description");

    public final NumberPath<Long> id = createNumber("id", Long.class);

    public final StringPath title = createString("title");

    public QProduct(String variable) {
        super(Product.class, forVariable(variable));
    }

    public QProduct(Path<? extends Product> path) {
        super(path.getType(), path.getMetadata());
    }

    public QProduct(PathMetadata metadata) {
        super(Product.class, metadata);
    }
}
```

---

#### Q-클래스의 역할과 구조

##### 1. 정적 필드 (Static Field)

```java
public static final QProduct product = new QProduct("product");
```

**역할**: 쿼리 작성 시 간편하게 사용할 수 있는 **싱글톤 인스턴스**

**사용**:
```java
// QProduct.product로 접근 가능!
QProduct product = QProduct.product;

List<Product> results = jpaQueryFactory
    .selectFrom(product)  // ← QProduct.product 사용
    .where(product.title.eq("TV"))
    .fetch();
```

---

##### 2. 타입 안전한 필드 (Type-Safe Fields)

```java
public final StringPath title = createString("title");
public final NumberPath<Long> id = createNumber("id", Long.class);
```

**역할**: 엔티티의 각 필드를 **타입 안전하게** 표현

| 엔티티 필드 | Q-클래스 필드 | 타입 |
|-----------|-------------|------|
| `String title` | `StringPath title` | 문자열 필드 |
| `Long id` | `NumberPath<Long> id` | 숫자 필드 |
| `String description` | `StringPath description` | 문자열 필드 |

**장점**:
```java
// ✅ 타입 안전: title은 StringPath이므로 문자열 메서드만 사용 가능
product.title.eq("TV")          // 가능
product.title.contains("TV")    // 가능
product.title.gt(10)            // ❌ 컴파일 에러! (문자열에 크기 비교 불가)

// ✅ IDE 자동완성 지원
product.title.  // ← 이 시점에 IDE가 사용 가능한 메서드 목록 표시
```

---

#### Q-클래스가 필요한 이유

| 문제 | JPQL | QueryDSL (Q-클래스) |
|-----|------|---------------------|
| **필드명 오타** | `"SELECT m FROM Member m WHERE m.nema = ?"` (오타 감지 불가) | `member.nema` (컴파일 에러 발생!) |
| **타입 불일치** | `"WHERE m.age = 'abc'"` (실행 시점 에러) | `member.age.eq("abc")` (컴파일 에러!) |
| **필드 삭제** | 엔티티에서 필드 삭제 시 문자열 쿼리는 그대로 (런타임 에러) | 컴파일 시점에 모든 참조 지점에서 에러 발생 |
| **리팩토링** | 필드명 변경 시 수동으로 모든 쿼리 수정 | IDE가 자동으로 모든 참조 변경 |

---

#### Q-클래스 생성 흐름

```
1. @Entity 클래스 작성 (Product.java)
   ↓
2. Gradle/Maven 빌드
   ↓
3. Annotation Processor 실행 (querydsl-apt)
   ↓
4. @Entity 분석
   ↓
5. Q-클래스 자동 생성 (QProduct.java)
   ↓
6. build/generated/sources/ 경로에 저장
   ↓
7. 개발자가 QProduct.product로 접근 가능
```

---

### 3.4.20.6 QueryDSL 설정 클래스

#### QueryDslConfig 클래스

**QueryDslConfig.java**:
```java
package com.example.queryDslSample.config;

import com.querydsl.jpa.impl.JPAQueryFactory;
import jakarta.persistence.EntityManager;
import jakarta.persistence.PersistenceContext;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class QueryDslConfig {
    
    @PersistenceContext
    private EntityManager em;

    @Bean
    public JPAQueryFactory jpaQueryFactory() {
        return new JPAQueryFactory(em);
    }
}
```

---

#### 설정 클래스의 역할

**목적**: QueryDSL이 JPA의 **EntityManager**를 통해 데이터베이스에 접근할 수 있도록 연결

```
[QueryDSL (쿼리 작성)]
    ↓
[JPAQueryFactory (쿼리 실행)]
    ↓
[EntityManager (DB 접근 + 영속성 컨텍스트 관리)]
    ↓
[데이터베이스]
```

---

#### 구성 요소 설명

##### 1. @Configuration

```java
@Configuration
public class QueryDslConfig {
```

**역할**: 이 클래스가 **Spring 설정 클래스**임을 선언

**의미**: Spring이 이 클래스를 읽어서 내부의 `@Bean` 메서드를 실행하고 빈을 등록

---

##### 2. EntityManager

```java
@PersistenceContext
private EntityManager em;
```

| 항목 | 설명 |
|-----|------|
| **EntityManager** | JPA의 핵심 인터페이스. **DB 접근 및 영속성 컨텍스트 관리**의 최종 책임자 |
| **`@PersistenceContext`** | EntityManager를 주입받는 **표준 방법** (트랜잭션 안전) |

**왜 `@Autowired`가 아닌 `@PersistenceContext`?**

| 어노테이션 | 용도 | 문제점 |
|-----------|------|--------|
| **`@Autowired`** | 일반 빈 주입 | EntityManager는 트랜잭션 단위로 생성/소멸되므로 부적합 |
| **`@PersistenceContext`** | EntityManager 전용 주입 | **트랜잭션 안전한 프록시 객체** 주입 |

**EntityManager의 역할**:
- QueryDSL이 생성한 쿼리를 **실제 DB에 실행**
- **영속성 컨텍스트**를 통해 엔티티 관리 (1차 캐시, 변경 감지 등)
- **트랜잭션 관리**

---

##### 3. JPAQueryFactory 빈 생성

```java
@Bean
public JPAQueryFactory jpaQueryFactory() {
    return new JPAQueryFactory(em);
}
```

| 항목 | 설명 |
|-----|------|
| **JPAQueryFactory** | QueryDSL 쿼리를 **실행**하는 엔진 |
| **`@Bean`** | 이 메서드가 반환하는 객체를 **Spring 컨테이너에 빈으로 등록** |

**JPAQueryFactory의 역할**:
```
1. 개발자가 작성한 QueryDSL 쿼리를 JPQL로 변환
2. EntityManager를 통해 JPQL을 DB에 실행
3. 결과를 Java 객체로 매핑하여 반환
```

**왜 `@Bean`으로 등록해야 하는가?**

| 항목 | 설명 |
|-----|------|
| **JPAQueryFactory** | QueryDSL 라이브러리의 클래스 (외부 라이브러리) |
| **문제** | Spring이 자동으로 감지하여 빈으로 만들 수 없음 |
| **해결** | 개발자가 직접 `new JPAQueryFactory(em)` 생성 후 `@Bean`으로 등록 |

---

#### 실행 흐름

```
1. 애플리케이션 시작
   ↓
2. @Configuration 클래스 스캔
   ↓
3. @PersistenceContext로 EntityManager 주입
   ↓
4. @Bean 메서드 실행
   ↓
5. new JPAQueryFactory(em) 생성
   ↓
6. Spring 컨테이너에 JPAQueryFactory 빈 등록
   ↓
7. 개발자가 JPAQueryFactory를 주입받아 사용 가능
```

---

#### 하나의 JPAQueryFactory로 모든 Q-클래스 사용 가능

**중요**: 하나의 `JPAQueryFactory` 빈으로 **모든 엔티티(Q-클래스)의 쿼리를 실행**할 수 있습니다.

```java
// 하나의 jpaQueryFactory로 여러 엔티티 쿼리 가능
QMember member = QMember.member;
QArticle article = QArticle.article;
QProduct product = QProduct.product;

// Member 조회
List<Member> members = jpaQueryFactory
    .selectFrom(member)
    .where(member.name.eq("hyechang"))
    .fetch();

// Article 조회
List<Article> articles = jpaQueryFactory
    .selectFrom(article)
    .where(article.title.like("방학%"))
    .fetch();

// Product 조회
List<Product> products = jpaQueryFactory
    .selectFrom(product)
    .where(product.description.contains("입니다"))
    .fetch();
```

**핵심**: JPAQueryFactory는 **쿼리 실행 엔진**일 뿐, 어떤 엔티티를 다루는지는 Q-클래스가 결정합니다.

---

### 3.4.20.7 사용자 정의 Repository 구조

#### 문제: Spring Data JPA만으로는 복잡한 동적 쿼리 어려움

**Spring Data JPA의 한계**:
```java
// 모든 조합을 메서드로 만들어야 함
List<Product> findByTitleContaining(String title);
List<Product> findByDescriptionContaining(String description);
List<Product> findByTitleContainingOrDescriptionContaining(String title, String description);
// ... 조합 폭발!
```

**해결**: QueryDSL을 사용한 **사용자 정의 Repository** 생성

---

#### 단계 1: 사용자 정의 인터페이스 정의

**ProductQueryDslRepository.java**:
```java
package com.example.queryDslSample;

import java.util.List;

public interface ProductQueryDslRepository {
    
    enum SearchType {
        TITLE,          // 제목 검색
        DESCRIPTION,    // 설명 검색
        BOTH            // 제목 또는 설명 검색
    }

    List<Product> queryByKeyword(String keyword, SearchType searchType, long offset, long limit);
}
```

**주의**: 이 인터페이스는 **`@Repository`를 붙이지 않습니다!**

**이유**: 구현체(`Impl`)에 `@Repository`를 붙여서 빈으로 등록할 것이기 때문

---

#### 단계 2: 구현 클래스 작성 (가장 중요!)

**ProductQueryDslRepositoryImpl.java**:
```java
package com.example.queryDslSample;

import com.querydsl.jpa.impl.JPAQuery;
import com.querydsl.jpa.impl.JPAQueryFactory;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository  // ← 구현체에 @Repository 붙임!
@RequiredArgsConstructor
public class ProductQueryDslRepositoryImpl implements ProductQueryDslRepository {
    
    private final JPAQueryFactory jpaQueryFactory;  // 주입받음

    @Override
    public List<Product> queryByKeyword(String keyword, SearchType searchType, long offset, long limit) {
        
        // 1. Q-클래스 준비
        QProduct product = QProduct.product;
        
        // 2. 쿼리 시작
        JPAQuery<Product> query = jpaQueryFactory.selectFrom(product);
        
        // 3. 동적 조건 추가
        switch (searchType) {
            case TITLE:
                query = query.where(product.title.contains(keyword));
                break;
                
            case DESCRIPTION:
                query = query.where(product.description.contains(keyword));
                break;
                
            case BOTH:
                query = query.where(
                    product.title.contains(keyword)
                        .or(product.description.contains(keyword))
                );
                break;
        }
        
        // 4. 정렬, 페이징, 실행
        return query
            .orderBy(product.id.desc())
            .offset(offset)
            .limit(limit)
            .fetch();
    }
}
```

---

#### 구현 클래스 핵심 요소

##### 1. 클래스명 규칙 (매우 중요!)

```
인터페이스명 + Impl
```

| 인터페이스 | 구현 클래스 | 비고 |
|-----------|------------|------|
| `ProductQueryDslRepository` | `ProductQueryDslRepositoryImpl` | ✅ Spring이 자동 인식 |
| `ProductQueryDslRepository` | `ProductQueryDslRepositoryImplCustom` | ❌ 인식 안 됨 |

**핵심**: 반드시 `Impl`로 끝나야 Spring Data JPA가 자동으로 찾아서 연결합니다!

---

##### 2. @Repository 어노테이션

```java
@Repository
public class ProductQueryDslRepositoryImpl
```

**역할**: 이 구현체를 **Spring 빈으로 등록**

**중요**: 인터페이스가 아닌 **구현체에** `@Repository`를 붙입니다!

---

##### 3. JPAQueryFactory 주입

```java
private final JPAQueryFactory jpaQueryFactory;
```

**의존성 주입**:
```
QueryDslConfig에서 @Bean으로 등록한 JPAQueryFactory를 주입받음
    ↓
이 객체를 통해 QueryDSL 쿼리 실행
```

---

##### 4. Q-클래스 사용

```java
QProduct product = QProduct.product;
```

**QProduct.product**: 빌드 시 자동 생성된 정적 필드

**사용**:
```java
jpaQueryFactory
    .selectFrom(product)          // SELECT * FROM product
    .where(product.title.eq("TV")) // WHERE title = 'TV'
    .fetch();                      // 실행 및 결과 반환
```

---

##### 5. 동적 쿼리 작성

```java
JPAQuery<Product> query = jpaQueryFactory.selectFrom(product);

switch (searchType) {
    case TITLE:
        query = query.where(product.title.contains(keyword));
        break;
}
```

**핵심**: `JPAQuery` 객체를 **변수에 저장**하고, 조건에 따라 **체이닝을 이어가는 방식**

**JPQL과 비교**:

| 방식 | 코드 |
|-----|------|
| **JPQL** | `"SELECT p FROM Product p WHERE " + (조건 ? "p.title LIKE ..." : "")` (문자열 조합 복잡) |
| **QueryDSL** | `query.where(조건 ? product.title.contains(...) : null)` (메서드 체이닝) |

---

#### QueryDSL 주요 메서드

##### 조회 메서드

| 메서드 | 설명 | 반환 타입 |
|-------|------|----------|
| **`selectFrom(entity)`** | SELECT * FROM 테이블 | `JPAQuery<T>` |
| **`select(필드1, 필드2...)`** | 특정 필드만 조회 | `JPAQuery<Tuple>` 또는 `JPAQuery<DTO>` |

**예시**:
```java
// 전체 조회
jpaQueryFactory.selectFrom(product)  // Product 엔티티 전체

// 특정 필드만
jpaQueryFactory.select(product.title, product.description)  // 제목, 설명만
```

---

##### 조건 메서드 (WHERE)

| 메서드 | 의미 | SQL |
|-------|------|-----|
| **`.eq(값)`** | 같다 | `= 값` |
| **`.ne(값)`** | 같지 않다 | `!= 값` |
| **`.contains(값)`** | 포함 | `LIKE '%값%'` |
| **`.startsWith(값)`** | ~로 시작 | `LIKE '값%'` |
| **`.endsWith(값)`** | ~로 끝남 | `LIKE '%값'` |
| **`.gt(값)`** | 크다 | `> 값` |
| **`.goe(값)`** | 크거나 같다 | `>= 값` |
| **`.lt(값)`** | 작다 | `< 값` |
| **`.loe(값)`** | 작거나 같다 | `<= 값` |
| **`.between(최소, 최대)`** | 범위 | `BETWEEN 최소 AND 최대` |
| **`.isNull()`** | NULL | `IS NULL` |
| **`.isNotNull()`** | NOT NULL | `IS NOT NULL` |

**예시**:
```java
product.title.eq("TV")                     // title = 'TV'
product.title.contains("컴퓨터")            // title LIKE '%컴퓨터%'
product.id.gt(10)                          // id > 10
product.id.between(1, 100)                 // id BETWEEN 1 AND 100
```

---

##### 조건 결합 (AND, OR)

```java
// AND (모두 만족)
.where(product.title.contains("TV"), product.id.gt(10))
// WHERE title LIKE '%TV%' AND id > 10

// OR (하나라도 만족)
.where(product.title.contains("TV").or(product.description.contains("TV")))
// WHERE title LIKE '%TV%' OR description LIKE '%TV%'
```

**핵심**: `where()` 안에 콤마(`,`)로 나열하면 **AND**, `.or()`로 연결하면 **OR**

---

##### 정렬, 페이징, 실행

| 메서드 | 역할 | 예시 |
|-------|------|------|
| **`.orderBy(필드.asc/desc())`** | 정렬 | `.orderBy(product.id.desc())` |
| **`.offset(숫자)`** | 건너뛸 개수 | `.offset(10)` (11번째부터) |
| **`.limit(숫자)`** | 가져올 개수 | `.limit(5)` (5개만) |
| **`.fetch()`** | 리스트 반환 | `List<Product>` |
| **`.fetchOne()`** | 단건 반환 | `Product` 또는 `null` |
| **`.fetchFirst()`** | 첫 번째만 | `Product` 또는 `null` |
| **`.fetchCount()`** | 개수
```java
**`.fetchCount()`** | 개수만 | `long` (Deprecated, count() 사용 권장) |

**예시**:
```java
List<Product> results = jpaQueryFactory
    .selectFrom(product)
    .where(product.title.contains("컴퓨터"))
    .orderBy(product.id.desc())  // ID 내림차순
    .offset(0)                   // 첫 페이지
    .limit(10)                   // 10개만
    .fetch();                    // 실행
```

---

### 3.4.20.8 통합 Repository 패턴 (가장 중요!)

#### 문제: QueryDSL Repository를 어떻게 사용하는가?

**잘못된 방법**:
```java
// ❌ 두 개의 Repository를 따로 주입?
@RequiredArgsConstructor
public class ProductService {
    private final ProductRepository productRepository;  // JPA용
    private final ProductQueryDslRepositoryImpl queryDslRepo;  // QueryDSL용
}
```

**문제점**: 관리 포인트가 2개로 늘어남, 일관성 없음

---

#### 해결: 통합 Repository 인터페이스

**ProductRepository.java**:
```java
package com.example.queryDslSample;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.List;

@Repository
public interface ProductRepository extends JpaRepository<Product, Long>, ProductQueryDslRepository {
    
    // Spring Data JPA 쿼리 메서드
    List<Product> findByTitleContaining(String title);
}
```

**구조**:
```
ProductRepository (인터페이스)
├─ extends JpaRepository<Product, Long>        (Spring Data JPA 기능)
└─ extends ProductQueryDslRepository           (QueryDSL 기능)
```

---

#### Spring의 통합 메커니즘 (핵심 원리!)

**문제**: `ProductQueryDslRepository`는 인터페이스인데, Spring이 어떻게 구현체를 찾는가?

**해결**: Spring Data JPA의 **자동 탐색 및 위임 패턴**

```
1. Spring이 ProductRepository 인터페이스 발견
   ↓
2. JpaRepository 부분: Spring이 자동으로 구현 코드 생성
   ↓
3. ProductQueryDslRepository 부분: 
   "ProductQueryDslRepository + Impl" 이름의 클래스를 찾음
   ↓
4. ProductQueryDslRepositoryImpl 발견 (@Repository 빈)
   ↓
5. 최종 프록시 객체 생성:
   - JpaRepository 메서드: Spring이 자동 처리
   - ProductQueryDslRepository 메서드: Impl 객체에 위임
```

---

#### 최종 프록시 객체 구조 (개념적 표현)

```java
// Spring이 런타임에 생성하는 가상의 프록시 클래스
public class ProductRepositoryProxy implements ProductRepository {

    // 1. JPA 기본 기능 처리 (Spring이 자동 생성)
    private final JpaRepositoryDelegate jpaDelegate;
    
    // 2. QueryDSL 사용자 정의 기능 처리 (개발자가 작성)
    private final ProductQueryDslRepositoryImpl customImpl;  // ← 주입받음!

    // --- JpaRepository 메서드 ---
    @Override
    public Product save(Product entity) {
        return jpaDelegate.executeSave(entity);  // Spring이 자동 처리
    }

    @Override
    public List<Product> findAll() {
        return jpaDelegate.executeFindAll();  // Spring이 자동 처리
    }

    // --- 쿼리 메서드 ---
    @Override
    public List<Product> findByTitleContaining(String title) {
        return jpaDelegate.executeQuery(...);  // Spring이 자동 생성
    }

    // --- ProductQueryDslRepository 메서드 ---
    @Override
    public List<Product> queryByKeyword(String keyword, SearchType searchType, long offset, long limit) {
        return customImpl.queryByKeyword(keyword, searchType, offset, limit);  // ← 위임!
    }
}
```

**핵심**: 
- `JpaRepository` 메서드: Spring이 **직접 구현**
- `ProductQueryDslRepository` 메서드: **Impl 객체에 위임**

---

#### 통합 Repository 비교표

| 기능 | 코드 출처 | 내부 처리 | 구현체 필요 |
|-----|----------|---------|-----------|
| **JpaRepository 기본 CRUD** (`save`, `findById`) | Spring Data JPA (자동) | Spring이 직접 런타임 코드 생성 | ❌ 불필요 |
| **쿼리 메서드** (`findByTitleContaining`) | Spring Data JPA (자동) | 메서드 이름 분석 후 자동 생성 | ❌ 불필요 |
| **QueryDSL 사용자 정의** (`queryByKeyword`) | 개발자 (수동) | `ProductQueryDslRepositoryImpl`에 위임 | ✅ 필수 |

---

### 3.4.20.9 애플리케이션 실행 예시

**QueryDslApplication.java**:
```java
package com.example.queryDslSample;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.boot.ApplicationArguments;
import org.springframework.boot.ApplicationRunner;
import org.springframework.stereotype.Component;
import java.util.List;

@Component
@RequiredArgsConstructor
@Slf4j
public class QueryDslApplication implements ApplicationRunner {
    
    private final ProductRepository repository;  // ← 통합 Repository 주입

    @Override
    public void run(ApplicationArguments args) throws Exception {
        
        // 1. 데이터 생성
        Product product1 = Product.builder()
                                  .title("tv")
                                  .description("최신 티비입니다.")
                                  .build();
        
        Product product2 = Product.builder()
                                  .title("컴퓨터")
                                  .description("게임용 컴퓨터입니다.")
                                  .build();
        
        Product product3 = Product.builder()
                                  .title("냉장고")
                                  .description("LG냉장고입니다.")
                                  .build();

        // ========================================
        // 2. JpaRepository 기본 CRUD 사용
        // ========================================
        repository.save(product1);
        repository.save(product2);
        repository.save(product3);
        log.info("=== JpaRepository save() 완료 ===");

        // ========================================
        // 3. Spring Data JPA 쿼리 메서드 사용
        // ========================================
        List<Product> lists = repository.findByTitleContaining("장고");
        log.info("=== findByTitleContaining('장고') 결과 ===");
        for (Product product : lists) {
            log.info(product.toString());
        }

        // ========================================
        // 4. QueryDSL 사용자 정의 메서드 사용
        // ========================================
        lists = repository.queryByKeyword(
            "입니다", 
            ProductQueryDslRepository.SearchType.DESCRIPTION, 
            0, 
            2
        );
        log.info("=== queryByKeyword('입니다', DESCRIPTION, 0, 2) 결과 ===");
        for (Product product : lists) {
            log.info(product.toString());
        }
    }
}
```

---

#### 실행 결과 분석

**생성된 데이터**:
```
id | title    | description
1  | tv       | 최신 티비입니다.
2  | 컴퓨터   | 게임용 컴퓨터입니다.
3  | 냉장고   | LG냉장고입니다.
```

**쿼리 실행 결과**:

##### 1. JpaRepository 사용
```java
repository.save(product1);
```
**생성된 SQL**:
```sql
INSERT INTO product (title, description) VALUES ('tv', '최신 티비입니다.');
```

##### 2. 쿼리 메서드 사용
```java
repository.findByTitleContaining("장고");
```
**생성된 SQL**:
```sql
SELECT * FROM product WHERE title LIKE '%장고%';
```
**결과**: `Product(id=3, title=냉장고, description=LG냉장고입니다.)`

##### 3. QueryDSL 사용
```java
repository.queryByKeyword("입니다", SearchType.DESCRIPTION, 0, 2);
```
**생성된 SQL**:
```sql
SELECT * FROM product 
WHERE description LIKE '%입니다%' 
ORDER BY id DESC 
LIMIT 2 OFFSET 0;
```
**결과**:
```
Product(id=3, title=냉장고, description=LG냉장고입니다.)
Product(id=2, title=컴퓨터, description=게임용 컴퓨터입니다.)
```

---

### 3.4.20.10 통합 사용 패턴 정리

#### 하나의 Repository로 3가지 방식 사용

```java
private final ProductRepository repository;

// 1️⃣ JpaRepository 기본 CRUD
repository.save(product);
repository.findById(1L);
repository.findAll();
repository.delete(product);

// 2️⃣ Spring Data JPA 쿼리 메서드
repository.findByTitleContaining("TV");

// 3️⃣ QueryDSL 사용자 정의 메서드
repository.queryByKeyword("검색어", SearchType.BOTH, 0, 10);
```

**장점**:
- ✅ **단일 진입점**: 하나의 Repository만 주입받으면 됨
- ✅ **일관성**: 모든 데이터 접근이 한 곳에서 관리됨
- ✅ **유지보수 용이**: 코드 변경 시 하나의 인터페이스만 확인

---

### 3.4.20.11 QueryDSL 실행 흐름 (전체)

```
1. 개발자가 ProductRepository 주입받음
   ↓
2. repository.queryByKeyword(...) 호출
   ↓
3. Spring이 ProductRepositoryProxy (프록시 객체) 실행
   ↓
4. 프록시가 ProductQueryDslRepositoryImpl.queryByKeyword() 호출 (위임)
   ↓
5. JPAQueryFactory가 QueryDSL 코드를 JPQL로 변환
   ↓
6. EntityManager가 JPQL을 SQL로 변환
   ↓
7. JDBC Driver를 통해 DB에 SQL 실행
   ↓
8. 결과를 Product 엔티티로 매핑
   ↓
9. 영속성 컨텍스트에 저장 (1차 캐시)
   ↓
10. 개발자에게 List<Product> 반환
```

---

### 3.4.20.12 QueryDSL vs 다른 방식 최종 비교

#### 코드 비교

**쿼리 메서드**:
```java
// 모든 조합을 메서드로 만들어야 함
List<Product> findByTitleContaining(String title);
List<Product> findByDescriptionContaining(String description);
List<Product> findByTitleContainingOrDescriptionContaining(String t, String d);
```

**JPQL**:
```java
@Query("SELECT p FROM Product p WHERE " +
       "(:title IS NULL OR p.title LIKE %:title%) AND " +
       "(:description IS NULL OR p.description LIKE %:description%)")
List<Product> search(@Param("title") String title, @Param("description") String desc);
```

**QueryDSL**:
```java
JPAQuery<Product> query = jpaQueryFactory.selectFrom(product);

if (title != null) {
    query = query.where(product.title.contains(title));
}
if (description != null) {
    query = query.where(product.description.contains(description));
}

return query.fetch();
```

---

#### 장단점 비교

| 항목 | 쿼리 메서드 | JPQL | QueryDSL |
|-----|-----------|------|----------|
| **간단한 CRUD** | ✅ 최적 | 🟡 가능 | 🟡 가능 |
| **복잡한 조건** | ❌ 메서드명 길어짐 | ✅ 가능 | ✅ 가능 |
| **동적 쿼리** | ❌ 매우 어려움 | 🟡 가능하나 복잡 | ✅ **매우 쉬움** ⭐ |
| **컴파일 시 검증** | ❌ 불가능 | ❌ 불가능 | ✅ **가능** ⭐ |
| **타입 안전성** | ❌ 없음 | ❌ 없음 | ✅ **완벽 지원** ⭐ |
| **리팩토링** | 🟡 IDE 지원 제한적 | ❌ 수동 | ✅ **자동** ⭐ |
| **학습 곡선** | 낮음 | 중간 | 중간 |
| **코드 양** | 적음 | 중간 | 중간 |

---

### 3.4.20.13 QueryDSL 사용 권장 시나리오

| 상황 | 권장 방법 | 이유 |
|-----|---------|------|
| **단순 CRUD** | 쿼리 메서드 또는 JpaRepository | 간단하고 직관적 |
| **단순 검색** | 쿼리 메서드 | 자동 생성으로 충분 |
| **복잡한 조건 (고정)** | JPQL (`@Query`) | SQL 제어 가능 |
| **동적 검색 조건** | **QueryDSL** ⭐ | 조건 조합 자유로움 |
| **복잡한 JOIN + 동적 조건** | **QueryDSL** ⭐ | 타입 안전 + 가독성 |
| **통계/집계 쿼리** | **QueryDSL** | 타입 안전 + 리팩토링 지원 |
| **대규모 프로젝트** | **QueryDSL** ⭐ | 유지보수성 극대화 |

---

### 3.4.20.14 핵심 정리

#### QueryDSL의 3대 핵심

| 개념 | 핵심 내용 |
|-----|----------|
| **1. Q-클래스** | 엔티티를 기반으로 자동 생성되는 쿼리 전용 클래스 (타입 안전성 보장) |
| **2. JPAQueryFactory** | QueryDSL 쿼리를 JPQL로 변환하고 EntityManager를 통해 실행하는 엔진 |
| **3. 통합 Repository** | JpaRepository + QueryDSL 사용자 정의 인터페이스를 상속하여 단일 진입점 제공 |

---

#### QueryDSL 설정 체크리스트

| 항목 | 필수 작업 | 확인 |
|-----|----------|------|
| **의존성** | `querydsl-jpa`, `querydsl-apt` 추가 | ✅ |
| **Q-클래스 생성** | 빌드 후 `build/generated/` 확인 | ✅ |
| **설정 클래스** | `JPAQueryFactory` 빈 등록 | ✅ |
| **사용자 정의 인터페이스** | 메서드 정의 | ✅ |
| **구현 클래스** | `인터페이스명 + Impl` 작성 | ✅ |
| **`@Repository`** | 구현 클래스에 붙임 | ✅ |
| **통합 Repository** | `JpaRepository` + 사용자 정의 인터페이스 상속 | ✅ |

---

#### QueryDSL vs JPA 관계 요약

```
QueryDSL은 JPA를 대체하는 것이 아니라 보완하는 도구입니다.

[QueryDSL]
    ↓ (타입 안전한 쿼리 작성)
[JPQL]
    ↓ (객체 지향 쿼리)
[JPA/Hibernate]
    ↓ (SQL 자동 생성 + 영속성 컨텍스트)
[JDBC Driver]
    ↓
[데이터베이스]
```

**핵심**: 
- QueryDSL은 **JPQL의 문자열 쿼리**를 **타입 안전한 자바 코드**로 작성할 수 있게 해줍니다.
- JPA의 모든 장점(영속성 컨텍스트, 트랜잭션, 자동 매핑)은 **그대로 유지**됩니다.

---

#### 최종 코드 흐름

```java
// 1. Q-클래스 준비 (빌드 시 자동 생성)
QProduct product = QProduct.product;

// 2. JPAQueryFactory로 쿼리 시작
JPAQuery<Product> query = jpaQueryFactory.selectFrom(product);

// 3. 동적 조건 추가 (타입 안전!)
if (keyword != null) {
    query = query.where(product.title.contains(keyword));
}

// 4. 실행 (JPA/Hibernate가 SQL로 변환 후 실행)
List<Product> results = query.fetch();
```

**모든 과정에서**:
- ✅ 컴파일러가 타입 체크
- ✅ IDE가 자동완성 지원
- ✅ 리팩토링 시 자동 반영
- ✅ JPA의 영속성 컨텍스트 유지

---




