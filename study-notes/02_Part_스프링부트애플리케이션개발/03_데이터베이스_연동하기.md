# 03_데이터베이스_연동하기

<!--
# 첫 작성 (3.1 JDBC)
docs: [Ch03] 데이터베이스 연동 - JDBC 추가

# 다음 업데이트 (3.2, 3.3 추가)
docs: [Ch03] 데이터베이스 연동 - Spring Data JDBC, MyBatis 추가

# 마지막 완료 (3.4, 3.5 추가)
docs: [Ch03] 데이터베이스 연동 - JPA, MongoDB 추가 및 완료

-->

## 📌 학습 목표
스프링부트에서 데이터베이스에 접근하는 다양한 방법을 이해하고, 각 방식의 특징과 사용법을 익힌다.

---

## 목차

- [3.1 JDBC](#31-jdbc)
- [3.2 Spring Data JDBC](#32-spring-data-jdbc) 
- [3.3 MyBatis](#33-mybatis) 
- [3.4 JPA](#34-jpa) 
- [3.5 MongoDB](#35-mongodb) 

---

## 3.1 JDBC

### 3.1.1 JDBC란?

**JDBC (Java Database Connectivity)** 는 Java 애플리케이션에서 데이터베이스에 접근하기 위한 **표준 API**입니다.

#### JDBC의 구성 요소

```
[Java 애플리케이션]
      ↓
[JDBC API] ← Java가 제공하는 표준 인터페이스
      ↓
[JDBC Driver] ← 각 DB 벤더가 제공하는 구현체
      ↓
[데이터베이스 (MySQL, Oracle, PostgreSQL 등)]
```

| 구성 요소 | 제공자 | 역할 |
|----------|-------|------|
| **JDBC API** | Java (Oracle) | 데이터베이스 접근을 위한 표준 인터페이스 정의 |
| **JDBC Driver** | 각 DB 벤더 (MySQL, Oracle 등) | JDBC API의 실제 구현체 |
| **데이터베이스** | DB 벤더 | 실제 데이터 저장 및 관리 |

#### JDBC Driver의 역할

**JDBC Driver**는 Java 애플리케이션과 특정 데이터베이스 간의 **통신을 담당하는 브리지(다리)** 역할을 합니다.

- MySQL JDBC Driver: `mysql-connector-j`
- PostgreSQL JDBC Driver: `postgresql`
- Oracle JDBC Driver: `ojdbc`

**비유**:
```
JDBC API = USB 규격 (표준 인터페이스)
JDBC Driver = USB 케이블 (제조사별 구현)
데이터베이스 = USB 장치
```

#### 왜 JDBC가 필요한가?

**문제 상황**:
- 데이터베이스마다 통신 방식이 다름
- MySQL, Oracle, PostgreSQL 등 각각 다른 방식으로 접근

**JDBC의 해결**:
- **표준화된 인터페이스 제공**
- 개발자는 JDBC API만 사용
- 데이터베이스 변경 시 Driver만 교체하면 됨

```java
// MySQL이든 Oracle이든 코드는 동일!
Connection conn = DriverManager.getConnection(url, user, password);
Statement stmt = conn.createStatement();
ResultSet rs = stmt.executeQuery("SELECT * FROM member");
```

---

### 3.1.2 데이터베이스 초기 설정

#### DBeaver를 통한 데이터 초기화

**실습 환경**:
- 데이터베이스: MySQL 8.4
- 관리 도구: DBeaver Community 25.2.2
- 데이터베이스명: `mydb`
- 사용자: `myuser` / 비밀번호: `mypass`

#### SQL 스크립트

```sql
-- ========================================
-- 1. 데이터베이스 생성
-- ========================================
-- mydb라는 이름의 데이터베이스 공간을 생성합니다.
-- IF NOT EXISTS: 이미 존재하면 생략 (에러 방지)
CREATE DATABASE IF NOT EXISTS mydb;

-- ========================================
-- 2. 사용자 생성 및 인증
-- ========================================
-- myuser 계정을 생성합니다.
-- @'%': 모든 호스트(IP)에서 접속 허용
-- IDENTIFIED BY 'mypass': 비밀번호를 mypass로 설정
CREATE USER IF NOT EXISTS 'myuser'@'%' IDENTIFIED BY 'mypass';

-- ========================================
-- 3. 권한 부여
-- ========================================
-- myuser가 mydb 데이터베이스의 모든 객체(테이블, 뷰 등)에 대해
-- 모든 권한(SELECT, INSERT, UPDATE, DELETE, CREATE, DROP 등)을 가지도록 설정
GRANT ALL ON mydb.* TO 'myuser'@'%';

-- ========================================
-- 4. 데이터베이스 선택
-- ========================================
USE mydb;

-- ========================================
-- 5. 테이블 생성
-- ========================================
CREATE TABLE IF NOT EXISTS member(
    id INTEGER AUTO_INCREMENT PRIMARY KEY,  -- 자동 증가 기본키
    name VARCHAR(128) NOT NULL,             -- 이름 (필수)
    email VARCHAR(256) NOT NULL,            -- 이메일 (필수)
    age INTEGER                             -- 나이 (선택)
);

-- ========================================
-- 6. 데이터 삽입
-- ========================================
INSERT INTO member(name, email, age) VALUES ('김우현', 'kimwoo@spring.co.kr', 10);
INSERT INTO member(name, email, age) VALUES ('홍혜창', 'hyechang@spring.co.kr', 20);
INSERT INTO member(name, email, age) VALUES ('윤서준', 'Seojunyoon@spring.co.kr', 22);
INSERT INTO member(name, email, age) VALUES ('김민수', 'minsusu@spring.co.kr', 30);

-- ========================================
-- 7. 데이터 조회 (확인)
-- ========================================
SELECT * FROM member;
```

#### SQL 명령어 설명

| 명령어 | 역할 | 설명 |
|-------|------|------|
| `CREATE DATABASE` | 데이터베이스 생성 | 데이터를 저장할 논리적 공간 생성 |
| `CREATE USER` | 사용자 계정 생성 | 데이터베이스 접속 계정 생성 |
| `GRANT` | 권한 부여 | 특정 사용자에게 DB 작업 권한 부여 |
| `USE` | 데이터베이스 선택 | 작업할 데이터베이스 지정 |
| `CREATE TABLE` | 테이블 생성 | 데이터를 저장할 테이블 구조 정의 |
| `INSERT INTO` | 데이터 삽입 | 테이블에 레코드 추가 |
| `SELECT` | 데이터 조회 | 테이블의 데이터 검색 |

#### 데이터 확인

```
+----+----------+-------------------------+------+
| id | name     | email                   | age  |
+----+----------+-------------------------+------+
|  1 | 김우현   | kimwoo@spring.co.kr     |   10 |
|  2 | 홍혜창   | hyechang@spring.co.kr   |   20 |
|  3 | 윤서준   | Seojunyoon@spring.co.kr |   22 |
|  4 | 김민수   | minsusu@spring.co.kr    |   30 |
+----+----------+-------------------------+------+
```

---

### 3.1.3 프로젝트 설정

#### 의존성 추가

**build.gradle**:
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter'
    
    // MySQL JDBC Driver
    implementation 'com.mysql:mysql-connector-j:9.2.0'
    
    // Lombok (코드 자동 생성)
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    
    // 테스트
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

#### 의존성 설명

| 의존성 | 역할 |
|-------|------|
| `spring-boot-starter` | 스프링부트 기본 기능 |
| `mysql-connector-j:9.2.0` | **MySQL JDBC Driver** (핵심!) |
| `lombok` | Getter, Setter 등 자동 생성 |

> ⚠️ **중요**: `mysql-connector-j`를 추가해야 MySQL과 통신할 수 있는 JDBC Driver가 프로젝트에 포함됩니다!

**JDBC Driver 포함 확인**:
```
프로젝트 구조
└─ External Libraries
   └─ com.mysql:mysql-connector-j:9.2.0
      └─ com.mysql.cj.jdbc.Driver ← JDBC Driver 클래스
```

---

### 3.1.4 엔티티 클래스 작성

**Member.java**:
```java
package kr.ac.hansung.cse.databasesample;

import lombok.*;

/**
 * Member 엔티티 클래스
 * - 데이터베이스의 member 테이블과 매핑되는 Java 객체
 * - Lombok을 사용하여 반복 코드 최소화
 */
@AllArgsConstructor  // 모든 필드를 매개변수로 받는 생성자 자동 생성
@ToString            // toString() 메서드 자동 생성
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

#### Lombok 애노테이션

| 애노테이션 | 생성 코드 |
|-----------|----------|
| `@AllArgsConstructor` | `public Member(Long id, String name, String email, Integer age) { ... }` |
| `@ToString` | `public String toString() { return "Member(id=1, name=김우현, ...)"; }` |

---

### 3.1.5 JDBC를 사용한 데이터베이스 연동

#### 전체 코드

**DatabaseSampleApplication.java**:
```java
package kr.ac.hansung.cse.databasesample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.sql.*;

@SpringBootApplication
public class DatabaseSampleApplication {

    public static void main(String[] args) throws ClassNotFoundException, SQLException {
        
        SpringApplication.run(DatabaseSampleApplication.class, args);

        // ========================================
        // 1. JDBC Driver 로딩
        // ========================================
        /*
         * Class.forName()의 역할:
         * - JDBC Driver 클래스를 JVM 메모리에 로드
         * - 로드된 Driver는 DriverManager에 자동 등록됨
         * - DriverManager가 MySQL 접속 방법을 알게 됨
         * 
         * "com.mysql.cj.jdbc.Driver":
         * - mysql-connector-j 라이브러리에 포함된 MySQL JDBC Driver 클래스
         * - 이 클래스가 JDBC API를 실제로 구현함
         * 
         * 참고: JDBC 4.0 이후로는 자동 로딩되지만, 명시적 표현을 위해 작성
         */
        Class.forName("com.mysql.cj.jdbc.Driver");

        // ========================================
        // 2. 데이터베이스 연결
        // ========================================
        /*
         * DriverManager.getConnection()의 역할:
         * - 실제 데이터베이스와의 연결(Connection) 객체 생성
         * 
         * 첫 번째 매개변수 (JDBC URL):
         * "jdbc:mysql://localhost:3306/mydb"
         *  ──── ───── ───────── ──── ────
         *   │     │       │       │     └─ 데이터베이스 이름
         *   │     │       │       └─ 포트 번호 (MySQL 기본: 3306)
         *   │     │       └─ 서버 주소 (localhost = 내 컴퓨터)
         *   │     └─ 데이터베이스 종류 (MySQL)
         *   └─ JDBC 프로토콜
         * 
         * 두 번째 매개변수: 사용자 이름 (myuser)
         * 세 번째 매개변수: 비밀번호 (mypass)
         */
        Connection connection = DriverManager.getConnection(
            "jdbc:mysql://localhost:3306/mydb",
            "myuser",
            "mypass"
        );

        // ========================================
        // 3. SQL 쿼리 준비
        // ========================================
        /*
         * PreparedStatement의 역할:
         * - SQL 쿼리를 데이터베이스에 미리 전송
         * - 실행 가능한 상태로 준비 (컴파일)
         * - SQL Injection 방지 (매개변수 바인딩 시)
         * 
         * "select * from member":
         * - member 테이블의 모든 컬럼(*), 모든 행 조회
         */
        PreparedStatement preparedStatement = connection.prepareStatement(
            "select * from member"
        );

        // ========================================
        // 4. 쿼리 실행
        // ========================================
        /*
         * executeQuery()의 역할:
         * - SELECT 쿼리 실행 (데이터 조회)
         * - 결과를 ResultSet 객체로 반환
         * 
         * ResultSet:
         * - 쿼리 결과를 담고 있는 객체
         * - 커서(cursor)를 사용하여 한 행씩 접근
         */
        ResultSet resultSet = preparedStatement.executeQuery();

        // ========================================
        // 5. 결과 처리
        // ========================================
        /*
         * while (resultSet.next()):
         * - 다음 행으로 커서 이동
         * - 더 이상 행이 없으면 false 반환 (반복 종료)
         * 
         * resultSet.getLong("id"):
         * - 현재 행의 "id" 컬럼 값을 Long 타입으로 가져옴
         * 
         * resultSet.getString("name"):
         * - 현재 행의 "name" 컬럼 값을 String 타입으로 가져옴
         * 
         * resultSet.getInt("age"):
         * - 현재 행의 "age" 컬럼 값을 Integer 타입으로 가져옴
         */
        while (resultSet.next()) {
            Member member = new Member(
                resultSet.getLong("id"),
                resultSet.getString("name"),
                resultSet.getString("email"),
                resultSet.getInt("age")
            );
            System.out.println(member);
        }

        // ========================================
        // 6. 연결 종료
        // ========================================
        /*
         * connection.close()의 역할:
         * - 데이터베이스 연결 해제
         * - 리소스(메모리, 네트워크) 반환
         * - 반드시 호출해야 함 (리소스 누수 방지)
         * 
         * 권장: try-with-resources 사용
         */
        connection.close();
    }
}
```

#### 실행 결과

```
Member(id=1, name=김우현, email=kimwoo@spring.co.kr, age=10)
Member(id=2, name=홍혜창, email=hyechang@spring.co.kr, age=20)
Member(id=3, name=윤서준, email=Seojunyoon@spring.co.kr, age=22)
Member(id=4, name=김민수, email=minsusu@spring.co.kr, age=30)
```

---

### 3.1.6 JDBC 동작 과정 상세 분석

#### 1단계: Driver 로딩

```java
Class.forName("com.mysql.cj.jdbc.Driver");
```

**내부 동작**:
```
1. JVM이 "com.mysql.cj.jdbc.Driver" 클래스 파일 로드
2. Driver 클래스의 static 초기화 블록 실행
3. Driver 객체가 DriverManager에 자동 등록
4. DriverManager: "MySQL과 통신하는 방법을 알게 되었다!"
```


#### 2단계: Connection 생성

```java
Connection connection = DriverManager.getConnection(
    "jdbc:mysql://localhost:3306/mydb",
    "myuser",
    "mypass"
);
```

**내부 동작**:
```
1. DriverManager가 등록된 Driver들을 순회
2. URL이 "jdbc:mysql"로 시작 → MySQL Driver 선택
3. MySQL Driver가 실제 연결 시도
   - TCP 소켓 연결 (localhost:3306)
   - 인증 확인 (myuser/mypass)
   - mydb 데이터베이스 선택
4. Connection 객체 반환
```

**Connection 객체의 역할**:
- 데이터베이스와의 **세션(Session)** 을 나타냄
- 이 연결을 통해 SQL을 실행하고 결과를 받음

#### 3단계: Statement 생성 및 실행

```java
PreparedStatement preparedStatement = connection.prepareStatement(
    "select * from member"
);
ResultSet resultSet = preparedStatement.executeQuery();
```

**내부 동작**:
```
1. SQL 문자열을 MySQL 서버로 전송
2. MySQL이 SQL을 파싱(분석)하고 실행 계획 수립
3. 쿼리 실행
4. 결과를 ResultSet으로 반환
   (네트워크를 통해 Java 애플리케이션으로 전송)
```

#### 4단계: 결과 처리

```java
while (resultSet.next()) {
    // 데이터 읽기
}
```

**ResultSet의 구조**:
```
커서 위치 (처음에는 첫 행 이전)
    ↓
[Before First] ← resultSet.next() 호출 전
[Row 1] id=1, name=김우현, ...  ← resultSet.next() → true
[Row 2] id=2, name=홍혜창, ...  ← resultSet.next() → true
[Row 3] id=3, name=윤서준, ...  ← resultSet.next() → true
[Row 4] id=4, name=김민수, ...  ← resultSet.next() → true
[After Last] ← resultSet.next() → false (반복 종료)
```

---

### 3.1.7 JDBC의 문제점

#### 문제 1: 반복적인 코드

```java
// 매번 작성해야 하는 코드
Connection conn = DriverManager.getConnection(...);
PreparedStatement stmt = conn.prepareStatement(...);
ResultSet rs = stmt.executeQuery();
while (rs.next()) {
    // 매핑 코드
}
conn.close();
```

#### 문제 2: 수동 매핑

```java
// 컬럼과 객체 필드를 수동으로 매핑
Member member = new Member(
    rs.getLong("id"),
    rs.getString("name"),
    rs.getString("email"),
    rs.getInt("age")
);
```

#### 문제 3: 리소스 관리

```java
// close()를 깜빡하면 리소스 누수!
connection.close();  // 반드시 호출해야 함
```

#### 문제 4: 예외 처리

```java
// 체크 예외(Checked Exception) 처리 필요
throws ClassNotFoundException, SQLException
```

**이러한 문제들을 해결하기 위해 등장한 것이:**
- Spring Data JDBC (3.2)
- MyBatis (3.3)
- JPA (3.4)

---


*작성일: 2025-10-13*  
*학습 목표: JDBC를 사용한 데이터베이스 연동 이해* ✅
