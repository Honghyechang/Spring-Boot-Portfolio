# 05_스프링부트로_게시판_만들기

<!--
# 첫 작성 (5.1)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 웹 애플리케이션과 MVC 모델 추가

# 다음 업데이트 (5.2 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 템플릿 엔진과 타임리프 추가

# 다음 업데이트 (5.3 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 스프링 시큐리티 추가

# 마지막 완료 (5.4 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 게시판 애플리케이션 구현 완료
-->

## 📌 학습 목표
스프링 부트를 기반으로 한 웹 애플리케이션 개발 과정을 실전 프로젝트를 통해 익혀본다. 게시판 기능 구현을 통해 MVC 패턴, 타임리프 템플릿 엔진, 스프링 시큐리티, 데이터베이스 연동 등의 핵심 기술을 습득하고 실무에서 활용 가능한 웹 애플리케이션 설계 및 구현 능력을 체계적으로 학습한다.

---

## 목차

- [5.1 웹 애플리케이션과 MVC 모델](#51-웹-애플리케이션과-mvc-모델)
- [5.2 템플릿 엔진과 타임리프](#52-템플릿-엔진과-타임리프)
- [5.3 스프링 시큐리티](#53-스프링-시큐리티)
- [5.4 스프링 부트 게시판 애플리케이션 만들기](#54-스프링-부트-게시판-애플리케이션-만들기)

---

## 5.1 웹 애플리케이션과 MVC 모델

### 5.1.1 웹 애플리케이션 개발 방식의 이해

#### CSR vs SSR: 두 가지 웹 애플리케이션 개발 방식

현대 웹 애플리케이션 개발은 크게 두 가지 방식으로 나뉩니다.

| 구분 | RESTful API 서버 (CSR) | 웹 애플리케이션 서버 (SSR) |
|-----|----------------------|------------------------|
| **주요 역할** | 순수한 데이터(JSON, XML) 제공 | 완성된 View (HTML) 제공 |
| **렌더링 주체** | 클라이언트(브라우저) 측 렌더링 (CSR) | 서버 측 렌더링 (SSR) |
| **Spring 어노테이션** | `@RestController` 사용 | `@Controller` 사용 |
| **MVC View 역할** | 데이터를 담는 그릇 역할 (JSON/XML 데이터) | UI 화면을 구성하는 역할 (JSP, Thymeleaf 등 템플릿) |
| **협업 방식** | 프론트엔드/백엔드 역할 분리가 명확하여 협업 용이 | View 작업에서 백엔드 개발자와 디자이너의 협업 필요 |

---

#### CSR (Client-Side Rendering)

**정의**: 서버는 데이터만 제공하고, 클라이언트(브라우저)가 JavaScript를 사용하여 화면을 렌더링

**동작 흐름**:
```
1. 클라이언트 → 서버: HTTP 요청
2. 서버 → 클라이언트: JSON 데이터 응답
3. 클라이언트: JavaScript로 DOM 조작하여 화면 렌더링
```

**예시 (RESTful API)**:
```java
@RestController
@RequestMapping("/api/members")
public class MemberController {
    @GetMapping
    public List<MemberResponse> getMembers() {
        // JSON 데이터 반환
        return memberService.findAll();
    }
}
```

**장점**:
- ✅ 서버와 클라이언트의 역할이 명확히 분리
- ✅ 다양한 클라이언트 지원 가능 (웹, 모바일 앱, IoT)
- ✅ 초기 로딩 후 빠른 화면 전환

**단점**:
- ⚠️ 초기 로딩 속도가 느림 (JavaScript 다운로드 및 실행 필요)
- ⚠️ SEO(검색 엔진 최적화)에 불리

---

#### SSR (Server-Side Rendering)

**정의**: 서버가 완성된 HTML을 생성하여 클라이언트에게 전달

**동작 흐름**:
```
1. 클라이언트 → 서버: HTTP 요청
2. 서버: 템플릿 엔진으로 HTML 생성
3. 서버 → 클라이언트: 완성된 HTML 응답
4. 클라이언트: HTML을 바로 표시
```

**예시 (Spring MVC)**:
```java
@Controller
@RequestMapping("/members")
public class MemberController {
    @GetMapping("/list")
    public String getMembers(Model model) {
        // Model에 데이터 담기
        model.addAttribute("members", memberService.findAll());
        // View 이름 반환
        return "member-list";
    }
}
```

**장점**:
- ✅ 초기 로딩 속도가 빠름
- ✅ SEO(검색 엔진 최적화)에 유리
- ✅ JavaScript 없이도 동작 가능

**단점**:
- ⚠️ 서버 부하가 큼 (매번 HTML 생성)
- ⚠️ 화면 전환 시 전체 페이지 새로고침 필요

---

#### MVC 패턴은 CSR과 SSR 모두에서 사용

**중요한 개념**: RESTful API 서버(CSR)와 웹 애플리케이션 서버(SSR) 모두 MVC 패턴을 사용합니다!

**공통점**:
- Controller → Service → Repository 구조는 동일
- 비즈니스 로직과 데이터 처리 방식은 동일

**차이점**:
- **View의 역할**만 다름

| 구분 | RESTful API (@RestController) | 웹 애플리케이션 (@Controller) |
|-----|------------------------------|------------------------------|
| **Model** | DTO (Data Transfer Object) | DTO + Spring의 Model 객체 |
| **View** | JSON, XML (데이터 직렬화) | JSP, Thymeleaf (HTML 템플릿) |
| **Controller 반환** | DTO 객체 (자동으로 JSON 변환) | View 이름 (문자열) |

---

#### @RestController와 @Controller의 차이

**@RestController**:
```java
@RestController  // = @Controller + @ResponseBody
public class ApiController {
    @GetMapping("/api/members")
    public List<MemberResponse> getMembers() {
        return memberService.findAll();  // 자동으로 JSON 변환
    }
}
```

**작동 방식**:
1. 메서드 반환 값을 HTTP 응답 본문(Body)에 직접 쓰기
2. Jackson 라이브러리가 객체를 JSON으로 자동 변환
3. View Resolver를 거치지 않음

---

**@Controller**:
```java
@Controller
public class WebController {
    @GetMapping("/members/list")
    public String getMembers(Model model) {
        model.addAttribute("members", memberService.findAll());
        return "member-list";  // View 이름 반환
    }
}
```

**작동 방식**:
1. Model 객체에 데이터 저장
2. View 이름(문자열) 반환
3. View Resolver가 View를 찾아 렌더링
4. 완성된 HTML을 응답

---

#### 핵심 비교 표

| 항목 | @RestController (CSR) | @Controller (SSR) |
|-----|---------------------|------------------|
| **반환 값** | 데이터 객체 (DTO) | View 이름 (문자열) |
| **데이터 전달** | JSON으로 직렬화 | Model 객체에 담기 |
| **View 처리** | 없음 (JSON 응답) | View Resolver로 템플릿 찾기 |
| **최종 응답** | JSON 데이터 | 완성된 HTML |
| **클라이언트 역할** | JavaScript로 화면 렌더링 | HTML을 바로 표시 |

---

### 5.1.2 MVC 패턴의 이해

#### MVC 패턴이란?

**MVC (Model-View-Controller)**: 애플리케이션의 복잡성을 분리하고 관심사를 명확히 하기 위한 디자인 패턴

**핵심 목적**:
- 코드의 역할을 명확히 분리
- 유지보수성 향상
- 협업 효율성 증대

---

#### MVC의 세 가지 구성 요소

**1. Model (모델) - 데이터**

| 항목 | 설명 |
|-----|------|
| **역할** | 애플리케이션의 데이터와 비즈니스 로직 담당 |
| **책임** | - 데이터베이스에서 가져온 순수한 데이터<br>- View에 전달할 데이터를 담는 객체<br>- 비즈니스 규칙 처리 |
| **예시** | Entity, DTO, Service 계층 |
| **Spring 구현** | `Model` 인터페이스로 View에 데이터 전달 |

---

**2. View (뷰) - 화면**

| 항목 | 설명 |
|-----|------|
| **역할** | 사용자에게 보여줄 UI 화면 담당 |
| **책임** | - Model이 제공하는 데이터를 이용해 동적으로 HTML 생성<br>- 사용자 인터페이스 표현 |
| **예시** | JSP, Thymeleaf, HTML 템플릿 |
| **핵심 원칙** | 비즈니스 로직을 포함하지 않고 표현만 담당 |

---

**3. Controller (컨트롤러) - 로직**

| 항목 | 설명 |
|-----|------|
| **역할** | 클라이언트의 요청을 받아 처리하고 결과를 Model과 View에 전달하는 중개자 |
| **책임** | - HTTP 요청 수신<br>- Service 계층과 연동하여 비즈니스 로직 호출<br>- 처리 결과를 Model에 담아 View에 전달 |
| **예시** | `@Controller`, `@RestController` |
| **핵심 원칙** | 얇은 계층 유지 (비즈니스 로직은 Service에 위임) |

---

#### MVC 패턴의 데이터 흐름

```
클라이언트 (HTTP 요청)
    ↓
Controller (요청 수신, 흐름 제어)
    ↓
Service (비즈니스 로직 처리)
    ↓
Repository (데이터베이스 접근)
    ↓
Service (데이터 가공)
    ↓
Controller (Model에 데이터 담기)
    ↓
View (Model 데이터로 HTML 생성)
    ↓
클라이언트 (HTML 응답)
```

---

#### MVC 패턴의 장점

| 장점 | 설명 |
|-----|------|
| **관심사 분리** | 각 계층이 자신의 역할만 담당하여 코드가 명확 |
| **재사용성** | Model과 Controller는 여러 View에서 재사용 가능 |
| **유지보수성** | 한 계층의 변경이 다른 계층에 영향을 주지 않음 |
| **협업 효율** | 백엔드 개발자는 Controller와 Model, 프론트엔드 개발자는 View 담당 |
| **테스트 용이** | 각 계층을 독립적으로 테스트 가능 |

---

### 5.1.3 Model 1 vs Model 2 아키텍처

#### Model 1 아키텍처 (Java-in-HTML)

**특징**: HTML 코드 내에 Java 코드를 직접 삽입하여 데이터 처리와 화면 생성을 동시에 처리

**구조**:
```
클라이언트 → JSP (Java 코드 + HTML) → 데이터베이스
```

**예시 (fortune.jsp)**:

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>오늘의 운세</title>
</head>
<body>
<%
    // ⚠️ 비즈니스 로직이 HTML과 혼재
    String[] fortunes = {
        "오늘은 운이 아주 좋습니다",
        "무난한 하루!",
        "밤길을.. 조심하세요.",
        "컨디션 최고!"
    };
    int randomIndex = (int)(Math.random() * fortunes.length);
    String f = fortunes[randomIndex];
%>

<h2>오늘의 운세</h2>
<p><%= f %></p>
</body>
</html>
```

---

#### JSP 기본 문법

**1. 스크립틀릿 (Scriptlet): `<% Java 코드 %>`**

| 항목 | 설명 |
|-----|------|
| **형태** | `<% Java 코드 %>` |
| **역할** | 서버에서 실행할 순수한 Java 코드 블록 |
| **용도** | 변수 선언, 제어문(if, for), 객체 생성 등 |
| **출력** | 화면에 직접 출력하지 않음 |

**예시**:
```jsp
<%
    String name = "홍길동";
    int age = 30;
    
    if (age >= 20) {
        out.println("성인입니다.");
    }
%>
```

---

**2. 표현식 (Expression): `<%= 표현식 %>`**

| 항목 | 설명 |
|-----|------|
| **형태** | `<%= 표현식 %>` |
| **역할** | 결과를 웹 페이지에 출력할 Java 표현식 |
| **용도** | 변수 값, 메서드 호출 결과 출력 |
| **주의** | 세미콜론(`;`)을 붙이지 않음 |

**예시**:
```jsp
<p>이름: <%= name %></p>
<p>나이: <%= age %></p>
<p>현재 시간: <%= new java.util.Date() %></p>
```

---

#### Model 1 아키텍처의 문제점

| 문제점 | 설명 |
|-------|------|
| **관심사 혼재** | 웹 디자이너의 관심사(HTML)와 백엔드 개발자의 관심사(Java 로직)가 하나의 파일에 혼재 |
| **복잡도 증가** | Java 코드와 HTML이 뒤섞여 코드 가독성 저하 |
| **협업 어려움** | 디자이너가 Java 코드를 이해해야 하고, 개발자가 HTML 구조를 파악해야 함 |
| **유지보수 어려움** | 로직 변경 시 HTML 구조에 영향을 줄 수 있음 |
| **재사용성 낮음** | 비즈니스 로직이 JSP에 종속되어 다른 곳에서 재사용 불가 |

---

#### Model 2 아키텍처 (MVC 패턴)

**특징**: Controller와 View의 역할을 명확하게 분리하여 Model 1의 문제점 해결

**구조**:
```
클라이언트
    ↓
Controller (Java 클래스) - 로직 처리
    ↓
Model (데이터)
    ↓
View (JSP/Thymeleaf) - 화면 표현만 담당
```

---

#### Model 2 아키텍처의 장점

| 장점 | 설명 |
|-----|------|
| **역할 분리** | Controller는 데이터 처리 로직만, View는 화면 생성만 담당 |
| **협업 용이** | 백엔드 개발자는 Controller와 Model, 웹 디자이너는 View 전담 |
| **유지보수성** | 로직 변경 시 View에 영향 없음 |
| **재사용성** | 비즈니스 로직을 여러 View에서 공유 가능 |
| **테스트 편의** | Controller를 독립적으로 테스트 가능 |

---

#### Model 1 vs Model 2 비교

| 구분 | Model 1 | Model 2 (MVC) |
|-----|---------|--------------|
| **구조** | JSP (Java + HTML) | Controller (Java) + View (HTML) |
| **로직 위치** | JSP 내부 | Controller와 Service 계층 |
| **View 역할** | 로직 + 화면 | 화면 표현만 |
| **복잡도** | 높음 (혼재) | 낮음 (분리) |
| **협업** | 어려움 | 용이함 |
| **권장 여부** | ❌ 비권장 | ✅ 권장 |

---

### 5.1.4 Spring MVC의 동작 원리

#### Spring MVC 요청 처리 흐름 (7단계)

```
1. HTTP 요청
   ↓
2. DispatcherServlet (Front Controller)
   ↓
3. Controller 매핑
   ↓
4. Controller 실행 (로직 처리 + Model 준비)
   ↓
5. View Resolver (View 탐색)
   ↓
6. View 렌더링 (HTML 생성)
   ↓
7. HTTP 응답 (완성된 HTML)
```

---

#### 각 단계 상세 설명

**1단계: HTTP 요청**

```
클라이언트 (브라우저)
    ↓
GET /members/list HTTP/1.1
Host: localhost:8080
```

**설명**:
- 사용자가 브라우저에서 URL 입력 또는 링크 클릭
- HTTP 요청이 서버로 전송

---

**2단계: DispatcherServlet 처리**

```
톰캣 (서블릿 컨테이너)
    ↓
DispatcherServlet (Front Controller)
```

**DispatcherServlet의 역할**:

| 역할 | 설명 |
|-----|------|
| **Front Controller** | 모든 HTTP 요청을 가장 먼저 받는 단일 진입점 |
| **요청 분석** | URL, HTTP 메서드, 파라미터 분석 |
| **Controller 탐색** | 요청을 처리할 적절한 Controller 메서드 찾기 |
| **응답 관리** | 최종 응답을 클라이언트에게 전달 |

**핵심**: 개발자는 DispatcherServlet을 직접 다루지 않음. Spring Boot가 자동으로 설정!

---

**3단계: Controller 매핑**

```
DispatcherServlet
    ↓
HandlerMapping (요청 URL과 Controller 매핑)
    ↓
적절한 Controller 메서드 찾기
```

**동작 방식**:

| 요청 URL | HTTP 메서드 | 매핑되는 Controller 메서드 |
|---------|-----------|-------------------------|
| `/members/list` | GET | `@GetMapping("/members/list")` |
| `/members/create` | POST | `@PostMapping("/members/create")` |

---

**4단계: 로직 처리 및 Model 준비**

```java
@Controller
public class MemberController {
    @GetMapping("/members/list")
    public String memberList(Model model) {
        // 1. Service 호출
        List<Member> members = memberService.findAll();
        
        // 2. Model에 데이터 담기
        model.addAttribute("members", members);
        
        // 3. View 이름 반환
        return "member-list";
    }
}
```

**동작 순서**:

| 순서 | 동작 | 설명 |
|-----|------|------|
| 1 | Service/Repository 호출 | 비즈니스 로직 실행, 데이터베이스 조회 |
| 2 | Model에 데이터 저장 | `model.addAttribute("key", value)` |
| 3 | View 이름 반환 | 문자열로 View 이름 반환 (예: "member-list") |

---

#### Model 객체의 작동 원리

**Model 객체**: Spring이 제공하는 데이터 전달 객체

**생명주기**:

```
HTTP 요청 수신
    ↓
Spring이 새로운 Model 객체 생성
    ↓
Controller 메서드에 주입 (매개변수)
    ↓
개발자가 Model에 데이터 저장
    ↓
View로 Model 전달
    ↓
View가 Model에서 데이터 추출
    ↓
요청 종료 후 Model 객체 소멸
```

**핵심**: Model은 요청당 1개씩 생성되며, View에 데이터를 전달하는 임시 저장소 역할!

---

**Model 사용 예시**:

```java
// Controller
@GetMapping("/members/list")
public String memberList(Model model) {
    List<Member> members = memberService.findAll();
    
    // Model에 데이터 저장
    model.addAttribute("members", members);
    model.addAttribute("title", "회원 목록");
    
    return "member-list";
}
```

```jsp
<!-- View (JSP) -->
<h1>${title}</h1>  <!-- "회원 목록" 출력 -->

<table>
    <c:forEach items="${members}" var="member">
        <tr>
            <td>${member.name}</td>
        </tr>
    </c:forEach>
</table>
```

---

**5단계: View 탐색 및 Model 전달**

```
DispatcherServlet
    ↓
ViewResolver (View 이름으로 실제 파일 찾기)
    ↓
View 파일 로딩 (JSP, Thymeleaf 등)
    ↓
Model 데이터를 View에 전달
```

**ViewResolver 설정 (application.properties)**:

```properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

**동작 예시**:

| Controller 반환 값 | 설정 | 최종 View 경로 |
|------------------|------|--------------|
| `"member-list"` | prefix + suffix | `/WEB-INF/views/member-list.jsp` |
| `"members/detail"` | prefix + suffix | `/WEB-INF/views/members/detail.jsp` |

**핵심**: 개발자는 View 이름만 반환하면, ViewResolver가 실제 파일을 찾아줌!

---

**6단계: View 렌더링**

```
View (JSP/Thymeleaf)
    ↓
Model 데이터 추출
    ↓
동적 코드를 데이터로 치환
    ↓
최종 HTML 생성
```

**렌더링 과정 예시**:

```jsp
<!-- 렌더링 전 (JSP 템플릿) -->
<h1>${title}</h1>
<p>회원 수: ${members.size()}</p>

<!-- 렌더링 후 (순수 HTML) -->
<h1>회원 목록</h1>
<p>회원 수: 4</p>
```

**핵심**: 
- `${}` 같은 동적 코드는 서버에서 실제 데이터로 치환
- 클라이언트는 순수한 HTML만 받음

---

**7단계: 클라이언트 전달**

```
View 렌더링 완료
    ↓
DispatcherServlet이 최종 HTML 수신
    ↓
HTTP 응답으로 클라이언트에 전송
    ↓
브라우저가 HTML 표시
```

**HTTP 응답 예시**:

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8

<!DOCTYPE html>
<html>
<head><title>회원 목록</title></head>
<body>
    <h1>회원 목록</h1>
    <table>
        <tr><td>홍길동</td></tr>
        <tr><td>김철수</td></tr>
    </table>
</body>
</html>
```

---

#### Spring MVC 전체 흐름 다이어그램

```
┌─────────────┐
│ 클라이언트    │
│ (브라우저)    │
└──────┬──────┘
       │ HTTP GET /members/list
       ↓
┌─────────────────────────────────┐
│ 톰캣 (서블릿 컨테이너)             │
│  ┌───────────────────────────┐  │
│  │ DispatcherServlet         │  │
│  │ (Front Controller)        │  │
│  └───────────┬───────────────┘  │
└──────────────┼──────────────────┘
               │
               ↓
       ┌───────────────┐
       │ HandlerMapping │
       │ (Controller 찾기) │
       └───────┬───────┘
               ↓
       ┌───────────────────┐
       │ MemberController  │
       │ (로직 처리)         │
       └───────┬───────────┘
               │
               ↓
       ┌───────────────┐
       │ Service 계층   │
       └───────┬───────┘
               │
               ↓
       ┌───────────────┐
       │ Repository     │
       │ (DB 조회)      │
       └───────┬───────┘
               │
               ↓ (데이터 반환)
       ┌───────────────────┐
       │ Controller        │
       │ Model에 데이터 담기 │
       │ "member-list" 반환 │
       └───────┬───────────┘
               │
               ↓
       ┌───────────────┐
       │ ViewResolver  │
       │ (View 찾기)    │
       └───────┬───────┘
               │
               ↓
       ┌──────────────────────┐
       │ member-list.jsp      │
       │ (HTML 생성)          │
       └──────────┬───────────┘
                  │
                  ↓
┌─────────────────────────────────┐
│ DispatcherServlet               │
│ (최종 HTML 수신)                 │
└─────────────┬───────────────────┘
              │ HTML 응답
              ↓
       ┌─────────────┐
       │ 클라이언트    │
       │```
       │ (HTML 표시)  │
       └─────────────┘
```

---

### 5.1.5 JSP로 MVC 프로젝트 만들기

#### 프로젝트 생성 및 환경 설정

**1단계: Spring Initializr로 프로젝트 생성**

**중요한 설정**:

| 항목 | 설정 값 | 이유 |
|-----|---------|------|
| **Packaging** | **WAR** | JSP 사용을 위해 필수 (JAR로는 JSP 불가) |
| **Dependencies** | Spring Web, Lombok | 웹 애플리케이션 개발을 위한 최소 의존성 |

**주의**: Spring Boot 애플리케이션에서 JSP를 사용하려면 반드시 **WAR 파일**로 패키징해야 합니다!

---

#### WAR vs JAR: 패키징 방식의 이해

**JAR (Java Archive)**:

| 항목 | 설명 |
|-----|------|
| **정의** | Java 클래스, 리소스를 압축한 파일 |
| **용도** | 독립 실행형 애플리케이션 (내장 WAS 포함) |
| **실행 방식** | `java -jar app.jar` |
| **JSP 지원** | ❌ 불가능 (기술적 제약) |
| **권장 사용** | RESTful API 서버, Spring Boot 기본 |

---

**WAR (Web Application Archive)**:

| 항목 | 설명 |
|-----|------|
| **정의** | 웹 애플리케이션을 압축한 파일 |
| **용도** | 외부 WAS(Tomcat 등)에 배포 |
| **실행 방식** | 외부 Tomcat에 배포 후 실행 |
| **JSP 지원** | ✅ 가능 |
| **권장 사용** | JSP, 전통적인 MVC 웹 애플리케이션 |

---

#### 개발 환경과 배포 환경 분리

**현재 설정의 의미**:

```gradle
plugins {
    id 'java'
    id 'war'  // ← WAR 플러그인 사용
    id 'org.springframework.boot' version '3.5.7'
    id 'io.spring.dependency-management' version '1.1.7'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'  // ← 핵심!
    // ...
}
```

---

**개발/테스트 단계 (내장 Tomcat 사용)**:

| 항목 | 상태 | 설명 |
|-----|------|------|
| **실행 방식** | 내장 Tomcat 사용 | IntelliJ에서 실행하거나 테스트 시, Spring Boot가 제공하는 내장 Tomcat을 구동 |
| **Tomcat WAS** | 포함됨 (일시적) | `spring-boot-starter-web`에 의해 내장 Tomcat이 로드됨 |
| **동작 방식** | JAR처럼 실행 | `bootRun` 또는 IDE 실행 버튼으로 즉시 실행 가능 |
| **JSP 지원** | implementation으로 추가 필요 | 내장 Tomcat에는 JSP 컴파일러가 없으므로 별도 추가 |

**핵심**: 개발 단계에서는 외부 Tomcat 설치 없이 내장 Tomcat으로 빠르게 개발/테스트 가능!

---

**최종 배포 단계 (외부 Tomcat 사용)**:

| 항목 | 상태 | 설명 |
|-----|------|------|
| **패키징** | WAR 파일 | `providedRuntime` 설정과 WAR 플러그인 사용으로 최종 아티팩트는 WAR 파일 |
| **Tomcat WAS** | 미포함 | `providedRuntime 'spring-boot-starter-tomcat'` 덕분에 내장 Tomcat은 WAR 파일에서 제외됨 |
| **JSP 지원** | 외부 Tomcat에 의존 | 외부 Tomcat은 이미 자체 JSP 엔진(Jasper)을 가지고 있음 |
| **배포 방식** | WAR 파일을 외부 Tomcat에 배포 | 서버 리소스를 효율적으로 사용 가능 |

**핵심**: 배포 시에는 서버의 Tomcat을 사용하므로 애플리케이션에 Tomcat을 포함하지 않음!

---

#### 정리: JAR vs WAR 개발 방식

```
┌─────────────────────────────────────────┐
│ 개발/테스트 단계                          │
├─────────────────────────────────────────┤
│ - 내장 Tomcat 사용 (JAR처럼 동작)         │
│ - IDE에서 즉시 실행 가능                  │
│ - JSP 기능을 위해 Jasper 의존성 추가      │
│ - 빠른 개발과 테스트                      │
└─────────────────────────────────────────┘
                   ↓
                 빌드
                   ↓
┌─────────────────────────────────────────┐
│ 배포 단계                                 │
├─────────────────────────────────────────┤
│ - WAR 파일 생성                           │
│ - 내장 Tomcat 제외 (providedRuntime)     │
│ - 외부 Tomcat에 배포                      │
│ - 서버 자원 효율적 사용                    │
└─────────────────────────────────────────┘
```

**핵심 이해**:
- "개발 단계에서는 내장 Tomcat을 사용하는 JAR 상태이고"
- "배포 시에는 외부 Tomcat을 사용하는 WAR 파일로 배포된다!"

---

#### 2단계: 필수 의존성 추가

**build.gradle에 추가할 의존성**:

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
    
    // ✅ JSP 사용을 위한 필수 의존성 3가지
    implementation 'org.apache.tomcat.embed:tomcat-embed-jasper:10.1.40'
    implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:3.0.1'
    implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl:3.0.1'
}
```

---

#### JSP 관련 의존성 상세 설명

**1. tomcat-embed-jasper (JSP 엔진)**

```gradle
implementation 'org.apache.tomcat.embed:tomcat-embed-jasper:10.1.40'
```

**역할**: JSP 파일을 HTML로 변환하는 컴파일러

**필요한 이유**:

| 항목 | 설명 |
|-----|------|
| **Jasper란?** | JSP 파일을 서블릿(Java 클래스)으로 변환한 후 실행하여 HTML을 생성하는 Tomcat의 핵심 모듈 |
| **내장 Tomcat의 문제** | Spring Boot의 내장 Tomcat에는 Jasper 기능이 **기본적으로 빠져있음** |
| **해결 방법** | 수동으로 Jasper 의존성을 추가하여 내장 Tomcat에 JSP 처리 능력 부여 |
| **배포 시** | 외부 Tomcat에는 이미 Jasper가 있으므로 이 의존성은 무의미 (providedRuntime으로 변경 가능) |

**핵심**: "개발 단계에서 내장 Tomcat이 JSP를 실행할 수 있도록 JSP 엔진을 수동으로 주입하는 것!"

---

**2. JSTL API (표준 규격)**

```gradle
implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:3.0.1'
```

**역할**: JSTL 태그의 표준 규격(API) 정의

**내용**:
- JSTL 태그가 무엇인지 정의
- 어떤 메서드를 호출해야 하는지 규격 제시
- **이것만으로는 실행되지 않음** (인터페이스와 유사)

---

**3. JSTL 구현체**

```gradle
implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl:3.0.1'
```

**역할**: JSTL API의 실제 구현체

**내용**:
- `<c:forEach>`, `<c:if>` 같은 태그를 실제로 Java 로직으로 변환하여 실행
- API 규격을 받아서 실제 기능을 수행하는 구현 코드

**핵심**: API(규격) + 구현체(실제 코드) 두 가지를 모두 추가해야 JSTL 사용 가능!

---

#### JSTL을 사용하는 이유

**JSTL (JSP Standard Tag Library)**: JSP에서 자바 코드 사용을 최소화하고, HTML과 유사한 태그로 로직을 표현하는 라이브러리

**목적**: Model 2 아키텍처(MVC 패턴)의 View 역할에 충실하기 위함

---

**JSP 스크립틀릿 vs JSTL 비교**:

| 구분 | JSP 스크립틀릿 (`<% %>`) | JSTL 태그 (`<c:태그>`) |
|-----|------------------------|----------------------|
| **코드 분리** | HTML과 Java 로직이 혼재되어 복잡함 | 로직을 태그 형태로 캡슐화하여 표현과 로직 분리 |
| **가독성** | Java 문법이 섞여 있어 디자인 작업이 어려움 | HTML과 유사한 형태로 가독성이 높아짐 |
| **유지보수** | 로직 수정 시 HTML 구조에 영향을 줄 수 있음 | View는 데이터만 전달받아 표현만 담당하므로 유지보수 용이 |
| **협업** | 웹 디자이너가 Java 코드를 이해해야 함 | 태그 형태로 디자이너도 쉽게 이해 가능 |

---

**예시 비교**:

**스크립틀릿 사용 (Model 1 방식)**:
```jsp
<%
    List<Member> members = (List<Member>) request.getAttribute("members");
    for (Member member : members) {
%>
    <tr>
        <td><%= member.getId() %></td>
        <td><%= member.getName() %></td>
    </tr>
<%
    }
%>
```

**JSTL 사용 (Model 2 방식)**:
```jsp
<c:forEach items="${members}" var="member">
    <tr>
        <td>${member.id}</td>
        <td>${member.name}</td>
    </tr>
</c:forEach>
```

**핵심**: JSTL을 사용하면 JSP 파일의 가독성이 높아지고, View는 순수하게 표현 역할만 담당!

---

#### 3단계: application.properties 설정

**프로젝트 루트 경로 설정**:

```properties
spring.application.name=jspSample

# ViewResolver 설정
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

---

**설정 의미**:

| 설정 | 값 | 의미 |
|-----|-----|------|
| **prefix** | `/WEB-INF/views/` | JSP 파일이 위치한 디렉토리의 기본 경로 |
| **suffix** | `.jsp` | View 파일의 확장자 |

**작동 방식**:

```java
// Controller
return "member-list";

// ViewResolver가 자동 변환
// "/WEB-INF/views/" + "member-list" + ".jsp"
// = /WEB-INF/views/member-list.jsp
```

---

#### webapp 폴더 생성 이유

**중요**: Spring Boot 프로젝트 생성 시 `src/main/webapp` 폴더는 **자동으로 생성되지 않습니다**!

**이유**:

| 항목 | 설명 |
|-----|------|
| **Spring Boot 기본 방향** | JSP 대신 Thymeleaf 같은 템플릿 엔진 권장 |
| **WAR 파일 구조** | 웹 애플리케이션의 루트 디렉토리(`/`)는 관행적으로 `src/main/webapp`으로 지정됨 |
| **수동 생성 필요** | JSP를 사용하려면 개발자가 직접 폴더 구조를 만들어야 함 |

---

**필요한 폴더 구조**:

```
src/
└── main/
    ├── java/
    ├── resources/
    │   └── application.properties
    └── webapp/  ← 수동으로 생성!
        └── WEB-INF/  ← 수동으로 생성!
            └── views/  ← 수동으로 생성!
                └── member-list.jsp  ← JSP 파일 위치
```

**핵심**: JSP 파일은 반드시 `src/main/webapp/WEB-INF/views/` 경로에 위치해야 함!

---

#### WEB-INF 디렉토리의 특별한 의미

**WEB-INF**: 웹 애플리케이션의 보호된 영역

**특징**:

| 항목 | 설명 |
|-----|------|
| **직접 접근 불가** | 클라이언트가 브라우저에서 직접 접근할 수 없음 |
| **보안** | JSP 파일을 외부에 노출하지 않고 Controller를 통해서만 접근 가능 |
| **WAR 표준** | Java EE 웹 애플리케이션의 표준 디렉토리 구조 |

**예시**:

```
❌ 직접 접근 불가:
http://localhost:8080/WEB-INF/views/member-list.jsp
→ 404 Not Found

✅ Controller를 통한 접근만 가능:
http://localhost:8080/members/list
→ Controller가 member-list.jsp를 렌더링하여 응답
```

**핵심**: View 파일을 WEB-INF 안에 두면 보안성이 높아짐!

---

### 5.1.6 JSP와 JSTL을 사용한 View 작성

#### member-list.jsp 파일 작성

**파일 위치**: `src/main/webapp/WEB-INF/views/member-list.jsp`

```jsp
<%@ taglib prefix="c" uri="jakarta.tags.core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>회원 목록</title>
</head>
<body>
    <h1>회원 목록</h1>
    
    <table border="1">
        <thead>
            <tr>
                <th>ID</th>
                <th>이름</th>
                <th>이메일</th>
                <th>나이</th>
            </tr>
        </thead>
        <tbody>
            <c:forEach items="${members}" var="member">
                <tr>
                    <td>${member.id}</td>
                    <td>${member.name}</td>
                    <td>${member.email}</td>
                    <td>${member.age}</td>
                </tr>
            </c:forEach>
        </tbody>
    </table>
</body>
</html>
```

---

#### JSP 지시자 (Directive) 설명

**1. taglib 지시자**

```jsp
<%@ taglib prefix="c" uri="jakarta.tags.core" %>
```

**역할**: JSTL 라이브러리를 JSP 페이지에서 사용하겠다고 선언

| 속성 | 값 | 의미 |
|-----|-----|------|
| **prefix** | `"c"` | 이 라이브러리의 태그들을 `<c:태그이름>` 형태로 사용 |
| **uri** | `"jakarta.tags.core"` | 사용할 라이브러리의 종류 (Core 라이브러리) |

**핵심**: 이 선언 없이는 `<c:forEach>` 같은 JSTL 태그를 사용할 수 없음!

---

**2. page 지시자**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

**역할**: JSP 페이지의 설정 정보 지정

| 속성 | 값 | 의미 |
|-----|-----|------|
| **contentType** | `text/html;charset=UTF-8` | 응답의 콘텐츠 타입과 인코딩 지정 |
| **language** | `java` | JSP 페이지에서 사용할 스크립팅 언어 |

---

#### JSTL Core 태그 사용법

**<c:forEach> 태그**

```jsp
<c:forEach items="${members}" var="member">
    <!-- 반복할 내용 -->
</c:forEach>
```

**속성 설명**:

| 속성 | 설명 | 예시 |
|-----|------|------|
| **items** | 반복할 컬렉션 (Model에서 가져옴) | `${members}` |
| **var** | 현재 반복 요소를 담을 변수 이름 | `member` |

**동작 방식**:

```
1. Model에서 "members" 키로 저장된 List<Member> 가져오기
2. 리스트의 첫 번째 요소를 member 변수에 담기
3. <c:forEach> 블록 내부 실행
4. 다음 요소로 이동하여 2-3 반복
5. 모든 요소 처리 완료 시 종료
```

---

#### EL (Expression Language) 사용법

**${}의 역할**: Model이나 스코프에서 데이터를 읽어오는 표현식

**사용 시점**:

| 사용 목적 | 설명 | 예시 |
|---------|------|------|
| **Model 접근** | Controller가 Model에 담아준 데이터에 접근 | `${members}` |
| **속성 접근** | Java 객체의 속성(Property)에 접근 | `${member.id}` |

---

**1. Model에서 데이터 읽기**

```jsp
<c:forEach items="${members}" var="member">
```

**동작 과정**:

```
1. EL이 현재 JSP의 스코프를 탐색 (Page → Request → Session → Application)
2. "members"라는 이름의 객체를 찾음
3. 찾은 객체(List<Member>)를 items 속성에 할당
```

**핵심**: Controller가 `model.addAttribute("members", list)`로 저장한 데이터를 `${members}`로 읽어옴!

---

**2. 객체 속성 접근**

```jsp
${member.id}
${member.name}
```

**동작 원리**:

```
${member.id} 실행 시:
1. EL이 member 객체 찾기
2. .id를 만나면 자동으로 getId() 메서드 호출
3. 반환 값을 출력
```

**JavaBean 규약**:

| EL 표현식 | 실제 호출되는 메서드 | 필요한 어노테이션 |
|---------|------------------|----------------|
| `${member.id}` | `member.getId()` | `@Getter` (Lombok) |
| `${member.name}` | `member.getName()` | `@Getter` (Lombok) |
| `${member.email}` | `member.getEmail()` | `@Getter` (Lombok) |

**핵심**: 
- EL은 private 필드에 직접 접근하지 않음
- 반드시 Getter 메서드가 있어야 함
- Lombok의 `@Getter` 또는 `@Data`가 필요!

---

#### JSP 구문 요약

| 구문 | 형태 | 역할 | 예시 |
|-----|------|------|------|
| **지시자** | `<%@ ... %>` | JSP 페이지 설정 및 라이브러리 선언 | `<%@ taglib ... %>` |
| **JSTL 태그** | `<c:태그>` | 제어 구조, 반복문 등 로직 처리 | `<c:forEach ...>` |
| **EL** | `${}` | Model 데이터 또는 객체 속성 접근하여 값 출력 | `${member.name}` |

---

### 5.1.7 Model 객체 (DTO) 작성

#### Member.java 작성

**파일 위치**: `src/main/java/com/example/jspSample/model/Member.java`

```java
package com.example.jspSample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

---

#### Lombok 어노테이션 설명

**@Data**:

| 자동 생성 메서드 | 설명 |
|---------------|------|
| **Getter** | 모든 필드에 대한 getter 메서드 생성 |
| **Setter** | 모든 필드에 대한 setter 메서드 생성 |
| **toString()** | 객체의 문자열 표현 생성 |
| **equals()** | 객체 비교 메서드 |
| **hashCode()** | 해시코드 생성 |

**@AllArgsConstructor**: 모든 필드를 매개변수로 받는 생성자 자동 생성

```java
// 자동 생성되는 생성자
public Member(Long id, String name, String email, Integer age) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.age = age;
}
```

---

#### DTO와 Entity의 관계 (중요!)

**질문**: "이 Member 객체는 DTO인가요, Entity인가요?"

**답변**: 현재는 **DTO (Data Transfer Object)** 역할을 하고 있습니다.

---

**DTO vs Entity 비교**:

| 구분 | Entity (`@Entity`) | DTO (Data Transfer Object) |
|-----|-------------------|---------------------------|
| **역할** | 데이터베이스 테이블 매핑 | 계층 간 데이터 전송 |
| **사용 계층** | Repository, Service 내부 | Controller, View |
| **의존성** | JPA에 의존 (`@Entity`, `@Id` 등) | 순수 Java 객체 (POJO) |
| **목적** | 영속성 관리 (Persistence) | 데이터 전달 |
| **민감 정보** | 포함 가능 (password, 내부 필드 등) | 필요한 정보만 선택적으로 포함 |

---

**왜 Entity를 View에 직접 사용하지 않는가?**

이전 Chapter 4에서 배운 내용과 동일합니다!

| 이유 | 설명 |
|-----|------|
| **관심사 분리** | Entity는 DB 구조와 1:1 매핑. View가 Entity를 직접 알면 DB 변경 시 View도 수정해야 하는 강한 결합 발생 |
| **보안** | Entity에는 password, 내부 감사 필드 등 View에 불필요하거나 민감한 정보가 포함될 수 있음 |
| **유연성** | View는 표시에 필요한 필드만 포함한 DTO를 사용하여 독립적으로 변경 가능 |

---

**실무 사용 방식**:

```
┌────────────────────┐
│ Controller (표현)   │ ← DTO 사용
├────────────────────┤
│ Service (비즈니스)  │ ← Entity ↔ DTO 변환
├────────────────────┤
│ Repository (영속성) │ ← Entity 사용
└────────────────────┘
         ↕
    Database
```

**핵심**: 
- RESTful API든 SSR MVC든, DTO 패턴 사용은 동일!
- 차이점은 DTO를 **JSON으로 반환**하느냐, **Model에 담아 View로 전달**하느냐!

---

### 5.1.8 Controller 작성

#### MemberController.java 작성

**파일 위치**: `src/main/java/com/example/jspSample/controller/MemberController.java`

```java
package com.example.jspSample.controller;

import com.example.jspSample.model.Member;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

import java.util.List;

@Controller
public class MemberController {
    
    // 테스트용 더미 데이터
    List<Member> members = List.of(
            new Member(1L, "홍혜창", "hyechang@spring.ac.kr", 10),
            new Member(2L, "김우현", "kim@spring.ac.kr", 20),
            new Member(3L, "김구라", "gugu@spring.ac.kr", 15),
            new Member(4L, "홍길동", "hong@spring.ac.kr", 30)
    );

    @GetMapping("/members/list")
    public String memberList(Model model) {
        // Model에 데이터 담기
        model.addAttribute("members", members);
        
        // View 이름 반환
        return "member-list";
    }
}
```

---

#### @Controller와 Model 객체

**@Controller의 역할**:

| 역할 | 설명 |
|-----|------|
| **요청 매핑** | HTTP 요청 URL을 메서드와 연결 |
| **Service 호출** | 비즈니스 로직 처리를 Service에 위임 |
| **Model 준비** | View에 전달할 데이터를 Model에 담기 |
| **View 선택** | 렌더링할 View 이름 반환 |

**핵심**: Controller는 **얇은 계층(Thin Layer)**이어야 함. 비즈니스 로직은 Service에 위임!

---

#### Model 객체의 생명주기

**Model 객체**: Spring이 제공하는 데이터 컨테이너

**생명주기**:

```
HTTP 요청 수신
    ↓
Spring이 Model 객체 자동 생성
    ↓
Controller 메서드에 주입 (매개변수)
    ↓
개발자가 Model에 데이터 저장
    model.addAttribute("key", value);
    ↓
View에 Model 전달
    ↓
View가 Model에서 데이터 추출
    ${key}↓
요청 처리 완료 후 Model 객체 소멸
```

**핵심**: 
- Model은 요청당 1개씩 생성
- View에 데이터를 전달하는 임시 저장소
- 개발자는 생성/소멸을 신경 쓸 필요 없음

---

#### model.addAttribute() 메서드

```java
model.addAttribute("members", members);
```

**메서드 시그니처**:
```java
Model addAttribute(String name, Object value)
```

| 매개변수 | 타입 | 설명 | 예시 |
|---------|------|------|------|
| **name** | String | View에서 접근할 키 이름 | "members" |
| **value** | Object | 전달할 데이터 (모든 타입 가능) | List<Member> 객체 |

**사용 예시**:

```java
// 리스트 저장
model.addAttribute("members", memberList);

// 단일 객체 저장
model.addAttribute("member", member);

// 문자열 저장
model.addAttribute("title", "회원 목록");

// 숫자 저장
model.addAttribute("count", 100);
```

---

#### Controller 메서드 반환 값

**View 이름 반환**:

```java
return "member-list";
```

**처리 과정**:

```
1. Controller가 "member-list" 문자열 반환
    ↓
2. ViewResolver가 설정 확인
    prefix: /WEB-INF/views/
    suffix: .jsp
    ↓
3. 최종 경로 생성
    /WEB-INF/views/member-list.jsp
    ↓
4. 해당 JSP 파일 로딩 및 렌더링
```

**핵심**: 개발자는 View 이름만 반환하면, ViewResolver가 실제 파일을 찾아줌!

---

### 5.1.9 애플리케이션 실행 및 테스트

#### 메인 클래스 실행

**파일 위치**: `src/main/java/com/example/jspSample/JspSampleApplication.java`

```java
package com.example.jspSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JspSampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(JspSampleApplication.class, args);
    }
}
```

**실행 방법**:

| 방법 | 실행 방식 |
|-----|---------|
| **IDE** | IntelliJ의 Run 버튼 클릭 또는 `Shift + F10` |
| **Gradle** | Gradle 탭 → Tasks → application → bootRun 더블클릭 |
| **터미널** | `./gradlew bootRun` |

---

#### 브라우저에서 테스트

**접속 URL**:
```
http://localhost:8080/members/list
```

**브라우저의 동작**:
- 브라우저는 기본적으로 **GET 메서드**를 사용
- 주소창에 URL을 입력하면 자동으로 GET 요청 전송

---

**예상 결과**:

```
회원 목록

ID    이름      이메일                    나이
1     홍혜창    hyechang@spring.ac.kr    10
2     김우현    kim@spring.ac.kr         20
3     김구라    gugu@spring.ac.kr        15
4     홍길동    hong@spring.ac.kr        30
```

---

#### 전체 동작 흐름 확인

**요청부터 응답까지의 전체 과정**:

```
1. 브라우저
   GET http://localhost:8080/members/list
       ↓
2. 톰캣 (서블릿 컨테이너)
       ↓
3. DispatcherServlet (Front Controller)
       ↓
4. HandlerMapping
   "/members/list" → MemberController.memberList() 찾기
       ↓
5. MemberController.memberList(Model model) 실행
   - members 리스트 생성
   - model.addAttribute("members", members)
   - return "member-list"
       ↓
6. ViewResolver
   "member-list" → /WEB-INF/views/member-list.jsp
       ↓
7. JSP 엔진 (Jasper)
   - member-list.jsp 로딩
   - Model 데이터 전달
   - <c:forEach> 실행하여 HTML 생성
   - ${member.id} → getId() 호출
       ↓
8. 완성된 HTML
   <!DOCTYPE html>
   <html>
   <body>
       <table>
           <tr><td>1</td><td>홍혜창</td>...</tr>
           <tr><td>2</td><td>김우현</td>...</tr>
           ...
       </table>
   </body>
   </html>
       ↓
9. DispatcherServlet
   HTTP 응답으로 HTML 전송
       ↓
10. 브라우저
    HTML 렌더링 및 화면 표시
```

---

### 5.1.10 JSP의 한계와 문제점

지금까지 JSP를 사용한 MVC 패턴 구현을 학습했습니다. 하지만 JSP는 여러 가지 근본적인 한계를 가지고 있습니다.

---

#### 1. HTML과의 비호환성 (가장 큰 문제)

**문제의 본질**: JSP 파일 자체가 순수한 HTML이 아님

| 항목 | 설명 |
|-----|------|
| **JSP의 구성** | HTML + JSP 문법 (`<% %>`, `<%= %>`) + Java 코드 |
| **브라우저의 이해** | 브라우저는 오직 HTML, CSS, JavaScript만 해석 가능 |
| **결과** | JSP 파일을 로컬에서 바로 열면 브라우저가 JSP 문법을 무시하거나 텍스트로 표시 |

**예시**:

```jsp
<!-- JSP 파일 -->
<h1>회원 수: ${members.size()}</h1>

<!-- 브라우저에서 로컬 파일로 열면 -->
<h1>회원 수: ${members.size()}</h1>  ← 그대로 표시됨 (동작 안 함)
```

**핵심**: JSP는 반드시 서버를 거쳐 HTML로 변환되어야 함!

---

#### 2. 개발 및 디버깅의 비효율성

**서버 구동 필수**:

| 작업 | JSP | 순수 HTML |
|-----|-----|----------|
| **파일 수정** | 수정 | 수정 |
| **결과 확인** | 서버 재시작/리로딩 필요 | 브라우저 새로고침만으로 즉시 확인 |
| **개발 속도** | ⚠️ 느림 | ✅ 빠름 |

**문제 상황**:

```
1. CSS 색상 변경
    ↓
2. 서버 재시작 또는 리로딩
    ↓
3. 브라우저 새로고침
    ↓
4. 결과 확인
    ↓
5. 마음에 안 들면 1~4 반복
```

**핵심**: 간단한 UI 수정도 서버를 거쳐야 하므로 개발 피드백 주기가 느림!

---

#### 3. Jasper 엔진 의존성

**JSP 실행 과정**:

```
JSP 파일
    ↓
Jasper (JSP 컴파일러)
    ↓
서블릿 (Java 클래스)
    ↓
컴파일
    ↓
실행
    ↓
HTML 생성
```

**문제점**:

| 항목 | 설명 |
|-----|------|
| **복잡한 변환 과정** | JSP → 서블릿 → HTML의 다단계 변환 |
| **오버헤드** | 최초 요청 시 컴파일 시간 소요 |
| **디버깅 어려움** | 에러 발생 시 변환된 서블릿 코드를 확인해야 함 |
| **의존성** | Jasper 엔진이 없으면 JSP 실행 불가 (내장 Tomcat에 수동 추가 필요) |

---

#### 4. Model 1 문제의 잔재

**스크립틀릿의 유혹**:

JSP는 여전히 `<% %>` 스크립틀릿으로 Java 코드를 직접 작성할 수 있습니다.

```jsp
<%
    // ⚠️ View에 로직이 들어가는 안티 패턴
    if (members.size() > 10) {
        members = members.subList(0, 10);
    }
%>

<c:forEach items="${members}" var="member">
    <!-- ... -->
</c:forEach>
```

**문제점**:

| 문제 | 설명 |
|-----|------|
| **관심사 혼재** | View에 비즈니스 로직이 포함되어 MVC 원칙 위반 |
| **유지보수 어려움** | 로직이 Controller와 View에 분산 |
| **테스트 불가** | View의 로직은 단위 테스트 불가능 |

**핵심**: JSTL을 사용해도 스크립틀릿을 쓸 수 있어 개발자의 실수 가능성 존재!

---

#### 5. 현대적 프론트엔드와의 부조화

**프론트엔드 생태계**:

| 기술 | JSP와의 호환 | 이유 |
|-----|------------|------|
| **React, Vue, Angular** | ❌ 불가능 | JSP는 서버 렌더링 방식으로 JavaScript 프레임워크와 구조가 다름 |
| **npm, Webpack** | ❌ 어려움 | JSP는 Java 빌드 도구(Gradle, Maven)와 통합되어 있음 |
| **Component 기반 개발** | ❌ 불가능 | JSP는 페이지 기반 방식 |

**핵심**: 현대적 프론트엔드 기술과 함께 사용하기 어려움!

---

#### JSP 한계 요약

| 문제점 | 영향 | 대안 |
|-------|------|------|
| **HTML 비호환** | 로컬에서 확인 불가, 서버 필수 | Thymeleaf (Natural Templates) |
| **개발 속도 저하** | 피드백 주기 느림 | 핫 리로딩 지원 템플릿 엔진 |
| **Jasper 의존성** | 복잡한 변환 과정, 디버깅 어려움 | 단순한 템플릿 엔진 |
| **스크립틀릿 사용 가능** | MVC 원칙 위반 가능성 | 로직 실행 불가능한 템플릿 엔진 |
| **프론트엔드 부조화** | 현대 기술 스택과 통합 어려움 | RESTful API + SPA 또는 Thymeleaf |

---

### 5.1.11 핵심 정리

#### MVC 패턴의 핵심 개념

| 구성 요소 | 역할 | Spring 구현 |
|---------|------|-----------|
| **Model** | 데이터와 비즈니스 로직 | DTO, Entity, Service |
| **View** | 사용자 인터페이스 | JSP, Thymeleaf |
| **Controller** | 요청 처리 및 흐름 제어 | `@Controller`, `@RestController` |

**핵심**: 관심사를 명확히 분리하여 유지보수성과 협업 효율성 향상!

---

#### CSR vs SSR 비교

| 구분 | CSR (RESTful API) | SSR (Spring MVC) |
|-----|------------------|-----------------|
| **데이터 전달** | JSON | Model 객체 |
| **렌더링** | 클라이언트 (JavaScript) | 서버 (템플릿 엔진) |
| **반환 값** | 데이터 객체 (DTO) | View 이름 (문자열) |
| **어노테이션** | `@RestController` | `@Controller` |
| **최종 응답** | JSON | HTML |

**공통점**: 
- Controller → Service → Repository 구조는 동일
- DTO 패턴 사용은 동일

---

#### Model 1 vs Model 2

| 구분 | Model 1 | Model 2 (MVC) |
|-----|---------|--------------|
| **구조** | JSP (로직 + 화면) | Controller (로직) + View (화면) |
| **복잡도** | 높음 | 낮음 |
| **협업** | 어려움 | 용이함 |
| **유지보수** | 어려움 | 용이함 |
| **권장 여부** | ❌ | ✅ |

---

#### Spring MVC 요청 처리 흐름

```
클라이언트 요청
    ↓
DispatcherServlet (Front Controller)
    ↓
HandlerMapping (Controller 찾기)
    ↓
Controller (로직 처리, Model 준비)
    ↓
ViewResolver (View 찾기)
    ↓
View (HTML 생성)
    ↓
클라이언트 응답
```

---

#### JSP 프로젝트 설정 체크리스트

| 항목 | 설정 | 필수 여부 |
|-----|------|---------|
| **패키징** | WAR | ✅ 필수 |
| **Jasper 의존성** | `tomcat-embed-jasper` | ✅ 필수 |
| **JSTL 의존성** | API + 구현체 2개 | ✅ 필수 |
| **ViewResolver 설정** | prefix, suffix | ✅ 필수 |
| **webapp 폴더** | 수동 생성 | ✅ 필수 |
| **WEB-INF/views** | JSP 파일 위치 | ✅ 필수 |

---

#### JSP vs Thymeleaf 미리보기

다음 섹션(5.2)에서 학습할 Thymeleaf는 JSP의 한계를 극복한 현대적 템플릿 엔진입니다.

| 특징 | JSP | Thymeleaf |
|-----|-----|-----------|
| **HTML 호환성** | ❌ 비호환 | ✅ Natural Templates |
| **로컬 확인** | ❌ 불가능 | ✅ 가능 |
| **개발 속도** | ⚠️ 느림 | ✅ 빠름 |
| **로직 포함** | ⚠️ 가능 (스크립틀릿) | ❌ 불가능 (안전) |
| **Spring 통합** | ⚠️ 추가 설정 필요 | ✅ 기본 지원 |
| **권장 여부** | △ 레거시 | ✅ 권장 |

**핵심**: Thymeleaf는 JSP의 문제점을 해결하면서 MVC 패턴의 장점은 그대로 유지!
---


# 5.2 템플릿 엔진과 타임리프

## 5.2.1 템플릿 엔진의 이해

### 템플릿 엔진이란?

**템플릿 엔진(Template Engine)**은 미리 정의된 뼈대 파일(Template)에 동적인 데이터(Model)를 주입하여 최종 결과물을 만들어내는 소프트웨어입니다.

**템플릿 엔진의 핵심 역할**:

| 단계 | 역할 | 설명 |
|-----|------|------|
| **1. 템플릿 읽기** | View 파일 로딩 | Controller가 지정한 View 템플릿 파일을 찾아 읽기 |
| **2. 데이터 채우기** | 동적 데이터 주입 | Model에 담긴 데이터를 템플릿의 변수 영역에 삽입 |
| **3. 결과 생성** | 최종 HTML 생성 | 데이터가 채워진 완성된 HTML 문서 생성 |

---

### JSP도 템플릿 엔진인가?

네, **JSP(JavaServer Pages)**는 템플릿 엔진의 한 종류입니다.

**JSP 엔진의 작동 방식**:

| 기술 | 역할 | 처리 과정 |
|-----|------|---------|
| **JSP** | 템플릿 기술 | JSP 파일을 읽고 Model 데이터를 채워 HTML 생성 |
| **Jasper** | JSP 엔진 | JSP 문법과 Java 코드를 서블릿으로 변환(컴파일)하고 실행하여 HTML 생성 |

---

### JSP의 문제점과 타임리프의 등장

#### JSP의 근본적인 한계

**HTML과의 비호환성 문제**:

| 항목 | JSP | 문제점 |
|-----|-----|-------|
| **문법** | `<% %>`, `<%= %>` | 브라우저가 해석할 수 없는 JSP 전용 문법 |
| **로컬 실행** | 불가능 | 서버 없이 브라우저로 열면 코드가 깨지거나 의도대로 보이지 않음 |
| **개발 효율** | 낮음 | UI 확인을 위해 매번 서버 구동 필요 |
| **유지보수** | 어려움 | HTML과 Java 로직이 혼재 |

---

#### 타임리프의 해결책

**HTML 호환성 극대화**:

| 특징 | 설명 | 장점 |
|-----|------|------|
| **Natural Templates** | HTML 속성 형태의 문법 사용 | 서버 없이도 브라우저에서 View 구조 확인 가능 |
| **th: 접두사** | `th:text`, `th:each` 등 | HTML 표준을 유지하면서 동적 기능 제공 |
| **개발 효율** | 프론트엔드 독립 개발 | 백엔드 없이도 디자인 작업 가능 |

---

### 최신 웹 개발 동향

**템플릿 엔진의 선택**:

| 템플릿 엔진 | 사용 현황 | 특징 |
|-----------|----------|------|
| **JSP** | 감소 추세 | 레거시 시스템 유지보수용 |
| **Thymeleaf** | 증가 추세 | Spring Boot 공식 권장 |
| **FreeMarker** | 일부 사용 | 타임리프와 함께 사용되는 대안 |

**핵심**: 웹 개발에서 JSP 사용은 줄어들고, HTML 호환성을 극대화한 **타임리프(Thymeleaf)**로 전환되는 추세입니다.

---

### 개발자가 템플릿 엔진을 명시하는 이유

#### 1. SSR 구조를 명확히 함

"템플릿 엔진을 사용했다"는 말은 곧 **SSR (서버 측 렌더링) 방식**을 채택했다는 의미입니다.

**아키텍처 정보 전달**:

| 개발 방식 | 의미 | 특징 |
|---------|------|------|
| **템플릿 엔진 사용** | SSR 방식 | 서버가 HTML을 완성해서 전달 |
| **REST API만 개발** | CSR 방식 | 클라이언트가 JavaScript로 렌더링 |

---

#### 2. 기술 환경의 구체화

**템플릿 엔진별 전달되는 정보**:

| 템플릿 엔진 | 전달되는 기술 정보 | 의미 |
|-----------|-----------------|------|
| **Thymeleaf** | HTML 호환성 유지 | 현대적인 Spring Boot SSR 방식 |
| **JSP** | 전통적 방식 사용 | 레거시 시스템 유지보수 |
| **FreeMarker** | 대안 템플릿 엔진 | 특정 요구사항에 따른 선택 |

---

#### 3. 프론트엔드 작업 방식 예측

템플릿 엔진을 명시하면 다음을 예측할 수 있습니다:

- View 코드 작성 방식 (문법)
- 프론트엔드 개발자의 역할 범위
- 협업 방식

**결론**: Spring 개발자가 "View가 필요한 웹 애플리케이션을 만들었다"고 할 때는 어떤 템플릿 엔진을 사용했는지 명시하는 것이 기술 스택 설명의 필수 요소입니다.

---

## 5.2.2 타임리프 프로젝트 생성

### 1단계: 프로젝트 생성 및 의존성 추가

**build.gradle 설정**:

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.7'
    id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
    useJUnitPlatform()
}
```

---

### 템플릿 엔진 의존성 비교

**JSP vs Thymeleaf 의존성**:

| 템플릿 엔진 | 의존성 | 의미 |
|-----------|--------|------|
| **Thymeleaf** | `spring-boot-starter-thymeleaf` | 타임리프를 View 템플릿 엔진으로 사용 |
| **JSP** | `tomcat-embed-jasper`, `jakarta.servlet.jsp.jstl-api` | JSP를 View 엔진으로 사용 (수동 추가 필요) |

**핵심**: 
- **Thymeleaf**: Spring Boot가 자동으로 설정 지원
- **JSP**: 수동으로 의존성 추가 필요

---

### 2단계: View 파일 위치 설정

**JSP와 Thymeleaf의 View 위치 비교**:

| 템플릿 엔진 | View 파일 위치 | 확장자 |
|-----------|--------------|--------|
| **JSP** | `/src/main/webapp/WEB-INF/views/` | `.jsp` |
| **Thymeleaf** | `/src/main/resources/templates/` | `.html` |

**타임리프의 장점**:
- ✅ HTML 표준 확장자 사용
- ✅ `resources` 디렉토리에 위치하여 빌드 시 자동 포함
- ✅ 별도의 `webapp` 폴더 생성 불필요

---

### Controller 작성

**BasicController.java**:

```java
package com.example.thymeleafSample.controller;

import com.example.thymeleafSample.model.Member;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class BasicController {
    
    @GetMapping("/book")
    public String getBook(Model model) {
        model.addAttribute("title", "홍혜창의 이것의 스프링부트다");
        model.addAttribute("description", "예제를 통해 공부해보아용");
        
        Member hyechang = new Member("홍혜창", 20);
        model.addAttribute("member", hyechang);
        
        return "basic/book";
    }
}
```

**Controller 동작 방식**:

| 단계 | 동작 | 설명 |
|-----|------|------|
| 1 | `Model`에 데이터 담기 | `model.addAttribute()` 사용 |
| 2 | View 이름 반환 | `"basic/book"` 문자열 반환 |
| 3 | ViewResolver 작동 | `templates/basic/book.html` 파일 찾기 |
| 4 | 타임리프 엔진 실행 | Model 데이터로 HTML 생성 |

**핵심**: JSP와 Controller 사용 방식은 동일하며, View의 위치와 확장자만 다릅니다!

---

### View 템플릿 작성

**파일 위치**: `src/main/resources/templates/basic/book.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1 th:text="${title}">책제목을 작성하는 부분!</h1>
    <p th:text="${description}">책 설명을 작성하는 부분</p>
    
    <p>
        글쓴이 : <span th:text="${member.name}">누구</span> 
        나이 : <span th:text="${member.age}">몇살</span>
    </p>
</body>
</html>
```

---

### 타임리프 선언의 의미

**xmlns:th 선언**:

```html
<html lang="en" xmlns:th="http://www.thymeleaf.org">
```

| 코드 | 역할 | 필수 여부 |
|-----|------|---------|
| `xmlns:th="..."` | 타임리프 네임스페이스 선언 | ✅ 필수 |
| **효과** | `th:` 접두사 사용 가능 | - |
| **없을 경우** | 타임리프 속성 인식 불가 | - |

**핵심**: 이 선언이 있어야만 `th:text`, `th:each` 같은 타임리프 속성을 사용할 수 있습니다!

---

### 🎯 IntelliJ 템플릿 자동 생성 설정 (팁)

매번 타임리프 기본 구조를 작성하는 것은 번거롭습니다. IntelliJ에서 자동 생성 템플릿을 설정할 수 있습니다.

**설정 방법**:

1. `Ctrl + Alt + S` (설정 열기)
2. `Editor` → `File and Code Templates` 선택
3. `+` 버튼 클릭 (새 템플릿 추가)
4. 다음 내용 입력:

**템플릿 이름**: `Thymeleaf`  
**확장자**: `html`  
**템플릿 내용**:

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
```

5. `Apply` → `OK` 클릭

**사용 방법**:
- 새 파일 생성 시 `Thymeleaf` 메뉴가 추가됨
- 선택하면 타임리프 기본 구조가 자동으로 삽입됨

---

## 5.2.3 타임리프의 핵심 원리

### 서버 구동 시 vs 서버 없이 실행

**타임리프의 두 가지 실행 모드**:

| 구분 | 서버 구동 시 (Controller 경유) | 서버 없이 (로컬 실행) |
|-----|------------------------------|---------------------|
| **타임리프 엔진** | 작동함 | 작동 안 함 |
| **th: 속성 처리** | Model 데이터로 대체됨 | 무시됨 |
| **결과** | 실제 데이터 출력 | HTML 기본값 출력 |

**실행 결과 비교**:

```
서버 구동 시 (http://localhost:8080/book):
- 홍혜창의 이것의 스프링부트다
- 예제를 통해 공부해보아용
- 글쓴이 : 홍혜창 나이 : 20

서버 없이 로컬 실행:
- 책제목을 작성하는 부분!
- 책 설명을 작성하는 부분
- 글쓴이 : 누구 나이 : 몇살
```

---

### Natural Templates의 장점

**프론트-백엔드 협업 구조**:

| 역할 | 작업 내용 | 필요 환경 |
|-----|---------|---------|
| **프론트엔드** | CSS/디자인 작업 | 서버 불필요 (로컬에서 HTML 열기) |
| **백엔드** | 데이터 준비 및 로직 | 서버 필요 (Controller 작성) |

**가상 데이터(Mock Data)의 역할**:

```html
<h1 th:text="${title}">책제목을 작성하는 부분!</h1>
```

- **"책제목을 작성하는 부분!"**: 프론트엔드가 디자인 시 참고하는 가상 데이터
- **`th:text="${title}"`**: 서버 구동 시 실제 데이터로 대체되는 부분

**핵심**: 프론트엔드와 백엔드는 **하나의 동일한 HTML 파일**을 공유하면서도, **서로 간섭 없이 독립적으로** 개발할 수 있습니다!

---

### JSP와 타임리프의 실행 방식 비교

| 항목 | JSP | Thymeleaf |
|-----|-----|-----------|
| **서버 없이 열기** | ❌ 불가능 (코드 깨짐) | ✅ 가능 (HTML로 표시) |
| **디자인 확인** | 서버 필수 | 브라우저만으로 가능 |
| **협업 효율** | 낮음 | 높음 |
| **개발 속도** | 느림 | 빠름 |

---

## 5.2.4 타임리프 기본 문법 소개

### 타임리프 핵심 속성 개요

타임리프의 주요 속성들을 간단히 소개합니다. 각 속성의 상세한 사용법은 뒤의 예제에서 자세히 다룹니다.

**핵심 속성 목록**:

| 속성 | 역할 | 간단 예시 |
|-----|------|---------|
| **th:text** | 텍스트 안전 출력 | `<p th:text="${title}">` |
| **th:utext** | HTML 태그 그대로 출력 | `<p th:utext="${html}">` |
| **th:href** | 동적 URL 생성 | `<a th:href="@{/users}">` |
| **th:if** | 조건부 렌더링 | `<p th:if="${isStudent}">` |
| **th:each** | 반복문 | `<li th:each="item : ${items}">` |
| **th:object** | 객체 선택 | `<div th:object="${member}">` |

**주의**: 이 섹션에서는 간단히 언급만 하고, 5.2.6 섹션에서 각 속성의 상세한 사용법과 예제를 다룹니다.

---

## 5.2.5 메시지 프로퍼티 (Message Properties)

### 메시지 프로퍼티란?

**정의**: 애플리케이션에서 사용하는 텍스트를 외부 파일로 분리하여 관리하는 방식

**파일 위치**: `src/main/resources/messages.properties`

**파일 이름 규칙**: 
- ⚠️ **`messages.properties`** (복수형 - 's' 필수!)
- ❌ `message.properties` (잘못된 이름)

---

### 메시지 프로퍼티 사용 목적

#### 1. 소스 코드 분리 (유지보수 용이)

**장점**:

| 항목 | 설명 |
|-----|------|
| **텍스트 수정** | 설정 파일만 수정하면 되므로 재컴파일 불필요 |
| **관리 편의성** | 모든 텍스트가 한 곳에 모여있어 관리 용이 |
| **사용 시점** | 변경 가능성이 있는 모든 고정 텍스트 |

---

#### 2. 국제화 (i18n) 지원

**장점**:

| 항목 | 설명 |
|-----|------|
| **다국어 지원** | 언어별 파일 분리 (`messages_ko.properties`, `messages_en.properties`) |
| **자동 선택** | 브라우저 언어 설정에 따라 자동으로 적절한 언어 파일 사용 |
| **유지보수** | 번역 텍스트를 코드 수정 없이 추가/변경 가능 |

---

### 메시지 프로퍼티 파일 작성

**messages.properties** (기본 파일):

```properties
welcome=(기본)홍혜창의 스프링부트에 오신 것을 환영합니다.
welcome.description=(기본)스프링부트는 <b>어렵지</b> 않아요!!!
```

**파일 규칙**:

| 항목 | 설명 | 예시 |
|-----|------|------|
| **형식** | `키=값` | `welcome=환영합니다` |
| **키 네이밍** | 점(`.`)으로 계층 구조 표현 | `welcome.description` |
| **HTML 태그** | 값에 HTML 포함 가능 | `<b>굵게</b>` |

---

### 메시지 프로퍼티 사용하기

**Controller 작성**:

```java
@GetMapping("/message")
public String getMessage() {
    return "message/message-basic";
}
```

**View 템플릿** (`message/message-basic.html`):

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h2 th:text="#{welcome}">제목</h2>
    <p th:text="#{welcome.description}"></p>
    <p th:utext="#{welcome.description}"></p>
</body>
</html>
```

**실행 결과**:

```
홍혜창의 스프링부트에 오신 것을 환영합니다.
스프링부트는 <b>어렵지</b> 않아요!!!
스프링부트는 어렵지 않아요!!!
```

---

### th:text vs th:utext

**차이점**:

| 속성 | 역할 | HTML 태그 처리 | 사용 시기 |
|-----|------|--------------|---------|
| **th:text** | 내용 안전 출력 | `<`를 `&lt;`로 치환 (Escape) | 대부분의 경우 (안전) |
| **th:utext** | 내용 그대로 출력 | HTML 태그 그대로 렌더링 | 신뢰할 수 있는 데이터만 |

**주의사항**: `th:utext`는 사용자 입력이 포함된 경우 XSS(Cross-Site Scripting) 공격에 취약할 수 있습니다!

---

### 메시지 표현식의 의미

**`#{키}` 문법**:

```html
<h2 th:text="#{welcome}">제목</h2>
```

**처리 과정**:

```
1. 타임리프 엔진이 #{welcome} 발견
    ↓
2. messages.properties 파일에서 'welcome' 키 검색
    ↓
3. 해당 값 ("홍혜창의 스프링부트에...") 가져오기
    ↓
4. <h2> 태그 내용으로 대체
```

---

## 5.2.6 메시지 파라미터 (플레이스홀더)

### 플레이스홀더란?

**정의**: 메시지 텍스트 내에서 동적 데이터가 삽입될 위치를 표시하는 자리 표시자

**문법**: `{0}`, `{1}`, `{2}` ...

---

### 플레이스홀더 사용 예제

**messages.properties**:

```properties
customer.contact={0} 고객님의 연락처는 {1}입니다.
```

**Controller**:

```java
@GetMapping("/customer")
public String getCustomer(Model model) {
    model.addAttribute("name", "홍혜창");
    model.addAttribute("phone", "010-1111-2222");
    return "message/message-customer";
}
```

**View 템플릿**:

```html
<p th:text="#{customer.contact(${name}, ${phone})}">고객정보</p>
```

**실행 결과**:

```
홍혜창 고객님의 연락처는 010-1111-2222입니다.
```

---

### 플레이스홀더 작동 원리

**매핑 규칙**:

| 메시지 파일 | 타임리프 코드 | 매핑 결과 |
|-----------|-------------|---------|
| `{0}` | `(${name}, ...` | 첫 번째 값 → {0}에 대체 |
| `{1}` | `..., ${phone})` | 두 번째 값 → {1}에 대체 |

**핵심**: 
- ✅ 플레이스홀더는 **순서 기반** (위치가 중요)
- ✅ 소괄호 `()` 안의 값들이 순서대로 매핑됨
- ⚠️ 개수가 맞지 않으면 빈 문자열 또는 에러 발생

---

### 여러 메시지 파일 사용하기

**messages.properties**:

```properties
customer.contact.long={0} 고객님 환영합니다. 오랜만에 방문하셨네요! 전화번호 {1} 맞으시죠?
customer.contact.short={0} : {1}
```

**동적 메시지 키 선택**:

```java
@GetMapping("/customer")
public String getCustomer(Model model) {
    model.addAttribute("type", "customer.contact.long");
    model.addAttribute("name", "홍혜창");
    model.addAttribute("phone", "010-1111-2222");
    return "message/message-customer";
}
```

**View 템플릿**:

```html
<p th:text="#{${type}(${name}, ${phone})}"></p>
```

---

### 중첩 표현식의 이해

**`#{${type}(...)}`의 의미**:

| 평가 순서 | 구문 | 역할 |
|---------|------|------|
| **1순위** | `${type}` | Model에서 "customer.contact.long" 문자열 가져오기 |
| **2순위** | `#{...}` | 가져온 키로 메시지 파일 검색 |
| **3순위** | `(${name}, ${phone})` | 플레이스홀더에 값 주입 |

**실행 결과**:

```
홍혜창 고객님 환영합니다. 오랜만에 방문하셨네요! 전화번호 010-1111-2222 맞으시죠?
```

**핵심**: 메시지 키 자체를 동적으로 결정할 수 있어 유연성이 극대화됩니다!

---

### 실무 활용 사례

**상황별 동적 메시지**:

| 사용 사례 | Model 데이터 | 메시지 키 |
|---------|------------|---------|
| **상품 상태** | `type = "product.status.SHIPPED"` | `#{${type}}` |
| **유효성 검증** | `type = "error.email.invalid"` | `#{${type}}` |
| **알림 메시지** | `type = "notification.order.complete"` | `#{${type}}` |

**장점**:
- ✅ 코드 중복 제거
- ✅ 유지보수 편의성 향상
- ✅ 다국어 지원 용이

---

## 5.2.7 국제화 (Internationalization, i18n)

### 국제화란?

**정의**: 사용자의 언어 설정에 따라 자동으로 해당 언어의 텍스트를 제공하는 기능

---

### 언어별 메시지 파일 분리

**파일 명명 규칙**:

```
기본 이름 + 언더바 + 로케일 코드 + .properties
```

**파일 구조**:

| 파일명 | 역할 | 로케일 |
|-------|------|--------|
| **messages.properties** | 기본값 (Fallback) | 없음 (기본) |
| **messages_ko.properties** | 한국어 | ko |
| **messages_en.properties** | 영어 | en |

---

### 언어별 메시지 파일 작성

**messages_ko.properties**:

```properties
welcome=홍혜창의 스프링부트에 오신 것을 환영합니다.
welcome.description=스프링부트는 <b>어렵지</b> 않아요!!!
```

**messages_en.properties**:

```properties
welcome=Welcome to hyechang spring!!
welcome.description=Spring boot is not <b>difficult</b>
```

---

### 국제화 자동 작동 원리

**Spring의 로케일 해결 과정**:

```
1. HTTP 요청 수신
    ↓
2. Accept-Language 헤더 확인↓
3. 로케일 감지 (예: ko, en)
    ↓
4. 해당 언어 파일 선택 (messages_ko.properties)
    ↓
5. 메시지 키로 값 검색
    ↓
6. View에 텍스트 삽입
```

**핵심**: 개발자가 언어 선택 로직을 작성할 필요 없이, Spring이 자동으로 처리합니다!

---

### Controller 작성

```java
@GetMapping("/language")
public String getLanguage(HttpServletRequest request) {
    // Accept-Language 헤더 확인 (로깅용)
    String acceptLanguage = request.getHeader("Accept-Language");
    log.info("Request Accept-Language Header: {}", acceptLanguage);
    
    return "basic/language-basic";
}
```

---

### View 템플릿

**language-basic.html**:

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h th:text="#{welcome}"></h>
    <p th:utext="#{welcome.description}"></p>
</body>
</html>
```

---

### 브라우저 언어 설정에 따른 결과

**케이스 1: 한국어 우선순위가 높은 경우**

**브라우저 설정**:
```
1. 한국어
2. 영어(미국)
3. 영어
```

**실행 결과**:
```
홍혜창의 스프링부트에 오신 것을 환영합니다.
스프링부트는 어렵지 않아요!!!
```

---

**케이스 2: 영어 우선순위가 높은 경우**

**브라우저 설정**:
```
1. English (United States)
2. Korean
3. English
```

**실행 결과**:
```
Welcome to hyechang spring!!
Spring boot is not difficult
```

---

### Accept-Language 헤더의 역할

**HTTP 헤더 예시**:

```
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```

**구성 요소**:

| 항목 | 의미 | 우선순위 |
|-----|------|---------|
| `ko-KR` | 한국어 (한국) | 가장 높음 (1.0) |
| `ko;q=0.9` | 한국어 | 0.9 |
| `en-US;q=0.8` | 영어 (미국) | 0.8 |
| `en;q=0.7` | 영어 | 가장 낮음 (0.7) |

**Spring의 처리**:
1. 우선순위가 가장 높은 언어 확인 (`ko-KR`)
2. 해당하는 메시지 파일 찾기 (`messages_ko.properties`)
3. 파일이 없으면 다음 우선순위 언어 시도
4. 모두 없으면 기본 파일 사용 (`messages.properties`)

---

### 기본 파일(messages.properties)의 필요성

**Fallback 역할**:

| 상황 | 기본 파일 있음 | 기본 파일 없음 |
|-----|-------------|-------------|
| **지원하지 않는 언어** | 기본 텍스트 표시 | 에러 또는 `??키이름??` 표시 |
| **안정성** | 높음 | 낮음 |
| **권장 여부** | ✅ 권장 | ❌ 비권장 |

**핵심**: `messages.properties` 기본 파일은 반드시 있어야 안정적인 애플리케이션 운영이 가능합니다!

---

### 동적 데이터의 국제화

**문제**: 데이터베이스에서 가져온 동적 데이터는 어떻게 국제화하나?

**해결**: 문장 구조만 번역하고, 동적 데이터는 플레이스홀더로 처리

**messages_en.properties**:

```properties
order.summary=Your order for {0} items was placed on {1}.
```

**messages_ko.properties**:

```properties
order.summary={0}개의 상품 주문이 {1}에 완료되었습니다.
```

**View 템플릿**:

```html
<p th:text="#{order.summary(${orderCount}, ${orderDate})}">주문 요약</p>
```

**실행 결과**:

| 언어 | orderCount = 3, orderDate = "2025-10-29" |
|-----|------------------------------------------|
| **한국어** | 3개의 상품 주문이 2025-10-29에 완료되었습니다. |
| **영어** | Your order for 3 items was placed on 2025-10-29. |

**핵심**: Spring은 데이터를 번역하는 것이 아니라, **데이터를 감싸는 문장 구조**를 언어별로 준비하고 동적 데이터를 적절한 위치에 삽입합니다!

---

## 5.2.8 타임리프 표현식 상세

### Model 객체 준비

**Member.java**:

```java
package com.example.thymeleafSample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Member {
    String name;
    int age;
}
```

**Customer.java**:

```java
package com.example.thymeleafSample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Customer {
    String name;
    String email;
    int age;
}
```

---

### Controller 작성

```java
@Controller
@Slf4j
public class BasicController {
    
    List<Customer> customers = List.of(
        new Customer("홍혜창", "hyechang@spring.ac.kr", 10),
        new Customer("김우현", "woohyun@spring.ac.kr", 10),
        new Customer("김구라", "gura@spring.ac.kr", 10)
    );

    @GetMapping("/thymeleaf")
    public String getThymeleaf(Model model) {
        model.addAttribute("firstCustomer", customers.get(0));
        
        Date date = Calendar.getInstance().getTime();
        model.addAttribute("date", date);
        model.addAttribute("number", 12.1);
        model.addAttribute("intNumber", 10);
        
        model.addAttribute("isStudent", true);
        model.addAttribute("isTeacher", false);
        model.addAttribute("grade", 4);
        
        model.addAttribute("customers", customers);
        
        return "basic/thymeleaf-basic";
    }
}
```

---

### ${} 표현식의 정확한 의미

**중요한 깨달음**: `${}`는 단순히 Model에 접근하는 것이 아니라, **Model 데이터를 사용할 수 있는 평가 공간**을 제공합니다!

**잘못된 이해**:
```
${name}으로만 접근 가능
```

**올바른 이해**:
```
${} 안에서 Model 데이터를 조합하고 연산할 수 있음
```

---

### ${} 내부에서 가능한 작업

**1. 단순 접근**:

```html
<p th:text="${name}">이름</p>
<p th:text="${age}">나이</p>
```

---

**2. 문자열 조합**:

```html
<p th:text="${'이름은 ' + name + ' 나이는 ' + age}">정보</p>
```

**주의**: 문자열 리터럴은 반드시 **작은따옴표**로 감싸야 합니다!

---

**3. 메서드 호출**:

```html
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}">날짜</p>
```

**핵심**: `date` 앞에 `$`를 붙이지 않는 이유는 이미 `${}` 평가 공간 안에 있기 때문입니다!

---

### 이중 $ 사용 금지

**잘못된 코드**:

```html
<!-- ❌ 잘못된 예시 -->
<p th:text="${#calendars.format(${date}, 'yyyy-MM-dd')}">날짜</p>
```

**올바른 코드**:

```html
<!-- ✅ 올바른 예시 -->
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}">날짜</p>
```

**이유**:

| 구문 | 의미 |
|-----|------|
| `${}` | 평가 공간 시작 |
| `date` | 평가 공간 내에서 자동으로 Model 키로 인식 |
| `${date}` | 불필요한 중복 (문법 오류) |

---

### 객체 접근 방식

**방법 1: 일반 접근**

```html
<h1>th:text 객체 사용법1</h1>
<ul>
    <li th:text="${firstCustomer.name}">이름부분</li>
    <li th:text="${firstCustomer.email}">이메일부분</li>
    <li th:text="${firstCustomer.age}">나이부분</li>
</ul>
```

**실행 결과**:
```
홍혜창
hyechang@spring.ac.kr
10
```

---

**방법 2: 선택 변수 표현식 (th:object + `*{}`)**

```html
<h1>th:text 객체 사용법2</h1>
<ul th:object="${firstCustomer}">
    <li th:text="*{name}">이름부분</li>
    <li th:text="*{email}">이메일부분</li>
    <li th:text="*{age}">나이부분</li>
</ul>
```

**실행 결과**:
```
홍혜창
hyechang@spring.ac.kr
10
```

---

### 선택 변수 표현식 (*{}) 상세

**th:object의 역할**:

| 항목 | 설명 |
|-----|------|
| **선언** | 부모 태그에서 객체 지정 |
| **효과** | 하위 태그에서 `*{}`로 간단히 접근 가능 |
| **스코프** | 가장 가까운 상위 `th:object` 태그까지 |

---

### *{} vs ${} 비교

| 방식 | 코드 | 원리 | 장점 |
|-----|------|------|------|
| **일반 접근** | `${firstCustomer.name}` | 매번 객체 이름 명시 | 직관적 |
| **선택 접근** | `*{name}` | 부모의 `th:object` 상속 | 코드 간결 |

**수식으로 표현**:
```
*{name} ≡ (부모 태그의 th:object 객체).name
```

---

### th:object 사용의 장점

**1. 코드 간결성**:

```html
<!-- 일반 접근: 긴 객체 이름 반복 -->
${veryLongObjectName.name}
${veryLongObjectName.email}
${veryLongObjectName.age}

<!-- 선택 접근: 간결함 -->
<div th:object="${veryLongObjectName}">
    *{name}
    *{email}
    *{age}
</div>
```

---

**2. 성능 최적화 (Micro-Optimization)**:

| 항목 | 설명 |
|-----|------|
| **객체 탐색** | 한 번만 수행 |
| **재사용** | 하위 요소에서 캐시된 객체 사용 |
| **효과** | 복잡한 View에서 미세한 성능 향상 |

---

**3. 폼 바인딩과의 연계**:

```html
<form th:object="${item}">
    <input th:field="*{name}">
    <input th:field="*{price}">
</form>
```

**핵심**: Spring MVC의 폼 처리 표준 방식으로, 유효성 검증과 자동 연동됩니다!

---

### 중첩된 th:object

**중첩 구조 예시**:

```html
<div th:object="${outerObject}">
    <span th:text="*{name}">Outer Name</span>
    
    <ul th:object="${innerObject}">
        <li th:text="*{title}">Inner Title</li>
    </ul>
    
    <p th:text="*{description}">Outer Description</p>
</div>
```

**작동 원리**:

| 요소 | 참조하는 객체 | 이유 |
|-----|------------|------|
| `<span>` | `outerObject` | 가장 가까운 상위 `th:object` |
| `<li>` | `innerObject` | 바로 위의 `<ul>` 태그에 새로운 객체 선언 |
| `<p>` | `outerObject` | `<ul>` 밖이므로 다시 `outerObject` 참조 |

**핵심**: `*{}`는 항상 **가장 가까운 상위 태그**의 `th:object`를 참조합니다!

---

## 5.2.9 유틸리티 객체

### # 기호의 두 가지 역할

**중요한 구분**:

| 구분 | 문법 | 역할 | 예시 |
|-----|------|------|------|
| **메시지 표현식** | `#{키}` | 외부 파일 텍스트 접근 | `#{welcome}` |
| **유틸리티 객체** | `${#객체.메서드}` | 타임리프 기본 제공 기능 | `${#calendars.format(...)}` |

**핵심**: 같은 `#` 기호지만 사용 위치와 문맥에 따라 역할이 다릅니다!

---

### 유틸리티 객체를 ${} 안에 사용하는 이유

**잘못된 사용**:

```html
<!-- ❌ 문자열로만 취급됨 -->
<p th:text="#calendars.format(date)">#calendars.format(date)</p>
```

**올바른 사용**:

```html
<!-- ✅ 실행되어 결과 반환 -->
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}">2025-10-29</p>
```

**이유**:

| 구문 | 타임리프 해석 | 결과 |
|-----|------------|------|
| `th:text="#calendars..."` | 고정된 문자열 리터럴 | 문자 그대로 출력 |
| `th:text="${#calendars...}"` | 실행 가능한 표현식 | 메서드 실행 후 결과 출력 |

---

### ${} 의 정확한 의미

**최종 정의**: `${}`는 **"평가 및 출력 지시자"**입니다.

**동작 과정**:

```
1. 평가 (Evaluation)
   - 내부 표현식을 Java 코드처럼 실행
   
2. 변환 (Conversion)
   - 실행 결과를 문자열로 변환
   
3. 출력 (Output)
   - HTML 텍스트로 삽입
```

---

### 날짜 유틸리티 (#calendars)

**사용 예시**:

```html
<h2>유틸리티 객체 사용하기 calendars</h2>
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}"></p>
```

**실행 결과**:
```
2025-10-29
```

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | `date` 변수로 Model에서 Date 객체 가져오기 |
| 2 | `#calendars.format()` 메서드 호출 |
| 3 | 지정된 형식으로 날짜 문자열 반환 |
| 4 | HTML에 문자열 삽입 |

---

### 숫자 유틸리티 (#numbers)

**formatDecimal 사용**:

```html
<h2>유틸리티 객체 사용하기 numbers</h2>
<p th:text="${'기본 : ' + number}"></p>
<p th:text="${#numbers.formatDecimal(number, 5, 3)}"></p>
```

**Model 데이터**:
```java
model.addAttribute("number", 12.1);
```

**실행 결과**:
```
기본 : 12.1
00012.100
```

---

**formatDecimal 메서드 분석**:

```
#numbers.formatDecimal(number, minIntegerDigits, decimalDigits)
```

| 매개변수 | 값 | 역할 | 결과 |
|---------|-----|------|------|
| `number` | 12.1 | 포맷팅 대상 | - |
| `minIntegerDigits` | 5 | 정수부 최소 자릿수 | 앞에 0 채움 → 00012 |
| `decimalDigits` | 3 | 소수부 자릿수 고정 | 뒤에 0 채움 → .100 |

**핵심**: 정수부는 최소 자릿수를 보장하고, 소수부는 정확히 지정된 자릿수로 고정합니다!

---

**formatInteger 사용**:

```html
<p th:text="${'기본 : ' + intNumber}"></p>
<p th:text="${#numbers.formatInteger(intNumber, 10)}"></p>
```

**Model 데이터**:
```java
model.addAttribute("intNumber", 10);
```

**실행 결과**:
```
기본 : 10
0000000010
```

**작동 원리**:

| 항목 | 값 | 설명 |
|-----|-----|------|
| **입력** | 10 (2자리) | - |
| **최소 자릿수** | 10자리 | - |
| **패딩** | 앞에 8개의 0 추가 | 0000000010 |

---

### 메서드 호출의 이해

**객체 속성 접근 시 내부 동작**:

```html
<li th:text="${member.age}">나이</li>
```

**실제 호출**:
```java
member.getAge()
```

**처리 과정**:

```
1. ${} 평가 공간 진입
    ↓
2. member 객체 찾기 (Model에서)
    ↓
3. .age 발견 → getAge() 메서드 자동 호출 (JavaBean 규약)
    ↓
4. 반환 값(int 30)을 문자열("30")로 변환
    ↓
5. HTML에 삽입
```

---

**일반 메서드 호출**:

```html
<p th:text="${member.calculateScore()}">점수</p>
<p th:text="${member.isAdult(20)}">성인 여부</p>
```

**가능한 접근 형태**:

| 접근 형태 | 예시 | 내부 호출 | 비고 |
|---------|------|----------|------|
| **속성** | `${member.name}` | `member.getName()` | 가장 일반적 |
| **일반 메서드** | `${member.calculateScore()}` | `member.calculateScore()` | 반환 값 필요 |
| **파라미터 전달** | `${member.isAdult(20)}` | `member.isAdult(20)` | 인자 전달 가능 |

**주의사항**:
- ⚠️ View에서는 **읽기 전용(Read-only)** 메서드만 호출
- ❌ 데이터 변경 또는 복잡한 로직은 Controller/Service에서 처리
- ✅ 간단한 포맷팅, 계산 메서드만 View에서 사용

---

## 5.2.10 조건문 (th:if, th:unless)

### th:if의 역할

**정의**: 조건식의 결과가 `true`일 때만 해당 HTML 요소를 렌더링

**Model 데이터**:

```java
model.addAttribute("isStudent", true);
model.addAttribute("isTeacher", false);
model.addAttribute("grade", 4);
```

---

### th:if 사용 예시

```html
<h2>th:if</h2>
<p th:if="${isStudent}">학생입니다.</p>
<p th:if="${isTeacher}">선생입니다.</p>
<p th:if="${isStudent or isTeacher}">학생 또는 선생입니다.</p>
<p th:if="${grade == 4}">4학년입니다.</p>
<p th:if="${showExtra == null}">showExtra는 없습니다.</p>
```

**실행 결과**:
```
학생입니다.
학생 또는 선생입니다.
4학년입니다.
showExtra는 없습니다.
```

---

### th:if 작동 원리

**평가 과정**:

| 타임리프 코드 | 평가식 | 불리언 결과 | 렌더링 | 출력 |
|-------------|--------|----------|-------|------|
| `th:if="${isStudent}"` | true | true | ✅ | 학생입니다. |
| `th:if="${isTeacher}"` | false | false | ❌ | (제거됨) |
| `th:if="${isStudent or isTeacher}"` | true or false | true | ✅ | 학생 또는... |
| `th:if="${grade == 4}"` | 4 == 4 | true | ✅ | 4학년입니다. |
| `th:if="${showExtra == null}"` | null == null | true | ✅ | showExtra는... |

**핵심**: `th:if`는 조건이 `false`일 때 **HTML에서 완전히 제거**합니다!

---

### th:unless의 역할

**정의**: `th:if`의 반대로, 조건이 `false`일 때만 렌더링

**영어 의미**: "~가 아니라면" (if not)

**수식 표현**:
```
th:unless(Condition) ≡ th:if(¬Condition)
```

---

### th:unless 사용 예시

```html
<p th:if="${isLoggedIn}">로그아웃</p>
<p th:unless="${isLoggedIn}">로그인</p>
```

**작동 비교**:

| 조건식 결과 | th:if="조건" | th:unless="조건" |
|-----------|------------|----------------|
| **true** | 렌더링됨 | 렌더링되지 않음 |
| **false** | 렌더링되지 않음 | 렌더링됨 |

---

### 조건문 활용 예시

**null 체크**:

```html
<div th:if="${user != null}">
    환영합니다, <span th:text="${user.name}"></span>님!
</div>

<div th:unless="${user != null}">
    <a th:href="@{/login}">로그인</a>이 필요합니다.
</div>
```

---

**컬렉션 비어있음 체크**:

```html
<div th:if="${list.size() > 0}">
    <p>항목이 있습니다.</p>
</div>

<div th:unless="${list.size() > 0}">
    <p>항목이 없습니다.</p>
</div>
```

---

### th:if vs th:unless 정리

| 조건식 | 의미 | th:unless 작동 (렌더링 여부) |
|-------|------|----------------------------|
| `${user == null}` | user가 null | user가 null이 아닐 때 (로그인 상태) |
| `${user != null}` | user가 null 아님 | user가 null일 때 (로그아웃 상태) |
| `${list.size() > 0}` | 리스트에 요소 있음 | 리스트가 비어있을 때 |
| `${status == 'ACTIVE'}` | 상태가 ACTIVE | 상태가 ACTIVE 아닐 때 |

---

## 5.2.11 반복문 (th:each)

### th:each의 역할

**정의**: 컬렉션(리스트, 배열)의 각 요소만큼 HTML 요소를 반복 생성

**문법**:
```
th:each="변수명 : ${컬렉션명}"
```

---

### 기본 사용법

```html
<h2>th:each 사용법1</h2>
<p>회원목록</p>
<table>
    <tr th:each="c : ${customers}">
        <td th:text="${c.name}"></td>
        <td th:text="${c.email}"></td>
        <td th:text="${c.age}"></td>
    </tr>
</table>
```

**실행 결과**:
```
회원목록
홍혜창  hyechang@spring.ac.kr  10
김우현  woohyun@spring.ac.kr   10
김구라  gura@spring.ac.kr      10
```

---

### th:each 작동 원리

| 코드 부분 | 역할 | 설명 |
|---------|------|------|
| `${customers}` | 컬렉션 참조 | Model에서 List<Customer> 가져오기 |
| `c` | 반복 변수 | 각 반복마다 하나의 Customer 객체 저장 |
| `${c.name}` | 객체 속성 접근 | c.getName() 호출 |

**처리 흐름**:

```
1. customers 리스트 가져오기 (3개 요소)
    ↓
2. 첫 번째 Customer → c 변수에 저장
    ↓
3. <tr> 블록 실행 (첫 번째 행 생성)
    ↓
4. 두 번째 Customer → c 변수에 저장
    ↓
5. <tr> 블록 실행 (두 번째 행 생성)
    ↓
6. 세 번째 Customer → c 변수에 저장
    ↓
7. <tr> 블록 실행 (세 번째 행 생성)
    ↓
8. 반복 종료
```

---

### 반복 상태 객체 (iteration)

**문법**:
```
th:each="요소변수, 상태변수 : ${컬렉션}"
```

**사용 예시**:

```html
<h2>th:each 사용법2 iteration 사용추가</h2>
<table>
    <tr th:each="c, iteration : ${customers}"
        th:style="${iteration.even ? 'background-color: lightgray;' : ''}">
        <td th:text="${'현재 처리중인 리스트 인덱스' + iteration.index}"></td>
        <td th:text="${'현재 반복 순번(1부터시작)' + iteration.count}"></td>
        <td th:text="${'전체 반복 사이즈 ' + iteration.size}"></td>
        <td th:text="${iteration.even == true ? '짝수' : '홀수'}"></td>
        <td th:text="${iteration.first ? '처음' : '처음아님'}"></td>
        <td th:text="${iteration.last ? '마지막' : '마지막아님'}"></td>
        <td th:text="${c.name}"></td>
        <td th:text="${c.email}"></td>
        <td th:text="${c.age}"></td></tr>
</table>
```

**실행 결과**:
```
현재 처리중인 리스트 인덱스0  현재 반복 순번(1부터시작)1  전체 반복 사이즈 3  홀수  처음  마지막아님  홍혜창  hyechang@spring.ac.kr  10

(회색배경) 현재 처리중인 리스트 인덱스1  현재 반복 순번(1부터시작)2  전체 반복 사이즈 3  짝수  처음아님  마지막아님  김우현  woohyun@spring.ac.kr  10

현재 처리중인 리스트 인덱스2  현재 반복 순번(1부터시작)3  전체 반복 사이즈 3  홀수  처음아님  마지막  김구라  gura@spring.ac.kr  10
```

---

### iteration 객체 속성 정리

**iteration은 타임리프가 자동으로 생성하는 유틸리티 객체**입니다.

| 속성 | 1번째 요소 | 2번째 요소 | 3번째 요소 | 설명 |
|-----|----------|----------|----------|------|
| **index** | 0 | 1 | 2 | 0부터 시작하는 인덱스 |
| **count** | 1 | 2 | 3 | 1부터 시작하는 순번 |
| **size** | 3 | 3 | 3 | 컬렉션 전체 크기 |
| **even** | false | true | false | 짝수 번째 여부 |
| **odd** | true | false | true | 홀수 번째 여부 |
| **first** | true | false | false | 첫 번째 여부 |
| **last** | false | false | true | 마지막 여부 |

---

### iteration의 특징

**1. 유틸리티 객체**:

| 항목 | 설명 |
|-----|------|
| **성격** | 반복 상태 확인 기능 제공 |
| **생성 시점** | 타임리프 엔진이 반복마다 자동 생성 |
| **독립성** | customers 리스트와는 별개의 객체 |

**핵심**: `#numbers`나 `#calendars`처럼 타임리프가 제공하는 **반복문 전용 유틸리티 객체**입니다!

---

**2. 스타일 적용 활용**:

```html
<tr th:each="c, iteration : ${customers}"
    th:style="${iteration.even ? 'background-color: lightgray;' : ''}">
```

**작동 원리**:

| 반복 | iteration.even | 스타일 적용 | 결과 |
|-----|---------------|-----------|------|
| 1번째 | false | 스타일 없음 | 흰색 배경 |
| 2번째 | true | `background-color: lightgray;` | 회색 배경 |
| 3번째 | false | 스타일 없음 | 흰색 배경 |

**실무 활용**: 테이블 행마다 다른 배경색을 주는 **스트라이프(Stripe) 패턴** 구현에 유용합니다!

---

## 5.2.12 th:block 태그

### th:block이란?

**정의**: HTML 구조에 영향을 주지 않으면서 타임리프 로직을 적용할 수 있는 **투명한 컨테이너**

**특징**:

| 항목 | 설명 |
|-----|------|
| **역할** | 타임리프 논리 적용을 위한 가상 컨테이너 |
| **최종 HTML** | 렌더링 후 흔적 없이 사라짐 |
| **용도** | 여러 요소를 묶어 제어하되 HTML 구조는 유지 |

---

### th:block 사용 예시

**예시 1: 여러 요소를 함께 반복**

```html
<h2>iteration, each를 block태그를 이용하여 사용하기</h2>
<th:block th:each="customer, iteration : ${customers}">
    <p th:text="${iteration.index + '인덱스 설명'}"></p>
    <p>
        이름은 <span th:text="${customer.name}"></span> 이고,
        나이는 <span th:text="${customer.age}"></span>입니다.
    </p>
</th:block>
```

**실행 결과**:
```
0인덱스 설명
이름은 홍혜창 이고, 나이는 10입니다.

1인덱스 설명
이름은 김우현 이고, 나이는 10입니다.

2인덱스 설명
이름은 김구라 이고, 나이는 10입니다.
```

**핵심**: `<th:block>` 태그는 사라지고, 그 안의 `<p>` 태그들만 3세트가 생성됩니다!

---

### div vs th:block 비교

**문제 상황**: 반복문을 적용하려면 부모 태그가 필요한데, 불필요한 `<div>`가 생성되는 문제

**예시 1: div 사용 시**

```html
<h2>th:block 태그의 중요성</h2>
<p>쓸데 없는 div 제거!</p>
<p>아래의 div 개수는 3</p>
<div th:each="c : ${customers}">
    <span th:text="${c.name}"></span> : <span th:text="${c.age}"></span>
</div>
```

**생성되는 HTML**:

```html
<div>홍혜창 : 10</div>
<div>김우현 : 10</div>
<div>김구라 : 10</div>
```

**문제점**:
- ❌ 불필요한 `<div>` 태그 3개 생성
- ❌ CSS/레이아웃에 의도치 않은 영향 가능

---

**예시 2: th:block 사용 시**

```html
<p>아래의 div 개수는 0</p>
<th:block th:each="c : ${customers}">
    <span th:text="${c.name}"></span> : <span th:text="${c.age}"></span>
</th:block>
```

**생성되는 HTML**:

```html
<span>홍혜창</span> : <span>10</span>
<span>김우현</span> : <span>10</span>
<span>김구라</span> : <span>10</span>
```

**장점**:
- ✅ `<th:block>` 태그는 완전히 제거됨
- ✅ 깨끗한 HTML 구조 유지
- ✅ CSS/레이아웃에 영향 없음

---

### th:block 사용이 필요한 경우

**케이스 1: 여러 독립된 태그를 함께 반복**

```html
<th:block th:each="item : ${items}">
    <h3 th:text="${item.title}"></h3>
    <p th:text="${item.description}"></p>
    <hr>
</th:block>
```

**효과**: `<h3>`, `<p>`, `<hr>` 세 개의 요소가 하나의 단위로 반복되지만, 부모 태그는 생성되지 않습니다.

---

**케이스 2: 조건부로 여러 요소 표시**

```html
<th:block th:if="${user.isAdmin}">
    <h2>관리자 메뉴</h2>
    <ul>
        <li>사용자 관리</li>
        <li>설정</li>
    </ul>
</th:block>
```

**효과**: 관리자일 때만 여러 요소를 표시하되, 불필요한 래퍼 태그 없이 깔끔하게 처리됩니다.

---

### th:block 정리

**핵심 원칙**:

| 항목 | 설명 |
|-----|------|
| **목적** | 여러 요소를 하나의 단위로 묶어 제어 |
| **효과** | HTML 구조는 건드리지 않음 |
| **사용 시점** | 반복/조건 로직 적용 시 부모 태그가 필요하지만 생성하고 싶지 않을 때 |

**비유**: 
- `<div>`는 실제 상자 (HTML에 남음)
- `<th:block>`은 투명한 상자 (사라짐)

---

## 5.2.13 링크 생성 (th:href)

### Context Path의 이해

링크 생성을 설명하기 전에, **Context Path** 개념을 먼저 이해해야 합니다.

---

### Context Path란?

**정의**: 웹 애플리케이션의 URL 상의 루트 경로

**역할**: 하나의 서버에서 여러 애플리케이션을 구분하는 식별자

---

### WAR vs JAR 배포 방식의 차이

#### WAR 배포 (전통적 방식)

**구조**:

```
AWS EC2 인스턴스 (가상 컴퓨터)
    ↓
외장 Tomcat 설치 (WAS 소프트웨어)
    ↓
여러 WAR 파일 배포
- app1.war
- app2.war
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **WAS** | 하나의 Tomcat 프로세스 |
| **포트** | 8080 하나만 사용 |
| **애플리케이션 구분** | Context Path로 구분 |

**접근 방식**:

```
http://서버IP:8080/app1/users  → app1.war 실행
http://서버IP:8080/app2/users  → app2.war 실행
```

**핵심**: 
- ✅ 포트는 공유 (8080)
- ✅ Context Path로 애플리케이션 구분 (`/app1`, `/app2`)

---

#### JAR 배포 (현대적 방식)

**구조**:

```
AWS EC2 인스턴스 (가상 컴퓨터)
    ↓
독립적인 JAR 파일들 (각각 내장 Tomcat 포함)
- java -jar hyechang.jar (8080 포트)
- java -jar woohyun.jar (8081 포트)
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **WAS** | 각 JAR마다 독립적인 Tomcat |
| **포트** | 각각 다른 포트 사용 |
| **애플리케이션 구분** | 포트 번호로 구분 |

**접근 방식**:

```
http://서버IP:8080/users  → hyechang.jar
http://서버IP:8081/users  → woohyun.jar
```

**핵심**: 
- ✅ 각 애플리케이션이 독립적인 프로세스
- ✅ 포트 번호로 구분

---

### AWS와 EC2의 역할

**중요한 이해**:

| 개념 | 역할 | 비유 |
|-----|------|------|
| **AWS** | IT 인프라 플랫폼 | 부동산 회사 |
| **EC2 인스턴스** | 가상 컴퓨터 (하드웨어) | 빌린 사무실 |
| **Tomcat** | WAS 소프트웨어 | 사무실 안의 가구 |

**핵심**: 
- ❌ EC2가 Tomcat 서버가 아님
- ✅ EC2는 Tomcat이 구동될 수 있는 **컴퓨터 환경**을 제공

---

### WAR 배포 과정 상세

**1단계: 서버 컴퓨터 준비**

```
요청: "AWS님, Tomcat을 구동할 수 있는 가상 컴퓨터 주세요"
    ↓
AWS: EC2 인스턴스 생성 (가상 컴퓨터)
```

---

**2단계: WAS 설치**

```
개발자: EC2에 외장 Tomcat 소프트웨어 설치
    ↓
Tomcat 프로세스 실행 (8080 포트 오픈)
```

---

**3단계: 애플리케이션 배포**

```
app1.war, app2.war 파일을 Tomcat에 배포
    ↓
하나의 Tomcat 프로세스가 여러 WAR 처리
```

---

**4단계: Context Path로 구분**

| 요청 URL | Context Path | 처리 애플리케이션 |
|---------|-------------|----------------|
| `IP:8080/app1/users` | `/app1` | app1.war |
| `IP:8080/app2/users` | `/app2` | app2.war |

**작동 원리**:

```
클라이언트 요청: IP:8080/app1/users
    ↓
Tomcat: "앞의 /app1을 보니 app1.war로 보내야겠다"
    ↓
app1.war의 /users 컨트롤러 실행
```

---

### JAR 배포 과정 상세

**1단계: 서버 컴퓨터 준비**

```
요청: "AWS님, JAR 파일을 실행할 수 있는 가상 컴퓨터 주세요"
    ↓
AWS: EC2 인스턴스 생성 (Java 설치)
```

---

**2단계: JAR 파일 실행**

```
java -jar hyechang.jar
    ↓
내장 Tomcat 프로세스 생성 (8080 포트)

java -jar woohyun.jar
    ↓
또 다른 내장 Tomcat 프로세스 생성 (8081 포트)
```

**핵심**: 각 JAR은 독립적인 프로세스로 실행됩니다!

---

**3단계: 포트로 구분**

| 요청 URL | 포트 | 처리 애플리케이션 |
|---------|------|----------------|
| `IP:8080/users` | 8080 | hyechang.jar |
| `IP:8081/users` | 8081 | woohyun.jar |

**작동 원리**:

```
클라이언트 요청: IP:8080/users
    ↓
EC2: "8080 포트로 온 요청이니 hyechang.jar로 보낸다"
    ↓
hyechang.jar의 /users 컨트롤러 실행
```

---

### Nginx와 포트 관리

**문제 상황**: 
- JAR 방식에서 사용자가 포트 번호를 알아야 함
- `http://IP:8080/users`, `http://IP:8081/users`

**해결책: Nginx 프록시 서버 사용**

---

### Nginx의 역할

**1. 80번 포트 사용 (HTTP 표준)**

| 프로토콜 | 기본 포트 | 생략 가능 |
|---------|---------|---------|
| **HTTP** | 80 | ✅ |
| **HTTPS** | 443 | ✅ |

**효과**: 사용자가 포트 번호를 입력하지 않아도 자동으로 80번 포트로 연결됩니다.

---

**2. 경로 기반 라우팅**

**Nginx 설정 예시**:

```nginx
location /hyechang/ {
    proxy_pass http://localhost:8080/;
}

location /woohyun/ {
    proxy_pass http://localhost:8081/;
}
```

**작동 방식**:

| 클라이언트 요청 | Nginx 판단 | 내부 전달 |
|--------------|-----------|---------|
| `IP/hyechang/users` | `/hyechang/` 경로 발견 | `localhost:8080/users` |
| `IP/woohyun/users` | `/woohyun/` 경로 발견 | `localhost:8081/users` |

---

**3. 포트 번호 숨기기**

**장점**:

| 항목 | Nginx 없이 | Nginx 사용 시 |
|-----|-----------|-------------|
| **클라이언트 접근** | `IP:8080/users` | `IP/hyechang/users` |
| **포트 노출** | 8080 포트 노출 | 80번 포트만 노출 |
| **보안** | 내부 구조 노출 | 내부 구조 숨김 |

---

### Nginx 작동 흐름 정리

```
1. 클라이언트: http://IP/hyechang/users 요청
   (포트 생략 = 자동으로 80번 포트)
    ↓
2. EC2의 Nginx(80번 포트): 요청 수신
    ↓
3. Nginx: "/hyechang/ 경로네? 8080 포트로 전달해야지"
    ↓
4. 내부 전달: localhost:8080/users
    ↓
5. hyechang.jar(8080 포트): 요청 처리
    ↓
6. Nginx를 통해 클라이언트에게 응답 전달
```

**핵심**: 
- ✅ 클라이언트는 80번 포트와 경로만 알면 됨
- ✅ 내부 포트(8080, 8081)는 Nginx가 관리
- ✅ 보안성과 관리 편의성 향상

---

### WAR vs JAR 배포 방식 최종 비교

| 구분 | WAR 배포 | JAR 배포 |
|-----|---------|---------|
| **WAS 설치** | 외장 Tomcat 수동 설치 필요 | 내장 Tomcat 포함 (설치 불필요) |
| **프로세스** | 하나의 Tomcat 프로세스 | 각 JAR마다 독립 프로세스 |
| **포트 사용** | 하나의 포트 공유 (8080) | 각각 다른 포트 사용 |
| **애플리케이션 구분** | Context Path로 구분 | 포트 번호로 구분 |
| **접근 URL** | `IP:8080/app1/users` | `IP:8080/users` |
| **배포 방식** | WAR 파일을 Tomcat에 배포 | `java -jar` 명령으로 실행 |
| **현대 트렌드** | 레거시 시스템 | Spring Boot 권장 방식 |

---

### Context Path 설정

**application.properties**:

```properties
spring.application.name=thymeleafSample

server.servlet.context-path=/hyechang
```

---

### Context Path 설정의 효과

**1. URL 접두사 강제**

| 설정 전 | 설정 후 (`/hyechang`) |
|--------|---------------------|
| `http://IP:8080/users` | `http://IP:8080/hyechang/users` |

**효과**: 모든 URL 앞에 `/hyechang`이 자동으로 붙습니다.

---

**2. Controller 매핑 자동 조정**

```java
@GetMapping("/users")  // Controller 코드는 그대로
```

**실제 매핑되는 URL**:
```
http://localhost:8080/hyechang/users
```

**핵심**: 
- ✅ Controller 코드는 수정 불필요
- ✅ Spring이 자동으로 Context Path 인식
- ✅ `/hyechang` 부분을 제외한 `/users`로 매핑 찾기

---

**3. 타임리프 @{} 문법의 중요성**

**문제 상황**:

```html
<!-- ❌ 하드코딩 방식 -->
<a href="/users">사용자 목록</a>
```

**문제점**:
- Context Path가 `/`에서 `/hyechang`으로 변경되면?
- 모든 HTML 파일의 링크를 수동으로 수정해야 함!

---

**해결책**:

```html
<!-- ✅ 타임리프 방식 -->
<a th:href="@{/users}">사용자 목록</a>
```

**장점**:
- ✅ Context Path 자동 포함
- ✅ 설정 변경 시에도 HTML 수정 불필요
- ✅ 유지보수성 향상

---

### th:href의 @{} 문법

**@{}의 역할**:

| 항목 | 설명 |
|-----|------|
| **의미** | Context Path 자동 포함 지시자 |
| **효과** | 타임리프가 자동으로 Context Path를 URL 앞에 붙임 |

---

**동작 예시**:

| Context Path 설정 | 타임리프 코드 | 최종 URL |
|-----------------|-------------|---------|
| `/` (기본) | `@{/users}` | `/users` |
| `/hyechang` | `@{/users}` | `/hyechang/users` |
| `/api` | `@{/users}` | `/api/users` |

**핵심**: 설정만 바꾸면 모든 링크가 자동으로 올바르게 변경됩니다!

---

## 5.2.14 링크 생성 실습

### Controller 작성

```java
@GetMapping("/link")
public String getLink(Model model) {
    model.addAttribute("firstId", 0);
    model.addAttribute("secondId", 1);
    model.addAttribute("thirdId", 2);
    return "expression/link";
}

@GetMapping("/member/{id}")
public String getMemberId(Model model, @PathVariable Integer id) {
    model.addAttribute("member", customers.get(id));
    return "expression/member";
}

@GetMapping("/member")
public String getMember(Model model, 
                        @RequestParam(value = "id", required = false) Integer id) {
    if (id == null) {
        model.addAttribute("member", customers.get(0));
    } else {
        model.addAttribute("member", customers.get(id));
    }
    return "expression/member";
}
```

---

### View 템플릿 - link.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <a th:href="@{/member}">
        <span th:text="${firstId}"></span>
    </a>
    
    <a th:href="@{/member/{id}(id=${secondId})}">
        <span th:text="${secondId}"></span>
    </a>
    
    <a th:href="@{/member(id=${thirdId})}">
        <span th:text="${thirdId}"></span>
    </a>
</body>
</html>
```

---

### View 템플릿 - member.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <p th:text="${member.name}"></p>
    <p th:text="${member.email}"></p>
    <p th:text="${member.age}"></p>
</body>
</html>
```

---

### 링크 생성 방식 비교

**실행 결과 (/link 페이지)**:

```
0  1  2  (각각 클릭 가능한 링크)
```

---

### 방식 1: 단순 경로

```html
<a th:href="@{/member}"><span th:text="${firstId}"></span></a>
```

**최종 URL**:
```
http://localhost:8080/hyechang/member
```

**설명**:

| 요소 | 역할 |
|-----|------|
| `@{/member}` | Context Path 자동 포함하여 경로 생성 |
| `th:text="${firstId}"` | 링크 텍스트로 "0" 표시 |

**클릭 시 결과**:
```
홍혜창
hyechang@spring.ac.kr
10
```

---

### 방식 2: 경로 변수 (Path Variable)

```html
<a th:href="@{/member/{id}(id=${secondId})}">
    <span th:text="${secondId}"></span>
</a>
```

**최종 URL**:
```
http://localhost:8080/hyechang/member/1
```

---

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | 경로 템플릿 `{id}` 발견 |
| 2 | 소괄호 내 `id=${secondId}` 확인 |
| 3 | 이름이 일치하므로 경로에 대체 |
| 4 | `/member/1` 생성 |

**매핑 규칙**:

```
경로 템플릿: /member/{id}
매개변수: (id=1)
    ↓
URL 경로 자체에 대체: /member/1
```

**클릭 시 결과**:
```
김우현
woohyun@spring.ac.kr
10
```

---

### 방식 3: 쿼리 파라미터 (Query Parameter)

```html
<a th:href="@{/member(id=${thirdId})}">
    <span th:text="${thirdId}"></span>
</a>
```

**최종 URL**:
```
http://localhost:8080/hyechang/member?id=2
```

---

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | 경로에 `{}` 템플릿 없음 |
| 2 | 소괄호 내 `id=${thirdId}` 확인 |
| 3 | 경로 템플릿과 매칭 안 됨 |
| 4 | 자동으로 쿼리 파라미터로 전환 |
| 5 | `?id=2` 형태로 추가 |

**매핑 규칙**:

```
경로: /member (템플릿 없음)
매개변수: (id=2)
    ↓
쿼리 파라미터로 전환: /member?id=2
```

**클릭 시 결과**:
```
김구라
gura@spring.ac.kr
10
```

---

### th:href 데이터 처리 규칙 정리

**우선순위**:

```
1. 경로 템플릿 매칭 우선
   → 이름이 일치하면 경로에 대체
   
2. 나머지는 쿼리 파라미터
   → 경로에 매칭되지 않은 모든 매개변수
```

---

**종합 비교**:

| 방식 | 타임리프 코드 | 최종 URL | Controller 매핑 |
|-----|-------------|---------|---------------|
| **단순 경로** | `@{/member}` | `/member` | `@GetMapping("/member")` |
| **경로 변수** | `@{/member/{id}(id=1)}` | `/member/1` | `@GetMapping("/member/{id}")` |
| **쿼리 파라미터** | `@{/member(id=2)}` | `/member?id=2` | `@GetMapping("/member")` + `@RequestParam` |

---

### 복수 매개변수 예시

```html
<a th:href="@{/users/{id}/{name}(id=${userId}, name=${userName}, sort='asc', language='korea')}">
    링크
</a>
```

**처리 규칙**:

| 매개변수 | 경로 템플릿 매칭 | 처리 방식 |
|---------|---------------|---------|
| `id=${userId}` | `{id}` 일치 | 경로에 대체 |
| `name=${userName}` | `{name}` 일치 | 경로에 대체 |
| `sort='asc'` | 매칭 없음 | 쿼리 파라미터 |
| `language='korea'` | 매칭 없음 | 쿼리 파라미터 |

**최종 URL** (userId=42, userName='Alice' 가정):
```
/users/42/Alice?sort=asc&language=korea
```

---

## 5.2.15 핵심 정리

### 템플릿 엔진 비교

| 항목 | JSP | Thymeleaf |
|-----|-----|-----------|
| **HTML 호환성** | ❌ 비호환 | ✅ Natural Templates |
| **로컬 실행** | ❌ 불가능 | ✅ 가능 |
| **파일 위치** | `webapp/WEB-INF/views/` | `resources/templates/` |
| **확장자** | `.jsp` | `.html` |
| **추가 설정** | 수동 의존성 추가 필요 | Spring Boot 자동 설정 |
| **개발 효율** | 낮음 (서버 필수) | 높음 (서버 없이 디자인 확인) |
| **Spring Boot 권장** | ❌ 비권장 | ✅ 권장 |

---

### 타임리프 핵심 개념

**1. xmlns 선언**:
```html
<html xmlns:th="http://www.thymeleaf.org">
```
- ✅ 필수 선언
- `th:` 접두사 사용 가능하게 함

---

**2. ${} 표현식의 정확한 의미**:

| 잘못된 이해 | 올바른 이해 |
|-----------|-----------|
| Model 접근만 가능 | Model 데이터를 사용할 수 있는 **평가 공간** |
| `${name}`만 가능 | `${'이름: ' + name}` 같은 조합 가능 |
| 문자열만 반환 | 메서드 호출, 연산 등 모든 표현식 평가 가능 |

**핵심**: `${}`는 타임리프의 **표현식 평가 및 출력 지시자**입니다!

---

**3. # 기호의 두 가지 역할**:

| 사용 위치 | 역할 | 예시 |
|---------|------|------|
| `#{}` | 메시지 프로퍼티 접근 | `#{welcome}` |
| `${#객체}` | 유틸리티 객체 접근 | `${#calendars.format(...)}` |

---

### 메시지 프로퍼티 핵심

**1. 파일 이름 규칙**:
```
messages.properties      (기본 - 필수!)
messages_ko.properties   (한국어)
messages_en.properties   (영어)
```
- ⚠️ `messages` (복수형 's' 필수)

---

**2. 플레이스홀더**:
```properties
customer.contact={0} 고객님의 연락처는 {1}입니다.
```

```html
<p th:text="#{customer.contact(${name}, ${phone})}"></p>
```

**매핑 규칙**: 순서 기반 (위치가 중요)

---

**3. 동적 메시지 키**:
```html
<p th:text="#{${type}(${name}, ${phone})}"></p>
```

**평가 순서**:
1. `${type}` → "customer.contact.long"
2. `#{...}` → 메시지 파일 검색
3. `(...)` → 플레이스홀더에 값 주입

---

### 타임리프 표현식 핵심

**1. th:text vs th:utext**:

| 속성 | HTML 처리 | 사용 시기 |
|-----|----------|---------|
| `th:text` | Escape (안전) | 대부분의 경우 |
| `th:utext` | 그대로 렌더링 | 신뢰할 수 있는 데이터만 |

---

**2. 객체 접근 방식**:

```html
<!-- 일반 접근 -->
<li th:text="${customer.name}"></li>

<!-- 선택 접근 -->
<ul th:object="${customer}">
    <li th:text="*{name}"></li>
</ul>
```

**`*{}`의 의미**: 가장 가까운 상위 `th:object`의 속성 접근

---

**3. 유틸리티 객체 사용 시 주의**:

```html
<!-- ✅ 올바름 -->
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}"></p>

<!-- ❌ 이중 $ 금지 -->
<p th:text="${#calendars.format(${date}, 'yyyy-MM-dd')}"></p>
```

**이유**: 이미 `${}` 평가 공간 안에 있음

---

### 조건문과 반복문

**1. th:if / th:unless**:

```html
<p th:if="${isStudent}">학생입니다</p>
<p th:unless="${isStudent}">학생이 아닙니다</p>
```

**효과**: 조건이 맞지 않으면 HTML에서 완전히 제거

---

**2. th:each + iteration**:

```html
<tr th:each="item, iteration : ${items}">
    <td th:text="${iteration.index}"></td>
    <td th:text="${iteration.count}"></td>
    <td th:text="${item.name}"></td>
</tr>
```

**iteration 주요 속성**:
- `index`: 0부터 시작
- `count`: 1부터 시작
- `even/odd`: 짝수/홀수 판별
- `first/last`: 첫/마지막 판별

---

**3. th:block**:

```html
<th:block th:each="item : ${items}">
    <h3 th:text="${item.title}"></h3>
    <p th:text="${item.description}"></p>
</th:block>
```

**효과**: 불필요한 래퍼 태그 없이 여러 요소를 함께 제어

---

### 링크 생성 핵심

**1. @{} 문법의 중요성**:

```html
<!-- ✅ 권장 -->
<a th:href="@{/users}">목록</a>

<!-- ❌ 비권장 -->
<a href="/users">목록</a>
```

**장점**: Context Path 자동 포함으로 유지보수성 향상

---

**2. 링크 생성 패턴**:

| 패턴 | 코드 | 결과 URL |
|-----|------|---------|
| **단순 경로** | `@{/users}` | `/users` |
| **경로 변수** | `@{/users/{id}(id=1)}` | `/users/1` |
| **쿼리 파라미터** | `@{/users(id=1)}` | `/users?id=1` |
| **복합** | `@{/users/{id}(id=1, sort='asc')}` | `/users/1?sort=asc` |

**매핑 규칙**: 
1. 경로 템플릿 `{}` 우선 매칭
2. 나머지는 쿼리 파라미터

---

### Context Path 이해

**WAR 배포**:
- 하나의 Tomcat (8080 포트)
- 여러 애플리케이션 → Context Path로 구분
- 예: `/app1/users`, `/app2/users`

**JAR 배포**:
- 각 JAR이 독립 프로세스
- 다른 포트 사용 → 포트로 구분
- 예: `8080/users`, `8081/users`

**Nginx 사용 시**:
- 80번 포트로 통일
- 경로로 내부 포트 매핑
- 예: `/hyechang/users` → `localhost:8080/users`

---

### 개발 팁

**1. IntelliJ 템플릿 설정**:
- `Ctrl + Alt + S` → `File and Code Templates`
- Thymeleaf 기본 구조 자동 생성

---

**2. 메시지 프로퍼티 디버깅**:
```java
@GetMapping("/language")
public String getLanguage(HttpServletRequest request) {
    String acceptLanguage = request.getHeader("Accept-Language");
    log.info("Accept-Language: {}", acceptLanguage);
    return "basic/language-basic";
}
```

---

**3. th:object 실무 활용**:
- 폼 바인딩과 함께 사용
- 유효성 검증 자동 연동
- Spring MVC 표준 패턴

---

### 자주 하는 실수

**1. messages.properties 파일명**:
- ❌ `message.properties`
- ✅ `messages.properties` (복수형!)

---

**2. ${} 이중 사용**:
```html
<!-- ❌ 잘못됨 -->
${#calendars.format(${date}, ...)}

<!-- ✅ 올바름 -->
${#calendars.format(date, ...)}
```

---

**3. th:text에서 문자열 조합 시 따옴표**:
```html
<!-- ❌ 잘못됨 -->
th:text="${이름: + name}"

<!-- ✅ 올바름 -->
th:text="${'이름: ' + name}"
```

---

**4. Context Path 하드코딩**:
```html
<!-- ❌ 비권장 -->
<a href="/users">목록</a>

<!-- ✅ 권장 -->
<a th:href="@{/users}">목록</a>
```

---

### 타임리프의 장점 요약

| 장점 | 설명 |
|-----|------|
| **HTML 호환** | 서버 없이 디자인 확인 가능 |
| **프론트-백엔드 분리** | 동일 파일로 독립 개발 가능 |
| **Spring 통합** | 자동 설정 및 표준 지원 |
| **유지보수성** | Context Path 자동 처리 |
| **안전성** | 기본 Escape 처리 (XSS 방지) |

---

**결론**: 타임리프는 HTML 표준을 유지하면서 강력한 동적 기능을 제공하는 현대적인 템플릿 엔진입니다. Spring Boot 환경에서 SSR 방식의 웹 애플리케이션을 개발할 때 가장 권장되는 선택입니다!


---
## 5.2.16 타임리프 레이아웃 관리

### 레이아웃 관리의 필요성

**상용 웹 서비스의 특징**:

상용으로 서비스되는 웹사이트를 살펴보면 모든 페이지가 동일한 레이아웃 구조를 가지고 있고, **콘텐츠 영역만 바뀌는** 것을 확인할 수 있습니다.

**문제점**:
- 매 페이지마다 헤더, 푸터, 네비게이션 등을 반복 작성
- 공통 영역 수정 시 모든 페이지를 수정해야 함
- 코드 중복으로 인한 유지보수 어려움

**해결책**:
타임리프는 공통으로 사용되는 영역을 **프래그먼트(Fragment)**로 지정하고, 이를 필요로 하는 페이지에 간단히 포함시킬 수 있는 방법을 제공합니다.

---

### 프래그먼트를 통한 레이아웃 관리 방법

타임리프의 프래그먼트를 활용한 레이아웃 관리는 크게 **두 가지 방식**으로 나뉩니다.

---

### 방법 1: 공통 요소 재사용 방식

**개념**: 공통 요소들(헤더, 푸터 등)을 프래그먼트로 선언하고, 필요한 곳에서 가져다 쓰는 방식

**특징**:

| 항목 | 설명 |
|-----|------|
| **대체 범위** | 일부 영역(헤더, 푸터 등) |
| **페이지 구조** | 각 페이지가 완전한 HTML 구조 보유 |
| **프래그먼트 역할** | 코드 조각 제공 |
| **사용 빈도** | 가장 기본적이고 직관적 |

---

### 방법 2: 전체 레이아웃 템플릿 방식

**개념**: 전체 레이아웃을 포함한 HTML을 프래그먼트로 만들고, 각 웹페이지에서 **HTML 전체를 교체**하되, 해당 페이지의 고유한 영역만 매개변수로 전달하는 방식

**특징**:

| 항목 | 설명 |
|-----|------|
| **대체 범위** | HTML 전체 |
| **페이지 구조** | 페이지는 콘텐츠만 정의 |
| **프래그먼트 역할** | Base Layout 제공 |
| **사용 빈도** | 실무에서 선호되는 고급 패턴 |

---

## 5.2.17 프래그먼트 구현 (방법 1: 공통 요소 재사용)

### 프래그먼트 파일 작성

**파일 위치**: `src/main/resources/templates/fragment/common.html`

---

### 프래그먼트 파일의 구성 원칙

**중요**: 프래그먼트 파일은 **완전한 HTML 문서가 아닌**, 재사용 가능한 **코드 블록**으로 만들어야 합니다.

---

### 제거해야 할 요소 ❌

다음 요소들은 프래그먼트 파일에 포함하지 **않아야** 합니다:

```html
<!-- ❌ 프래그먼트 파일에 포함하지 말 것 -->
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>...</title>
</head>
<body>
    ...
</body>
</html>
```

**이유**:

| 이유 | 설명 |
|-----|------|
| **중복 방지** | 호출하는 파일에 이미 이 태그들이 존재 |
| **문법 오류** | HTML 문서에 `<html>`, `<head>` 태그가 중복되면 오류 발생 |
| **렌더링 문제** | 브라우저가 비정상적으로 해석할 수 있음 |

---

### 정의해야 할 요소 ✅

**기본 프래그먼트 정의**:

```html
<!-- fragment/common.html -->
<div th:fragment="header">
    <p style="background-color: black; color: white; padding: 12px;">
        홍혜창 스프링 | 강의 | 책 | 대관 | 이벤트 | 자료실
    </p>
</div>

<div th:fragment="footer">
    <p style="background-color: black; color: white; padding: 12px;">
        Copyright hyechang
    </p>
</div>
```

---

### 프래그먼트 정의 문법

**th:fragment 속성**:

```
th:fragment="프래그먼트이름"
```

| 항목 | 설명 |
|-----|------|
| **속성** | `th:fragment` |
| **값** | 고유한 프래그먼트 이름 (식별자) |
| **적용 대상** | 재사용할 HTML 요소 (div, header, footer 등) |

---

### 매개변수를 받는 프래그먼트

**동적 프래그먼트 정의**:

```html
<!-- fragment/common.html -->
<div th:fragment="header(a, b, c, d, e, f)">
    <p style="background-color: black; color: white; padding: 12px;">
        <span th:text="${a}"></span> | 
        <span th:text="${b}"></span> | 
        <span th:text="${c}"></span> | 
        <span th:text="${d}"></span> | 
        <span th:text="${e}"></span> | 
        <span th:text="${f}"></span>
    </p>
</div>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **문법** | `th:fragment="이름(매개변수1, 매개변수2, ...)"` |
| **매개변수** | 호출 시 전달받을 변수 선언 |
| **사용 목적** | 동일한 구조, 다른 내용 표시 |
| **비유** | 함수처럼 동작 |

---

### 프래그먼트 호출

**파일 위치**: `src/main/resources/templates/fragment/fragment-common.html`

---

### 기본 호출 방식

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>
</head>
<body>
    <div th:replace="~{fragment/common::header}"></div>
    
    <p class="round-shadow-box">
        spring boot 공부 열심히 하자!
    </p>
    
    <div th:replace="~{fragment/common::footer}"></div>
</body>
</html>
```

**실행 결과**:
```
홍혜창 스프링 | 강의 | 책 | 대관 | 이벤트 | 자료실

spring boot 공부 열심히 하자!

Copyright hyechang
```

---

### th:replace 문법 분석

**기본 문법**:

```
th:replace="~{파일경로::프래그먼트이름}"
```

**구성 요소**:

| 요소 | 설명 | 예시 |
|-----|------|------|
| **~{}** | 템플릿 링크 표현식 | 필수 |
| **파일경로** | `templates/` 기준 경로 | `fragment/common` |
| **::** | 구분자 | 파일과 프래그먼트 구분 |
| **프래그먼트이름** | 대체할 프래그먼트 | `header` |

---

### th:replace의 정확한 의미

**핵심 이해**: `th:replace`는 단순히 "`~{파일경로::프래그먼트이름}`" 형태만 사용하는 것이 아닙니다!

**올바른 이해**:

```
th:replace = "프래그먼트로 대체하겠다"
```

**의미 분석**:

| 항목 | 설명 |
|-----|------|
| **replace** | 현재 태그를 **대체(교체)** |
| **대상** | 뒤에 오는 **프래그먼트** |
| **형태** | 프래그먼트를 가져오는 방법은 다양 |

---

### 다양한 th:replace 사용 형태

**1. 파일에서 가져오기**:

```html
<div th:replace="~{fragment/common::header}"></div>
```

**2. 변수에서 가져오기**:

```html
<div th:replace="${contentFragment}"></div>
```

**3. 현재 파일에서 가져오기**:

```html
<div th:replace="~{::localFragment}"></div>
```

**핵심**: `th:replace` 뒤에는 항상 **프래그먼트**가 오며, 그것으로 현재 태그를 대체한다는 의미입니다!

---

### th:replace 작동 원리

**처리 과정**:

```
1. 호출 태그 발견
   <div th:replace="~{fragment/common::header}"></div>
    ↓
2. 프래그먼트 파일 탐색
   templates/fragment/common.html 열기
    ↓
3. 프래그먼트 찾기
   th:fragment="header" 검색
    ↓
4. 태그 대체
   호출 <div>를 프래그먼트 내용으로 완전히 교체
    ↓
5. 최종 HTML
   <p style="...">홍혜창 스프링 | ...</p>
```

**결과 비교**:

| 단계 | 코드 |
|-----|------|
| **대체 전** | `<div th:replace="..."></div>` |
| **대체 후** | `<p style="...">홍혜창 스프링...</p>` |

**핵심**: 호출 태그인 `<div>`는 사라지고, 프래그먼트의 루트 태그인 `<p>`가 그 자리를 차지합니다!

---

### 매개변수를 전달하는 호출

```html
<div th:replace="~{fragment/common::header('목차1', '목차2', '목차3', '내용1', '내용2', '내용3')}"></div>
```

**실행 결과**:
```
목차1 | 목차2 | 목차3 | 내용1 | 내용2 | 내용3
```

---

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | 프래그먼트 호출 시 6개의 값 전달 |
| 2 | 프래그먼트 정의의 매개변수 `(a, b, c, d, e, f)`에 순서대로 매핑 |
| 3 | `${a}` → '목차1', `${b}` → '목차2', ... |
| 4 | 최종 HTML 생성 |

**비유**: 함수를 호출하듯이 프래그먼트를 호출하는 방식입니다!

---

### CSS 링크와 프래그먼트의 차이

**중요한 구분**: `th:replace`와 `th:href`는 왜 `@{}`를 다르게 사용할까?

---

### th:href의 경우 (CSS/JS 링크)

```html
<link th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **성격** | 외부 HTTP 요청 |
| **@{} 사용** | ✅ 필수 |
| **이유** | Context Path 자동 포함 필요 |
| **최종 URL** | `/hyechang/css/round-shadow-box.css` |

**작동 방식**:

```
1. 브라우저가 CSS 파일 요청
    ↓
2. HTTP 프로토콜 사용
    ↓
3. URL 경로 필요
    ↓
4. Context Path 포함해야 함
    ↓
5. @{}로 자동 처리
```

---

### th:replace의 경우 (프래그먼트)

```html
<div th:replace="~{fragment/common::header}"></div>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **성격** | 서버 내부 파일 접근 |
| **@{} 사용** | ❌ 불필요 |
| **이유** | HTTP 요청이 아님 |
| **경로 기준** | `templates/` 폴더 |

**작동 방식**:

```
1. 타임리프 엔진이 처리
    ↓
2. 서버 파일 시스템 접근
    ↓
3. templates/ 폴더 기준 탐색
    ↓
4. 메모리 내에서 HTML 조립
    ↓
5. HTTP 요청 관련 없음
```

---

### 핵심 비교

| 구분 | th:href (링크) | th:replace (프래그먼트) |
|-----|--------------|----------------------|
| **목적** | 외부 리소스 요청 URL 생성 | 서버 내부 파일 참조 |
| **처리 시점** | 클라이언트 (브라우저) | 서버 (타임리프 엔진) |
| **프로토콜** | HTTP | 파일 시스템 |
| **@{} 필요** | ✅ 필수 | ❌ 불필요 |
| **Context Path** | 포함 필요 | 무관 |
| **경로 기준** | Context Path + `/static/` | `/templates/` |

**핵심**: 
- `th:href`는 **클라이언트의 인터넷 요청 경로**를 만드는 작업 → `@{}` 필수
- `th:replace`는 **서버의 내부 파일 시스템**에서 파일을 찾는 작업 → `@{}` 불필요

---

### Controller 작성

```java
@Controller
public class BasicController {
    
    @GetMapping("/fragment")
    public String getFragment() {
        return "fragment/fragment-common";
    }
}
```

---

### CSS 접근 경로의 원리

**static 폴더의 역할**:

**파일 위치**: `src/main/resources/static/css/round-shadow-box.css`

**URL 매핑**:

| 구성 요소 | 값 | 설명 |
|---------|-----|------|
| **Context Path** | `/hyechang` | 애플리케이션 식별자 |
| **static 폴더** | (생략) | Spring Boot가 자동으로 루트로 매핑 |
| **실제 경로** | `/css/round-shadow-box.css` | static 내부 경로 |
| **최종 URL** | `/hyechang/css/round-shadow-box.css` | 클라이언트 요청 경로 |

**핵심**: 
- `resources/static` 경로는 URL에 노출되지 않음
- Context Path 바로 뒤에 static 내부 경로가 붙음

---

### 프래그먼트 사용의 장점 (방법 1)

| 장점 | 설명 |
|-----|------|
| **코드 중복 제거** | 헤더, 푸터를 한 곳에서 관리 |
| **유지보수 용이** | 공통 영역 수정 시 한 파일만 변경 |
| **일관성 유지** | 모든 페이지가 동일한 헤더/푸터 사용 |
| **개발 속도 향상** | 새 페이지 추가 시 프래그먼트만 호출 |

---

## 5.2.18 프래그먼트 구현 (방법 2: 전체 레이아웃 템플릿)

### Base Layout 패턴이란?

**개념**: 전체 페이지 구조를 포함한 레이아웃을 프래그먼트로 정의하고, 개별 페이지는 **콘텐츠만 정의**하여 전달하는 방식

**핵심 원리**:
- 레이아웃 = 큰 틀 (뼈대)
- 개별 페이지 = 내용물
- 조립 = 매개변수 전달

---

### Base Layout 파일 작성

**파일 위치**: `src/main/resources/templates/fragment/allcommon.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      th:fragment="allfragment(title, links, content, menu)">
<head>
    <meta charset="UTF-8">
    <title th:text="${title}">Title</title>
    <link th:replace="${links}"/>
</head>
<body>
    <p style="background-color: black; color: white; padding: 12px;">
        홍혜창 스프링 | 강의 | 책 | 
        <span th:text="${menu}"></span> | 
        이벤트 | 자료실
    </p>
    
    <th:block th:replace="${content}"></th:block>
</body>
</html>
```

---

### Base Layout 구조 분석

**1. 최상위 태그에 프래그먼트 선언**:

```html
<html ... th:fragment="allfragment(title, links, content, menu)">
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **선언 위치** | `<html>` 태그 |
| **의미** | HTML 전체가 프래그먼트 |
| **매개변수** | 4개 (title, links, content, menu) |

---

**2. 매개변수 역할**:

| 매개변수 | 타입 | 사용 위치 | 역할 |
|---------|------|---------|------|
| **title** | String | `<title>` 태그 | 페이지 제목 |
| **links** | Fragment | `<head>` 내부 | CSS/JS 링크 |
| **content** | Fragment | `<body>` 내부 | 메인 콘텐츠 |
| **menu** | String | 헤더 영역 | 메뉴 항목 |

---

**3. 프래그먼트 삽입 구문**:

```html
<link th:replace="${links}"/>
```

**작동 원리**:

| 구문 | 의미 |
|-----|------|
| `th:replace="${links}"` | 매개변수로 받은 프래그먼트를 현재 위치에 삽입 |
| `${links}` | 변수에 저장된 프래그먼트 객체 |

**핵심**: `th:replace`는 `~{파일::이름}` 형태만 사용하는 것이 아니라, **변수에 저장된 프래그먼트**도 사용할 수 있습니다!

---

### 개별 페이지 작성

**파일 위치**: `src/main/resources/templates/fragment/fragment-allcommon.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      th:replace="~{fragment/allcommon::allfragment('스프링부트', ~{::link}, ~{::section}, '뉴메뉴')}">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link th:fragment="link" th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>
</head>
<body>
    <section th:fragment="section">
        프래그먼트 어렵다.. ㅠㅠ
    </section>
</body>
</html>
```

**실행 결과**:
```
홍혜창 스프링 | 강의 | 책 | 뉴메뉴 | 이벤트 | 자료실

프래그먼트 어렵다.. ㅠㅠ
```

---

### 개별 페이지 구조 분석

**1. 최상위 태그에서 전체 대체**:

```html
<html ... th:replace="~{fragment/allcommon::allfragment(...)}">
```

**의미**:

| 항목 | 설명 |
|-----|------|
| **위치** | `<html>` 태그 |
| **동작** | 현재 HTML 전체를 Base Layout으로 대체 |
| **효과** | 이 파일의 HTML 구조는 최종 결과에서 사라짐 |

---

**2. 매개변수 전달**:

```html
allfragment('스프링부트', ~{::link}, ~{::section}, '뉴메뉴')
```

**매개변수 분석**:

| 순서 | 전달 값 | 타입 | Base Layout 매개변수 |
|-----|--------|------|-------------------|
| 1 | `'스프링부트'` | String | `title` |
| 2 | `~{::link}` | Fragment | `links` |
| 3 | `~{::section}` | Fragment | `content` |
| 4 | `'뉴메뉴'` | String | `menu` |

---

**3. ~{::태그명}의 의미**:

```html
~{::link}
~{::section}
```

**구문 분석**:

| 구성 요소 | 의미 |
|---------|------|
| **~{}** | 프래그먼트 참조 표현식 |
| **::** | 구분자 (파일 생략 시 현재 파일) |
| **태그명** | 찾을 프래그먼트 또는 태그 |

**작동 원리**:

```
~{::link} 실행 시:
1. 현재 파일에서 th:fragment="link" 또는 <link> 태그 탐색
2. 해당 태그와 내용을 프래그먼트 객체로 변환
3. 매개변수로 전달
```

---

**4. 콘텐츠 프래그먼트 정의**:

```html
<link th:fragment="link" th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>

<section th:fragment="section">
    프래그먼트 어렵다.. ㅠㅠ
</section>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **th:fragment** | 명시적으로 프래그먼트 이름 지정 |
| **목적** | 이 코드 블록을 Base Layout에 전달 |
| **최종 HTML** | 이 내용이 Base Layout의 해당 위치에 삽입됨 |

---

### Base Layout 패턴 작동 흐름

**전체 처리 과정**:

```
1. Controller
   return "fragment/fragment-allcommon"
    ↓
2. ViewResolver
   fragment-allcommon.html 열기
    ↓
3. 전체 대체 명령 발견
   <html th:replace="~{fragment/allcommon::allfragment(...)}">
    ↓
4. 현재 파일에서 프래그먼트 추출
   ~{::link} → <link> 태그 추출
   ~{::section} → <section> 태그 추출
    ↓
5. Base Layout 호출
   fragment/allcommon.html의 allfragment 실행
    ↓
6. 매개변수 주입
   title = '스프링부트'
   links = <link> 프래그먼트
   content = <section> 프래그먼트
   menu = '뉴메뉴'
    ↓
7. Base Layout에서 조립
   <title th:text="${title}"> → <title>스프링부트</title>
   <link th:replace="${links}"/> → <link th:href="..."/>
   <span th:text="${menu}"> → <span>뉴메뉴</span>
   <th:block th:replace="${content}"> → <section>...</section>
    ↓
8. 최종 HTML 생성
   완성된 HTML을 클라이언트에게 전달
```

---

### Controller 작성

```java
@Controller
public class BasicController {
    
    @GetMapping("/allfragment")
    public String getAllFragment() {
        return "fragment/fragment-allcommon";
    }
}
```

---

### 핵심 개념: View의 역할 변화

**전통적인 방식**:

```
Controller → View (완전한 HTML 파일) → 클라이언트
```

**Base Layout 방식**:

```
Controller → View (콘텐츠만 정의)
                ↓
            Base Layout (전체 구조)
                ↓
            최종 HTML → 클라이언트
```

**핵심 차이**:

| 항목 | 전통적 방식 | Base Layout 방식 |
|-----|-----------|----------------|
| **View 역할** | 완성된 HTML 생성 | 콘텐츠만 제공 |
| **HTML 구조** | 각 페이지에 포함 | Base Layout에만 존재 |
| **프래그먼트 사용** | 일부 영역 대체 | HTML 전체 대체 |
| **유지보수** | 각 파일 수정 필요 | Base Layout만 수정 |

---

### 프래그먼트 참조 시 주의사항

#### 문제점: 태그 이름 참조의 모호성

**문제 상황**:

```html
<section>첫 번째 섹션</section>
<section>두 번째 섹션</section>

<!-- ❌ 어떤 section을 참조? -->
<div th:replace="~{::section}"></div>
```

**오류 발생**:
- 동일한 태그가 여러 개 있으면 모호성 발생
- `TemplateProcessingException` 오류
- 렌더링 실패

---

#### 해결책: th:fragment로 고유 이름 지정 (권장)

**안전한 방식**:

```html
<!-- ✅ 프래그먼트 정의 -->
<link th:fragment="pageCss" th:href="@{/css/style.css}"/>
<section th:fragment="mainContent">메인 콘텐츠</section>

<!-- ✅ 명확한 참조 -->
<div th:replace="~{::pageCss}"></div>
<div th:replace="~{::mainContent}"></div>
```

**장점**:

| 장점 | 설명 |
|-----|------|
| **명확성** | 고유한 이름으로 정확히 식별 |
| **유지보수** | 태그 종류 변경 시에도 참조 코드 수정 불필요 |
| **가독성** | 코드의 목적이 명확함 |
| **안전성** | 모호성 오류 방지 |

---

### Base Layout 패턴의 장점

#### 1. 구조적 일관성

| 항목 | 설명 |
|-----|------|
| **레이아웃 통일** | 모든 페이지가 동일한구조 보장 |
| **디자인 일관성** | 헤더, 푸터가 항상 동일하게 표시 |
| **표준화** | 웹사이트 전체의 UI/UX 통일 |

---

#### 2. 유지보수 효율성

**변경 사항 발생 시**:

| 구분 | 방법 1 (부분 대체) | 방법 2 (Base Layout) |
|-----|-----------------|-------------------|
| **헤더 수정** | 모든 페이지 수정 필요 | allcommon.html 한 곳만 수정 |
| **레이아웃 변경** | 각 페이지 구조 수정 | Base Layout만 수정 |
| **CSS 추가** | 모든 페이지에 링크 추가 | Base Layout에 한 번만 추가 |

**효과**: 수백 개의 페이지가 있어도 한 파일만 수정하면 전체 반영!

---

#### 3. 개발 속도 향상

**새 페이지 추가 시**:

```html
<!-- 필요한 작업: 콘텐츠만 작성 -->
<html th:replace="~{fragment/allcommon::allfragment('제목', ~{::link}, ~{::section}, '메뉴')}">
<head>
    <link th:fragment="link" th:href="@{/css/new-page.css}"/>
</head>
<body>
    <section th:fragment="section">
        <!-- 이 페이지만의 콘텐츠 작성 -->
        새로운 페이지 내용
    </section>
</body>
</html>
```

**장점**:

| 항목 | 설명 |
|-----|------|
| **간단한 구조** | `<html>`, `<head>`, `<body>`의 복잡한 설정 불필요 |
| **빠른 개발** | 콘텐츠에만 집중 가능 |
| **실수 방지** | 레이아웃 구조를 잘못 작성할 위험 없음 |

---

#### 4. 프로젝트 구조 개선

**디렉토리 구조**:

```
templates/
├── fragment/
│   └── allcommon.html          (Base Layout - 1개)
├── home.html                    (콘텐츠만)
├── about.html                   (콘텐츠만)
├── products/
│   ├── list.html                (콘텐츠만)
│   └── detail.html              (콘텐츠만)
└── admin/
    ├── dashboard.html           (콘텐츠만)
    └── users.html               (콘텐츠만)
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **명확한 분리** | 레이아웃과 콘텐츠의 역할 분리 |
| **파일 크기** | 각 페이지 파일이 간결해짐 |
| **관리 용이** | 구조를 한눈에 파악 가능 |

---

### 방법 1 vs 방법 2 비교

**최종 비교표**:

| 구분 | 방법 1 (부분 대체) | 방법 2 (Base Layout) |
|-----|-----------------|-------------------|
| **대체 범위** | 일부 영역 (헤더, 푸터) | HTML 전체 |
| **페이지 구조** | 완전한 HTML 포함 | 콘텐츠만 정의 |
| **유지보수** | 공통 영역만 중앙 관리 | 전체 구조 중앙 관리 |
| **개발 속도** | 보통 | 빠름 |
| **복잡도** | 낮음 (직관적) | 높음 (고급) |
| **사용 시점** | 간단한 공통 요소 재사용 | 대규모 프로젝트, 일관된 레이아웃 필요 |
| **실무 선호도** | 기본적인 사용 | 실무에서 더 선호 |

---

### 실무 사용 패턴

#### 방법 1 사용 케이스

**적합한 상황**:

| 상황 | 설명 |
|-----|------|
| **부분 공통화** | 헤더, 푸터만 공통으로 사용 |
| **간단한 프로젝트** | 페이지 수가 적음 |
| **빠른 프로토타입** | 개념 검증용 개발 |
| **학습 단계** | 프래그먼트 개념 학습 |

---

#### 방법 2 사용 케이스

**적합한 상황**:

| 상황 | 설명 |
|-----|------|
| **대규모 프로젝트** | 수십~수백 개의 페이지 |
| **일관된 레이아웃** | 전체 사이트의 구조 통일 필수 |
| **관리자 페이지** | 동일한 사이드바, 헤더 구조 |
| **실무 프로젝트** | 유지보수성이 중요한 경우 |

---

### 프래그먼트 패턴의 현대적 의미

**타임리프 프래그먼트의 개념은 현대 프론트엔드 프레임워크와 유사합니다**:

| 프레임워크 | 유사 개념 | 설명 |
|-----------|---------|------|
| **React** | Component | 재사용 가능한 UI 조각 |
| **Vue** | Component + Slot | 컴포넌트와 슬롯 시스템 |
| **Angular** | Component | 컴포넌트 기반 구조 |
| **Thymeleaf** | Fragment | 재사용 가능한 HTML 조각 |

**핵심**: Base Layout 패턴은 React의 `children` props나 Vue의 `<slot>`과 동일한 개념입니다!

---

### 실무 개발 워크플로우

**Base Layout 방식 개발 순서**:

```
1단계: Base Layout 설계
    ↓
fragment/allcommon.html 작성
- 전체 구조 정의
- 매개변수 선언 (title, links, content)
    ↓
2단계: 개별 페이지 개발
    ↓
각 페이지에서:
- 콘텐츠만 작성 (<section th:fragment="section">)
- 필요한 CSS만 정의 (<link th:fragment="link">)
- Base Layout 호출
    ↓
3단계: 유지보수
    ↓
레이아웃 변경 시:
- allcommon.html만 수정
- 모든 페이지에 자동 반영
```

---

### 프래그먼트 사용 모범 사례

#### 1. 명확한 네이밍

```html
<!-- ✅ 좋은 예 -->
<header th:fragment="mainHeader">...</header>
<nav th:fragment="sideNavigation">...</nav>
<footer th:fragment="mainFooter">...</footer>

<!-- ❌ 나쁜 예 -->
<div th:fragment="div1">...</div>
<div th:fragment="d2">...</div>
```

---

#### 2. 프래그먼트 파일 분리

**권장 구조**:

```
templates/fragment/
├── allcommon.html      (Base Layout)
├── common.html         (헤더, 푸터)
├── navigation.html     (네비게이션)
└── forms.html          (폼 요소들)
```

---

#### 3. 매개변수 문서화

```html
<!--
Base Layout Fragment: allfragment
매개변수:
- title (String): 페이지 제목
- links (Fragment): CSS/JS 링크
- content (Fragment): 메인 콘텐츠
- menu (String): 활성 메뉴 이름
-->
<html th:fragment="allfragment(title, links, content, menu)">
```

---

### 핵심 정리

**프래그먼트의 본질**:

| 개념 | 설명 |
|-----|------|
| **코드 재사용** | 중복 제거 |
| **관심사 분리** | 레이아웃과 콘텐츠 분리 |
| **유지보수성** | 중앙 집중식 관리 |
| **개발 효율** | 빠른 페이지 추가 |

---

**th:replace의 핵심**:

```
th:replace = "프래그먼트로 대체"
```

**다양한 형태**:
- `~{파일::이름}` : 파일에서 가져오기
- `${변수}` : 변수에서 가져오기
- `~{::이름}` : 현재 파일에서 가져오기

**공통점**: 모두 **프래그먼트**를 대상으로 함!

---

**@{} 사용 구분**:

| 속성 | @{} 사용 | 이유 |
|-----|---------|------|
| `th:href` | ✅ 필수 | HTTP 요청 URL 생성 |
| `th:src` | ✅ 필수 | 외부 리소스 경로 |
| `th:replace` | ❌ 불필요 | 서버 내부 파일 접근 |

---

**레이아웃 관리 권장사항**:

| 프로젝트 규모 | 권장 방법 |
|------------|---------|
| **소규모** | 방법 1 (부분 대체) |
| **중규모** | 방법 1 + 방법 2 혼용 |
| **대규모** | 방법 2 (Base Layout) |

---

**결론**: 

타임리프의 프래그먼트 시스템은 효율적인 레이아웃 관리를 위한 강력한 도구입니다. 

특히 **Base Layout 패턴(방법 2)**은 대규모 웹 애플리케이션에서 구조적 일관성과 유지보수성을 극대화하는 현대적인 접근 방식으로, 실무에서 널리 사용되는 표준 패턴입니다.

프래그먼트를 이해하고 활용하면, JSP의 `<jsp:include>`나 현대 프론트엔드 프레임워크의 컴포넌트 시스템과 유사한 수준의 모듈화된 개발이 가능하며, 이는 Spring Boot 기반 SSR 웹 애플리케이션 개발의 핵심 기술입니다.



---


# 5.3 스프링 시큐리티

## 📌 학습 목표
스프링 시큐리티를 활용한 인증(Authentication) 시스템의 작동 원리를 이해하고, 실무에서 사용 가능한 다양한 사용자 인증 방식을 학습한다. 메모리 기반, JDBC 기반, 커스텀 구현 등 세 가지 방식을 통해 스프링 시큐리티의 핵심 개념인 UserDetailsService와 UserDetails를 체계적으로 익힌다.

---

## 5.3.1 스프링 시큐리티란?

### 스프링 시큐리티의 필요성

현대의 대부분 웹 서비스는 다음과 같은 보안 기능을 필수적으로 제공합니다:

| 기능 | 설명 |
|-----|------|
| **로그인 기능** | 사용자 식별 및 인증 |
| **화면 제어** | 로그인 여부에 따른 다른 화면 표시 |
| **권한 관리** | 사용자 권한에 따른 기능 접근 제어 |

**스프링 시큐리티(Spring Security)**는 이러한 보안 기능을 체계적으로 구현할 수 있도록 지원하는 프레임워크입니다.

---

### 인증과 인가

스프링 시큐리티의 두 가지 핵심 개념:

| 개념 | 영문 | 의미 | 예시 |
|-----|------|------|------|
| **인증** | Authentication | "당신은 누구인가?" | 로그인 (ID/비밀번호 확인) |
| **인가** | Authorization | "당신은 무엇을 할 수 있는가?" | 관리자만 특정 페이지 접근 가능 |


---

### 프로젝트 의존성 설정

**build.gradle**:

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6'
    implementation 'org.springframework.session:spring-session-jdbc'

    compileOnly 'org.projectlombok:lombok'
    runtimeOnly 'com.h2database:h2'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testImplementation 'org.springframework.security:spring-security-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}
```

**핵심 의존성**:

| 의존성 | 역할 |
|-------|------|
| **spring-boot-starter-security** | 스프링 시큐리티 핵심 기능 |
| **spring-boot-starter-data-jpa** | 데이터베이스 연동 (JPA) |
| **h2** | 내장 데이터베이스 (개발/테스트용) |
| **spring-session-jdbc** | 세션 정보 DB 저장 (세션 공유) |
| **thymeleaf-extras-springsecurity6** | 타임리프에서 시큐리티 기능 사용 |

---

## 5.3.2 스프링 시큐리티의 기본 동작

### 기본 예제 준비

**Member.java** (DTO):

```java
package com.example.springscuritySample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Member {
    private Long id;
    private String name;
    private String email;
}
```

---

**MemberController.java**:

```java
package com.example.springscuritySample.controller;

import com.example.springscuritySample.model.Member;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

import java.util.List;

@Controller
@Slf4j
public class MemberController {

    private List<Member> members = List.of(
            new Member(1L, "홍혜창", "hyechang@spring.ac.kr"),
            new Member(2L, "김우현", "woo@spring.ac.kr"),
            new Member(3L, "홍길동", "hong@spring.ac.kr"),
            new Member(4L, "김구라", "gura@spring.ac.kr")
    );

    @GetMapping("/member/list")
    public String memberList(Model model) {
        model.addAttribute("members", members);
        return "member-list";
    }
}
```

---

**member-list.html**:

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>회원 목록</title>
</head>
<body>
    <table>
        <thead>
            <tr>
                <td>#</td>
                <td>회원명</td>
                <td>이메일</td>
            </tr>
        </thead>
        <tbody>
            <tr th:each="member : ${members}">
                <td th:text="${member.id}"></td>
                <td th:text="${member.name}"></td>
                <td th:text="${member.email}"></td>
            </tr>
        </tbody>
    </table>
</body>
</html>
```

---

### 스프링 시큐리티 자동 활성화

**중요한 발견**: `spring-boot-starter-security` 의존성을 추가한 순간, 애플리케이션의 동작이 완전히 바뀝니다!

---

### 애플리케이션 실행 시 변화

**1. 콘솔에 임시 비밀번호 생성**:

```
Using generated security password: d1e25e2d-3b51-4d3f-9d17-923d240afdb1
```

**의미**:

| 항목 | 값 | 설명 |
|-----|-----|------|
| **아이디** | `user` (고정) | 스프링 시큐리티 기본 계정 |
| **비밀번호** | 랜덤 생성 | 서버 재시작마다 변경됨 |
| **용도** | 개발/테스트 | 임시 보안 계정 |

---

**2. 모든 페이지 접근 차단**:

```
요청: http://localhost:8080/member/list
    ↓
자동 리다이렉트
    ↓
결과: http://localhost:8080/login
```

**스프링 시큐리티의 기본 정책**:

| 정책 | 내용 |
|-----|------|
| **보호 범위** | 모든 URL (`/**`) |
| **접근 조건** | 반드시 인증 필요 |
| **미인증 시** | 자동으로 `/login` 페이지로 리다이렉트 |

---

**3. 자동 생성된 로그인 페이지**:

```html
Please sign in
Username: [입력란]
Password: [입력란]
Sign in
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **자동 생성** | 스프링 시큐리티가 기본 로그인 폼 제공 |
| **커스터마이징 가능** | 필요 시 직접 로그인 페이지 제작 가능 |

---

### 로그인 성공 후 흐름

**정상 로그인 시**:

```
1. 사용자 입력
   Username: user
   Password: d1e25e2d-3b51-4d3f-9d17-923d240afdb1
    ↓
2. 인증 성공
    ↓
3. 리다이렉트
   http://localhost:8080/member/list?continue
    ↓
4. 회원 목록 페이지 표시
   #  회원명   이메일
   1  홍혜창   hyechang@spring.ac.kr
   2  김우현   woo@spring.ac.kr
   3  홍길동   hong@spring.ac.kr
   4  김구라   gura@spring.ac.kr
```

---

### 사용자 정의 계정 설정

**application.properties**:

```properties
spring.application.name=springscuritySample

# 사용자 정의 계정
spring.security.user.name=admin
spring.security.user.password=password
spring.security.user.roles=USER,ADMIN
```

**설정 효과**:

| 설정 | 값 | 의미 |
|-----|-----|------|
| **user.name** | `admin` | 로그인 ID를 `admin`으로 고정 |
| **user.password** | `password` | 비밀번호를 `password`로 고정 |
| **user.roles** | `USER,ADMIN` | 사용자에게 부여할 권한 목록 |

**결과**: 
- ✅ 랜덤 비밀번호 대신 고정된 계정 사용 가능
- ✅ 개발 단계에서 테스트 편의성 향상
- ⚠️ 운영 환경에서는 절대 사용 금지!

---

### 설정 파일 사용 시 주의사항

**설정의 의미**:

이 설정은 스프링 부트가 자동으로 **메모리 기반 인증(`InMemoryUserDetailsManager`)**을 생성하고, 해당 사용자 정보를 사용하도록 지시합니다.

**비밀번호 처리 방식**:

| 상황 | 비밀번호 처리 |
|-----|------------|
| **설정 파일만 사용** | 내부적으로 `{noop}` 처리 (평문 비교) |
| **PasswordEncoder 빈 등록 시** | `{bcrypt}` 등 암호화된 값 필요 |

**핵심**: 
- 설정 파일에 평문 비밀번호를 입력해도 로그인되는 이유는 스프링 부트가 개발 편의를 위해 자동으로 평문 비교를 허용하기 때문입니다.
- 실제로는 이후 배울 `PasswordEncoder`를 통해 암호화된 비밀번호를 사용해야 합니다.

---

## 5.3.3 세션 기반 인증의 이해

### 한 번 로그인하면 계속 인증 상태 유지

**중요한 발견**: 한 번 로그인에 성공하면, 이후 다른 페이지 요청 시 다시 로그인할 필요가 없습니다!

**재인증 불필요 확인**:

```
1. /member/list 접근
   → 로그인 필요
   → admin/password 입력
   → 로그인 성공
    ↓
2. /member/detail 접근
   → 로그인 불필요!
   → 바로 페이지 표시
    ↓
3. /api/members 접근
   → 로그인 불필요!
   → 바로 데이터 반환
```

**이유**: 세션 기반 인증 메커니즘

---

### 세션과 쿠키의 작동 원리

**로그인 성공 시**:

```
1. 사용자 인증 성공
    ↓
2. 서버: 세션 생성
   - 세션 ID 생성: 4D14450B1DB8365A62ABE56D8F11AD7C
   - 사용자 정보 저장 (메모리 또는 DB)
    ↓
3. 서버 → 클라이언트: 쿠키 전송
   Set-Cookie: JSESSIONID=4D14450B1DB8365A62ABE56D8F11AD7C
    ↓
4. 브라우저: 쿠키 저장
```

---

**브라우저 개발자 도구에서 확인**:

```
애플리케이션 → 저장용량 → 쿠키 → localhost

이름: JSESSIONID
값: 4D14450B1DB8365A62ABE56D8F11AD7C
도메인: localhost
경로: /
```

---

**이후 요청 시**:

```
1. 클라이언트 요청
   GET /member/detail
   Cookie: JSESSIONID=4D14450B1DB8365A62ABE56D8F11AD7C
    ↓
2. 서버: 쿠키의 세션 ID 확인
    ↓
3. 서버: 세션 저장소에서 해당 세션 조회
    ↓
4. 세션 존재 확인
   "이 사용자는 이미 로그인했구나!"
    ↓
5. 재인증 없이 요청 처리
```

**핵심**:

| 항목 | 설명 |
|-----|------|
| **세션 ID** | 사용자를 식별하는 고유 키 |
| **쿠키** | 세션 ID를 저장하는 클라이언트 저장소 |
| **자동 전송** | 브라우저가 쿠키를 자동으로 모든 요청에 포함 |

---

### 세션 종료 조건

**세션이 만료되는 경우**:

| 조건 | 설명 | 결과 |
|-----|------|------|
| **로그아웃** | `/logout` 경로 접근 | 세션 즉시 삭제 |
| **브라우저 종료** | 브라우저 완전 종료 | 쿠키 삭제 (세션 쿠키) |
| **서버 재시작** | 애플리케이션 재구동 | 메모리 세션 소실 |
| **타임아웃** | 일정 시간 동안 요청 없음 | 세션 자동 만료 |

**세션 만료 후**:

```
1. 다음 요청 시
    ↓
2. 서버: 세션 ID로 세션 조회
    ↓
3. 세션 없음!
    ↓
4. 미인증 상태로 간주
    ↓
5. /login으로 리다이렉트
```

---

### 분산 환경에서의 세션 문제

**현대 웹 애플리케이션의 구조**:

고가용성(High Availability)과 부하 분산(Load Balancing)을 위해 **2대 이상의 서버**를 사용합니다.

**문제 상황**:

```
┌──────────────┐
│ 로드 밸런서   │
└──────┬───────┘
       │
   ┌───┴───┐
   ↓       ↓
┌─────┐ ┌─────┐
│App 1│ │App 2│
└─────┘ └─────┘
(세션 A) (세션 B)
```

**시나리오**:

```
1. 사용자 → App 1에 로그인
   → App 1의 메모리에 세션 저장
    ↓
2. 다음 요청 → 로드 밸런서 → App 2로 전달
    ↓
3. App 2: 세션 ID 확인
    ↓
4. App 2의 메모리에 해당 세션 없음!
    ↓
5. 미인증으로 간주 → 재로그인 요구
```

**문제의 본질**:

| 문제 | 설명 |
|-----|------|
| **세션 독립성** | 각 서버가 독립적인 메모리에 세션 저장 |
| **공유 불가** | App 1의 세션을 App 2가 알 수 없음 |
| **사용자 경험 저하** | 요청마다 다른 서버로 가면 재로그인 필요 |

---

### 세션 공유 해결책: spring-session-jdbc

**해결 방법**: 세션 정보를 **중앙 데이터베이스**에 저장하여 모든 서버가 공유

**의존성 추가**:

```gradle
implementation 'org.springframework.session:spring-session-jdbc'
```

---

**application.properties 설정**:

```properties
spring.session.jdbc.initialize-schema=always
```

**설정의 의미**:

| 항목 | 설명 |
|-----|------|
| **jdbc** | JDBC를 통해 DB에 세션 저장 |
| **initialize-schema** | 세션 저장용 테이블 자동 생성 |
| **always** | 애플리케이션 시작 시마다 확인 및 생성 |

---

**자동 생성되는 테이블**:

| 테이블명 | 역할 |
|---------|------|
| **SPRING_SESSION** | 세션 ID, 생성 시간, 만료 시간 등 저장 |
| **SPRING_SESSION_ATTRIBUTES** | 세션에 저장된 데이터 (사용자 정보, 권한 등) |

---

**세션 공유 작동 방식**:

```
1. App 1: 사용자 로그인
    ↓
2. App 1: 세션 생성
    ↓
3. 중앙 DB: 세션 정보 저장
    ↓
4. 다음 요청 → App 2로 전달
    ↓
5. App 2: 쿠키의 세션 ID 확인
    ↓
6. App 2: 중앙 DB에서 세션 조회
    ↓
7. 세션 정보 발견!
    ↓
8. 로그인 상태 유지 → 정상 처리
```

**장점**:

| 장점 | 설명 |
|-----|------|
| **세션 공유** | 모든 서버가 DB를 통해 세션 정보 공유 |
| **서버 재시작 대응** | DB에 저장되어 있어 서버 재시작해도 세션 유지 |
| **확장성** | 서버를 추가해도 세션 문제 없음 |

---

## 5.3.4 RESTful API와 HTTP Basic Authentication

### RESTful API에서의 인증

**질문**: 지금까지는 Spring MVC 웹 애플리케이션의 예제였습니다. 그렇다면 **RESTful API** (JSON 응답)에서도 스프링 시큐리티를 사용할 수 있을까요?

**답변**: 네! 스프링 시큐리티는 **Spring MVC**와 **RESTful API** 모두 지원합니다.

---

### RESTful API Controller 작성

**RestfulApiController.java**:

```java
package com.example.springscuritySample.controller;

import com.example.springscuritySample.model.Member;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class RestfulApiController {
    
    private List<Member> members = List.of(
            new Member(1L, "홍혜창", "hyechang@spring.ac.kr"),
            new Member(2L, "김우현", "woo@spring.ac.kr"),
            new Member(3L, "홍길동", "hong@spring.ac.kr"),
            new Member(4L, "김구라", "gura@spring.ac.kr")
    );

    @GetMapping("/api/members")
    public List<Member> getMembers() {
        return members;
    }
}
```

---

### Postman으로 API 요청

**인증 없이 요청**:

```
GET http://localhost:8080/api/members
```

**결과**:

```
Status: 401 Unauthorized

Headers:
WWW-Authenticate: Basic realm="Realm"

Body:
{
  "timestamp": "2025-11-02T10:30:00.000+00:00",
  "status": 401,
  "error": "Unauthorized",
  "message": "Unauthorized",
  "path": "/api/members"
}
```

---

### 응답 분석

**401 Unauthorized의 의미**:

| 항목 | 설명 |
|-----|------|
| **상태 코드** | 401 (인증 필요) |
| **의미** | "당신은 인증되지 않았습니다" |
| **조치** | 인증 정보를 제공해야 함 |

---

**WWW-Authenticate 헤더**:

```
WWW-Authenticate: Basic realm="Realm"
```

**헤더의 구성 요소**:

| 구성 요소 | 값 | 의미 |
|---------|-----|------|
| **Basic** | 인증 기법 | HTTP Basic Authentication 사용 |
| **realm** | "Realm" | 보호 영역의 이름 |

**핵심**: 서버가 클라이언트에게 "이 영역에 접근하려면 Basic 인증 방식을 사용해야 한다"고 알려주는 것입니다.

---

### HTTP Basic Authentication이란?

**정의**: 사용자 아이디와 비밀번호를 Base64로 인코딩하여 HTTP 헤더에 담아 전송하는 인증 방식

**작동 원리**:

```
1. 원본 문자열 생성
   admin:password
    ↓
2. Base64 인코딩
   YWRtaW46cGFzc3dvcmQ=
    ↓
3. Authorization 헤더 구성
   Authorization: Basic YWRtaW46cGFzc3dvcmQ=
    ↓
4. 서버로 전송
```

---

### Postman에서 Basic Auth 설정

**설정 방법**:

```
1. Postman 열기
    ↓
2. Authorization 탭 선택
    ↓
3. Type: Basic Auth 선택
    ↓
4. Username: admin
   Password: password
    ↓
5. Send 클릭
```

**Postman이 자동으로 처리**:

```
Authorization: Basic YWRtaW46cGFzc3dvcmQ=
```

---

**성공 응답**:

```
Status: 200 OK

Body:
[
    {
        "id": 1,
        "name": "홍혜창",
        "email": "hyechang@spring.ac.kr"
    },
    {
        "id": 2,
        "name": "김우현",
        "email": "woo@spring.ac.kr"
    },
    {
        "id": 3,
        "name": "홍길동",
        "email": "hong@spring.ac.kr"
    },
    {
        "id": 4,
        "name": "김구라",
        "email": "gura@spring.ac.kr"
    }
]
```

---

### Spring MVC vs RESTful API 인증 비교

**인증 방식의 차이**:

| 구분 | Spring MVC (웹 앱) | RESTful API |
|-----|-------------------|------------|
| **인증 방식** | 폼 기반 로그인 | HTTP Basic Authentication |
| **상태 저장** | 세션 (Stateful) | 토큰 또는 매 요청마다 인증 (Stateless) |
| **인증 정보 위치** | 쿠키 (JSESSIONID) | 헤더 (Authorization) |
| **로그인 화면** | HTML 폼 페이지 | 없음 (클라이언트가 처리) |
| **사용자 경험** | 사용자가 폼 입력 | 앱이 백그라운드에서 처리 |

---

### 핵심 이해

**스프링 시큐리티의 유연성**:

| 특징 | 설명 |
|-----|------|
| **다양한 인증 방식** | 폼 기반, Basic, Bearer Token 등 |
| **통합 지원** | Spring MVC와 RESTful API 모두 지원 |
| **일관된 보안 정책** | 동일한 필터 체인으로 모든 요청 처리 |

**결론**: 스프링 시큐리티는 **웹 애플리케이션과 API 서버 모두**에서 사용 가능한 강력한 보안 프레임워크입니다!

---

## 5.3.5 UserDetails와 UserDetailsService

### 다중 사용자 인증의 필요성

**현재의 문제**:

지금까지는 `application.properties`에 설정한 **단 한 명의 계정**만 사용했습니다:

```properties
spring.security.user.name=admin
spring.security.user.password=password
```

**실제 서비스의 요구사항**:

| 요구사항 | 설명 |
|---------|------|
| **다중 사용자** | 수많은 사용자 계정 지원 필요 |
| **동적 조회** | 입력된 아이디로 DB에서 사용자 정보 조회 |
| **비밀번호 검증** | 저장된 암호화된 비밀번호와 비교 |
| **권한 확인** | 사용자가 가진 권한 목록 확인 |

**해결책**: `UserDetailsService`와 `UserDetails` 인터페이스

---

### UserDetails 인터페이스

**정의**: 스프링 시큐리티가 사용하는 **사용자 정보 모델**

**인터페이스 구조**:

```java
public interface UserDetails extends Serializable {
    
    // 필수 구현 메서드 (추상 메서드)
    Collection<? extends GrantedAuthority> getAuthorities();
    String getPassword();
    String getUsername();
    
    // 선택적 구현 메서드 (디폴트 메서드)
    default boolean isAccountNonExpired() { return true; }
    default boolean isAccountNonLocked() { return true; }
    default boolean isCredentialsNonExpired() { returntrue; }
    default boolean isEnabled() { return true; }
}
```

---

### 필수 구현 메서드

**반드시 구현해야 하는 추상 메서드**:

| 메서드 | 반환 타입 | 역할 | 예시 |
|-------|----------|------|------|
| **getUsername()** | String | 사용자 식별자 (로그인 ID) | "hyechang@spring.ac.kr" |
| **getPassword()** | String | 암호화된 비밀번호 | "{bcrypt}$2a$10$..." |
| **getAuthorities()** | Collection<? extends GrantedAuthority> | 권한 목록 | [ROLE_USER, ROLE_ADMIN] |

**핵심**: 이 세 가지 정보는 **로그인 검증과 권한 부여**의 핵심 데이터입니다.

---

### 선택적 구현 메서드

**기본 구현이 있는 디폴트 메서드**:

| 메서드 | 기본값 | 의미 | 사용 사례 |
|-------|--------|------|----------|
| **isEnabled()** | true | 계정 활성화 여부 | 탈퇴/정지된 계정 차단 |
| **isAccountNonExpired()** | true | 계정 만료되지 않았는가 | 기간 제한 계정 |
| **isAccountNonLocked()** | true | 계정 잠기지 않았는가 | 비밀번호 5회 실패 시 잠금 |
| **isCredentialsNonExpired()** | true | 비밀번호 만료되지 않았는가 | 비밀번호 주기적 변경 정책 |

**핵심**: 
- 기본값이 모두 `true`이므로 오버라이드하지 않아도 됨
- 필요 시 회사 정책에 맞게 구현 가능

---

### GrantedAuthority 인터페이스

**정의**: 사용자가 가진 **권한(Role)** 정보를 나타내는 인터페이스

**인터페이스 구조**:

```java
public interface GrantedAuthority extends Serializable {
    String getAuthority();
}
```

**역할**: 
- "ROLE_USER", "ROLE_ADMIN" 같은 권한 문자열 반환

---

### SimpleGrantedAuthority 구현체

**정의**: 스프링 시큐리티가 제공하는 기본 구현 클래스

**사용 예시**:

```java
GrantedAuthority authority = new SimpleGrantedAuthority("ROLE_USER");
String role = authority.getAuthority(); // "ROLE_USER"
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **기본 구현체** | 스프링 시큐리티 내장 |
| **단순 구조** | 권한 문자열만 저장 |
| **충분한 기능** | 대부분의 경우 이것만으로 충분 |

---

### UserDetailsService 인터페이스

**정의**: 사용자 아이디로 사용자 정보를 조회하는 **서비스 인터페이스**

**인터페이스 구조**:

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;
}
```

**역할**:

| 항목 | 설명 |
|-----|------|
| **메서드 개수** | 단 하나 (함수형 인터페이스) |
| **입력** | 사용자 아이디 (username) |
| **출력** | UserDetails 객체 |
| **역할** | DB에서 사용자 정보 조회 및 UserDetails 생성 |

**핵심**: "DB에서 유저 정보 꺼내오기 담당 클래스"

---

### UserDetails 구현 시 주의사항

**필드명과 Getter의 중요성**:

UserDetails 인터페이스의 메서드를 구현할 때, **필드명**을 잘 지정하면 Lombok의 `@Data` 또는 `@Getter`를 통해 자동으로 메서드가 생성됩니다.

**예시**:

```java
@Data
public class MyUserDetails implements UserDetails {
    
    // 필드명이 중요!
    private String username;  // getUsername() 자동 생성
    private String password;  // getPassword() 자동 생성
    private List<SimpleGrantedAuthority> authorities;  // getAuthorities() 자동 생성
}
```

**주의사항**:

| 잘못된 필드명 | 생성되는 Getter | 문제 |
|------------|----------------|------|
| `private String userId` | `getUserId()` | getUsername() 구현 안 됨 |
| `private String pwd` | `getPwd()` | getPassword() 구현 안 됨 |

**해결책**: 
- 필드명을 `username`, `password`, `authorities`로 정확히 지정
- 또는 직접 메서드 오버라이드

---

## 5.3.6 스프링 시큐리티 인증 과정의 이해

### 인증 과정의 큰 틀 (4단계)

스프링 시큐리티의 로그인 과정을 **4단계**로 이해하면 전체 구조를 명확히 파악할 수 있습니다.

---

### 1단계: 사용자 정보 조회

**사용자 로그인 시도**:

```
사용자 입력:
ID (username): hyechang@spring.ac.kr
Password: 2222
```

**스프링 시큐리티의 동작**:

```
1. AuthenticationProvider 작동
    ↓
2. UserDetailsService.loadUserByUsername() 호출
   매개변수: "hyechang@spring.ac.kr"
    ↓
3. DB에서 사용자 정보 조회
    ↓
4. UserDetails 객체 생성 및 반환
```

**핵심**: 
- **비밀번호는 이 단계에서 전달되지 않음**
- **아이디만으로** 사용자 정보 조회

---

### 2단계: 비밀번호 검증

**PasswordEncoder를 통한 검증**:

```
1. 사용자 입력 비밀번호 획득
   입력값: "2222" (평문)
    ↓
2. UserDetails에서 저장된 비밀번호 획득
   getPassword(): "{bcrypt}$2a$10$..." (암호화)
    ↓
3. PasswordEncoder.matches() 호출
   매개변수:
   - 평문: "2222"
   - 암호화: "{bcrypt}$2a$10$..."
    ↓
4. matches() 내부 동작
   - 암호화된 문자열에서 솔트(salt) 추출
   - 평문을 동일한 솔트로 암호화
   - 두 해시 값 비교
    ↓
5. 결과 반환
   - true: 비밀번호 일치 → 인증 진행
   - false: 비밀번호 불일치 → BadCredentialsException
```

---

### PasswordEncoder의 두 가지 사용 시점

**중요한 이해**: PasswordEncoder는 두 가지 시점에서 사용됩니다.

| 사용 시점 | 메서드 | 주체 | 목적 |
|---------|--------|------|------|
| **회원가입/비밀번호 변경** | `encode()` | 애플리케이션 (Service) | 평문 비밀번호를 암호화하여 DB 저장 |
| **로그인 인증** | `matches()` | 스프링 시큐리티 | 입력 비밀번호와 저장된 해시 값 비교 |

---

**PasswordEncoder 인터페이스**:

```java
public interface PasswordEncoder {
    
    // 1. 회원가입 시 사용
    String encode(CharSequence rawPassword);
    
    // 2. 로그인 시 사용
    boolean matches(CharSequence rawPassword, String encodedPassword);
    
    // 3. 암호화 방식 업그레이드 판단
    default boolean upgradeEncoding(String encodedPassword) {
        return false;
    }
}
```

---

**matches() 메서드의 작동 원리**:

```java
// 내부 동작 (BCryptPasswordEncoder 기준)
public boolean matches(CharSequence rawPassword, String encodedPassword) {
    // 1. encodedPassword에서 솔트 추출
    String salt = extractSalt(encodedPassword);
    
    // 2. 평문 비밀번호를 동일한 솔트로 암호화
    String hashedInput = hash(rawPassword, salt);
    
    // 3. 두 해시 값 비교
    return hashedInput.equals(encodedPassword);
}
```

**핵심**: 
- `matches()`는 내부적으로 평문을 암호화하여 비교
- 개발자가 직접 `encode()`를 호출할 필요 없음

---

### 3단계: 계정 상태 확인

**UserDetails의 상태 메서드 확인**:

```
비밀번호 일치 확인 후:
    ↓
UserDetails의 디폴트 메서드 호출:
    ↓
isAccountNonExpired()  // 계정 만료 확인
isAccountNonLocked()   // 계정 잠금 확인
isCredentialsNonExpired()  // 비밀번호 만료 확인
isEnabled()  // 계정 활성화 확인
    ↓
모든 메서드가 true 반환 시:
    ↓
인증 성공으로 진행
```

**실패 시**:

| 메서드 | false 반환 시 예외 |
|-------|------------------|
| `isEnabled()` | `DisabledException` |
| `isAccountNonLocked()` | `LockedException` |
| `isAccountNonExpired()` | `AccountExpiredException` |
| `isCredentialsNonExpired()` | `CredentialsExpiredException` |

---

### 4단계: 인증 성공 및 SecurityContext 저장

**인증 성공 처리**:

```
1. 인증 성공
    ↓
2. Authentication 객체 생성
   - UserDetails 포함
   - 권한 목록 포함
    ↓
3. SecurityContext에 저장
    ↓
4. SecurityContext를 세션에 저장
   세션 키: SPRING_SECURITY_CONTEXT
    ↓
5. 이후 요청마다 세션에서 SecurityContext 조회
    ↓
6. 재인증 불필요
```

---

**SecurityContext의 구조**:

```
Session
    └── SPRING_SECURITY_CONTEXT
            └── Authentication
                    ├── UserDetails
                    │       ├── username
                    │       ├── password
                    │       └── authorities
                    └── authenticated: true
```

**핵심**: 
- 한 번 로그인하면 UserDetails가 세션에 보관
- 이후 요청에서는 DB 조회 없이 세션에서 정보 사용

---

### PasswordEncoder의 {} 접두사

**다중 인코더 지원**:

스프링 시큐리티는 **여러 종류의 PasswordEncoder**를 동시에 사용할 수 있습니다.

**문제 상황**:

```
DB에 저장된 비밀번호:
- 일부 사용자: {bcrypt}$2a$10$...
- 일부 사용자: {sha256}abc123...
- 일부 사용자: {noop}password
```

**해결책: DelegatingPasswordEncoder**:

```
로그인 시:
    ↓
UserDetails.getPassword(): "{bcrypt}$2a$10$..."
    ↓
DelegatingPasswordEncoder:
    ↓
{} 접두사 확인: "bcrypt"
    ↓
BCryptPasswordEncoder 빈 선택
    ↓
matches() 호출
```

---

**접두사별 인코더 선택**:

| DB 저장 비밀번호 | 선택되는 인코더 |
|----------------|---------------|
| `{bcrypt}$2a$10$...` | BCryptPasswordEncoder |
| `{sha256}abc123...` | SHA-256 인코더 |
| `{noop}password` | NoOpPasswordEncoder |

**핵심**: 
- `{}`는 어떤 인코더를 사용할지 알려주는 **식별자**
- 시스템 마이그레이션 시 유용

---

### 인증 과정 전체 흐름도

```
┌─────────────────────┐
│ 1. 로그인 요청       │
│ ID: hyechang@...    │
│ PW: 2222            │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 2. UserDetailsService│
│ loadUserByUsername() │
│ 호출                │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 3. DB 조회          │
│ SELECT * FROM user  │
│ WHERE email = ?     │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 4. UserDetails 생성 │
│ username: hyechang  │
│ password: {bcrypt}..│
│ authorities: [...]  │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 5. 비밀번호 검증     │
│ PasswordEncoder     │
│ matches(2222, ...)  │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 6. 계정 상태 확인    │
│ isEnabled()         │
│ isAccountNonLocked()│
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 7. 인증 성공        │
│ SecurityContext 저장│
│ 세션에 보관         │
└──────────┬──────────┘
           ↓
┌─────────────────────┐
│ 8. 요청 페이지 표시  │
└─────────────────────┘
```

---

## 5.3.7 메모리 기반 사용자 인증

### InMemoryUserDetailsManager란?

**정의**: 사용자 정보를 **메모리(애플리케이션 힙 공간)**에 저장하고 관리하는 UserDetailsService 구현체

**특징**:

| 항목 | 설명 |
|-----|------|
| **저장 방식** | 내부 Map에 저장 (username이 키) |
| **속도** | DB 접근 없어 가장 빠름 |
| **휘발성** | 서버 재시작 시 데이터 소멸 |
| **사용 목적** | 개발/테스트 환경 |

---

### 메모리 기반 인증 구현

**SecurityConfiguration.java** (첫 번째 예제):

```java
package com.example.springscuritySample.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;

@Configuration
public class SecurityConfiguration {
    
    @Bean
    public UserDetailsService useInMemoryUserDetailsManager() {
        
        // 사용자 1
        UserDetails userDetailsOne = User.builder()
                .username("hyechang")
                .password("{noop}password")
                .roles("USER", "ADMIN")
                .build();
        
        // 사용자 2
        UserDetails userDetailsTwo = User.builder()
                .username("woohyun")
                .password("{noop}password")
                .roles("USER")
                .build();
        
        // 사용자 3
        UserDetails userDetailsThree = User.builder()
                .username("adminUser")
                .password("{noop}password")
                .roles("ADMIN")
                .build();
        
        return new InMemoryUserDetailsManager(
            userDetailsOne, 
            userDetailsTwo, 
            userDetailsThree
        );
    }
}
```

---

### User.builder()의 역할

**User 클래스**: 스프링 시큐리티가 제공하는 **UserDetails 기본 구현체**

**빌더 패턴 사용**:

| 메서드 | 역할 | 예시 |
|-------|------|------|
| **username()** | 로그인 ID 설정 | `.username("hyechang")` |
| **password()** | 비밀번호 설정 | `.password("{noop}password")` |
| **roles()** | 권한 설정 | `.roles("USER", "ADMIN")` |
| **build()** | User 객체 생성 | 최종적으로 UserDetails 반환 |

---

### {noop} 접두사의 의미

**정의**: "No Operation" - 암호화 없이 평문 비교

**사용 예시**:

```java
.password("{noop}password")
```

**작동 방식**:

```
로그인 시:
    ↓
사용자 입력: "password"
    ↓
UserDetails.getPassword(): "{noop}password"
    ↓
DelegatingPasswordEncoder:
    ↓
{} 확인: "noop"
    ↓
NoOpPasswordEncoder 선택
    ↓
평문 그대로 비교
    ↓
"password" == "password" → 인증 성공
```

---

### {noop} vs 암호화 비교

| 구분 | {noop} | {bcrypt} |
|-----|--------|----------|
| **비밀번호 저장** | `{noop}password` | `{bcrypt}$2a$10$...` |
| **비교 방식** | 평문 그대로 비교 | 해시 값 비교 |
| **보안성** | ❌ 매우 취약 | ✅ 안전 |
| **사용 시점** | 테스트 전용 | 운영 환경 필수 |

**주의**: `{noop}`은 **절대 운영 환경에서 사용 금지**!

---

### InMemoryUserDetailsManager 작동 원리

**미리 UserDetails 생성**:

```
애플리케이션 시작:
    ↓
@Bean 메서드 실행
    ↓
User.builder()로 UserDetails 객체 생성
    ↓
InMemoryUserDetailsManager 생성자에 전달
    ↓
내부 Map에 저장:
Map<String, UserDetails> users = {
    "hyechang" → UserDetails객체1,
    "woohyun" → UserDetails객체2,
    "adminUser" → UserDetails객체3
}
```

---

**로그인 시**:

```
loadUserByUsername("hyechang") 호출
    ↓
내부 Map에서 "hyechang" 키로 검색
    ↓
미리 만들어진 UserDetails 객체 반환
    ↓
DB 조회 없이 즉시 반환 (빠름)
```

**핵심**: 
- 다른 방식은 **요청 시 UserDetails 생성**
- 메모리 방식은 **서버 시작 시 미리 생성**하여 저장

---

### PasswordEncoder와 함께 사용

**SecurityConfiguration.java** (두 번째 예제):

```java
@Configuration
public class SecurityConfiguration {
    
    @Bean
    public UserDetailsService useInMemoryUserDetailsManager(PasswordEncoder passwordEncoder) {
        
        UserDetails userDetailsOne = User.builder()
                .username("hyechang")
                .password(passwordEncoder.encode("password"))  // 암호화
                .roles("USER", "ADMIN")
                .build();
        
        UserDetails userDetailsTwo = User.builder()
                .username("woohyun")
                .password(passwordEncoder.encode("password"))
                .roles("USER")
                .build();
        
        UserDetails userDetailsThree = User.builder()
                .username("adminUser")
                .password(passwordEncoder.encode("password"))
                .roles("ADMIN")
                .build();
        
        return new InMemoryUserDetailsManager(
            userDetailsOne, 
            userDetailsTwo, 
            userDetailsThree
        );
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

### 스프링의 의존성 주입 순서

**빈 생성 순서**:

```
1. @Configuration 클래스 스캔
    ↓
2. @Bean 메서드 확인 및 의존성 분석
   - passwordEncoder(): 의존성 없음
   - useInMemoryUserDetailsManager(PasswordEncoder): PasswordEncoder 필요
    ↓
3. 의존성 없는 빈 먼저 생성
   passwordEncoder() 빈 생성
    ↓
4. 의존성 있는 빈 생성
   useInMemoryUserDetailsManager() 호출 시
   생성된 PasswordEncoder 빈 주입
    ↓
5. passwordEncoder.encode("password") 실행
   → {bcrypt}$2a$10$... 생성
    ↓
6. UserDetails 객체 완성
    ↓
7. InMemoryUserDetailsManager 빈 등록
```

**핵심**: 스프링이 자동으로 의존성 순서를 파악하여 빈 생성

---

### 메모리 기반 인증의 장단점

**장점**:

| 장점 | 설명 |
|-----|------|
| **빠른 속도** | DB 접근 없어 가장 빠름 |
| **간단한 설정** | 코드 몇 줄로 인증 시스템 구축 |
| **테스트 용이** | 단위 테스트에 최적 |

**단점**:

| 단점 | 설명 |
|-----|------|
| **데이터 휘발성** | 서버 재시작 시 모든 사용자 정보 소멸 |
| **확장성 없음** | 사용자 추가/수정 불가 |
| **운영 부적합** | 실제 서비스에는 사용 불가 |

---

## 5.3.8 JDBC 기반 사용자 인증

### JdbcUserDetailsManager란?

**정의**: **데이터베이스**에서 사용자 정보를 조회하는 UserDetailsService 구현체

**특징**:

| 항목 | 설명 |
|-----|------|
| **저장소** | RDBMS (H2, MySQL, PostgreSQL 등) |
| **스키마** | 스프링 시큐리티 표준 테이블 구조 사용 |
| **영속성** | 서버 재시작해도 데이터 유지 |
| **UserDetails 생성** | 내부적으로 자동 생성 |

---

### 표준 스키마 구조

스프링 시큐리티는 **고정된 테이블 구조**를 요구합니다.

**schema.sql** (테이블 생성):

```sql
-- 테이블이 이미 존재한다면 삭제
DROP TABLE IF EXISTS authorities;
DROP TABLE IF EXISTS users;

-- 1. USERS 테이블 (사용자 정보 저장)
CREATE TABLE users (
    -- 사용자 이름 (로그인 ID), 기본 키
    username VARCHAR(50) NOT NULL PRIMARY KEY,
    
    -- 암호화된 비밀번호
    password VARCHAR(100) NOT NULL,
    
    -- 계정 활성화 여부
    enabled BOOLEAN NOT NULL
);

-- 2. AUTHORITIES 테이블 (사용자 권한 정보 저장)
CREATE TABLE authorities (
    -- 사용자 이름 (외래 키)
    username VARCHAR(50) NOT NULL,
    
    -- 사용자가 가진 권한
    authority VARCHAR(50) NOT NULL,
    
    -- 외래 키 제약조건
    CONSTRAINT fk_authorities_users 
        FOREIGN KEY (username) 
        REFERENCES users(username)
);

-- 인덱스 설정 (username과 authority 조합은 고유)
CREATE UNIQUE INDEX ix_auth_username
    ON authorities (username, authority);
```

---

### 테이블 구조 분석

**USERS 테이블**:

| 칼럼 | 타입 | 설명 |
|-----|------|------|
| **username** | VARCHAR(50) | 로그인 ID (기본 키) |
| **password** | VARCHAR(100) | 암호화된 비밀번호 |
| **enabled** | BOOLEAN | 계정 활성화 여부 |

**AUTHORITIES 테이블**:

| 칼럼 | 타입 | 설명 |
|-----|------|------|
| **username** | VARCHAR(50) | 사용자 ID (외래 키) |
| **authority** | VARCHAR(50) | 권한 (ROLE_USER, ROLE_ADMIN 등) |

**관계**:

```
users (1) ←──→ (N) authorities

한 명의 사용자는 여러 권한을 가질 수 있음
```

---

### 초기 데이터 설정

**data.sql** (초기 데이터 삽입):

```sql
-- 비밀번호 "password"를 BCrypt로 인코딩한 결과
-- (실제로는 BCryptPasswordEncoder로 생성한 값 사용)

-- 1. USERS 테이블에 사용자 데이터 삽입
INSERT INTO users (username, password, enabled)
VALUES
    ('hyechang', '{bcrypt}$2a$10$T6i8oJg274718sK87H330u5O...', TRUE),
    ('adminUser', '{bcrypt}$2a$10$T6i8oJg274718sK87H330u5O...', TRUE);

-- 2. AUTHORITIES 테이블에 권한 데이터 삽입
-- hyechang: ROLE_USER 권한
INSERT INTO authorities (username, authority)
VALUES ('hyechang', 'ROLE_USER');

-- adminUser: ROLE_ADMIN 권한
INSERT INTO authorities (username, authority)
VALUES ('adminUser', 'ROLE_ADMIN');
```

---

### 파일 위치 규칙

**스프링 부트의 자동 실행 규칙**:

| 파일명 | 경로 | 용도 | 실행 시점 |
|-------|------|------|----------|
| **schema.sql** | `src/main/resources/` | DDL (테이블 생성) | 애플리케이션 시작 시 |
| **data.sql** | `src/main/resources/` | DML (데이터 삽입) | schema.sql 실행 후 |

**핵심**: 
- 파일명과 위치가 정확해야 자동 실행
- 순서: schema.sql → data.sql

---

### JDBC 기반 인증 구현

**SecurityConfiguration.java**:

```java
@Configuration
public class SecurityConfiguration {
    
    @Bean
    public UserDetailsManager useJdbcUserDetailsManager(DataSource dataSource) {
        return new JdbcUserDetailsManager(dataSource);
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

### 코드 분석

**DataSource 주입**:

| 항목 | 설명 |
|-----|------|
| **DataSource** | 데이터베이스 연결 정보를 담은 객체 |
| **자동 주입** | 스프링 부트가 자동으로 생성 및 주입 |
| **사용** | JdbcUserDetailsManager가 DB 접근 시 사용 |

---

**반환 타입: UserDetailsManager**:

```
UserDetailsService (인터페이스)
    ↑
    상속
    ↓
UserDetailsManager (인터페이스)
    ↑
    구현JdbcUserDetailsManager (구현체)
```

**관계**:

| 인터페이스 | 메서드 | 역할 |
|-----------|--------|------|
| **UserDetailsService** | `loadUserByUsername()` | 사용자 조회 (읽기) |
| **UserDetailsManager** | `createUser()`, `updateUser()`, `deleteUser()` | 사용자 관리 (CRUD) |

**핵심**: 
- JdbcUserDetailsManager는 UserDetailsManager를 구현
- UserDetailsManager는 UserDetailsService를 상속
- 따라서 UserDetailsService 빈으로도 사용 가능

---

### 반환 타입 선택 기준

**UserDetailsService 반환**:

```java
@Bean
public UserDetailsService useJdbcUserDetailsManager(DataSource dataSource) {
    return new JdbcUserDetailsManager(dataSource);
}
```

**사용 시기**: 
- 인증 기능만 필요한 경우
- 학습 목적

---

**UserDetailsManager 반환**:

```java
@Bean
public UserDetailsManager useJdbcUserDetailsManager(DataSource dataSource) {
    return new JdbcUserDetailsManager(dataSource);
}
```

**사용 시기**: 
- 사용자 계정 관리 기능(CRUD) 필요
- 회원가입, 회원정보 수정 기능 구현

**권장**: 
- 실무에서는 UserDetailsManager 반환
- 추후 기능 확장 가능

---

### JdbcUserDetailsManager 작동 방식

**로그인 시 내부 동작**:

```
1. loadUserByUsername("hyechang") 호출
    ↓
2. SQL 실행
   SELECT username, password, enabled 
   FROM users 
   WHERE username = ?
    ↓
3. 사용자 정보 조회 성공
    ↓
4. 권한 조회 SQL 실행
   SELECT username, authority 
   FROM authorities 
   WHERE username = ?
    ↓
5. 내부적으로 UserDetails 객체 생성
   username: hyechang
   password: {bcrypt}$2a$10$...
   authorities: [ROLE_USER]
    ↓
6. UserDetails 반환
```

**핵심**: 
- 개발자가 SQL을 작성할 필요 없음
- JdbcUserDetailsManager가 자동으로 처리

---

### 표준 스키마의 제약

**고정된 테이블 구조**:

| 제약 사항 | 설명 |
|---------|------|
| **테이블명 고정** | `users`, `authorities` 이름 변경 불가 |
| **칼럼명 고정** | `username`, `password`, `authority` 변경 불가 |
| **추가 필드 어려움** | email, name 같은 추가 정보 저장 복잡 |

**한계**: 
- 실무에서는 테이블 구조를 자유롭게 설계하고 싶음
- 이 한계를 극복하기 위해 **커스텀 구현**이 필요

---

## 5.3.9 커스텀 사용자 인증 서비스

### 커스텀 구현의 필요성

**실무 요구사항**:

| 요구사항 | 표준 방식의 한계 | 커스텀 구현의 장점 |
|---------|----------------|------------------|
| **비표준 DB 구조** | 테이블/칼럼명 고정 | 자유로운 스키마 설계 |
| **JPA 사용** | JDBC 방식 사용 | ORM 기반 객체 지향 개발 |
| **추가 정보 저장** | 제한적 | name, phone, address 등 자유 추가 |
| **복잡한 로직** | 불가능 | 비즈니스 로직 자유롭게 구현 |

**결론**: 가장 유연하고 실무에서 많이 사용하는 방식

---

### 엔티티 설계

**User.java** (사용자 엔티티):

```java
package com.example.springscuritySample.model;

import jakarta.persistence.*;
import lombok.*;

@Data
@Entity
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    private String email;
    private String password;
}
```

**특징**:

| 필드 | 역할 | 비고 |
|-----|------|------|
| **id** | 기본 키 | 자동 생성 |
| **name** | 사용자 이름 | 표준 스키마에 없는 추가 정보 |
| **email** | 이메일 (로그인 ID로 사용) | username 역할 |
| **password** | 암호화된 비밀번호 | {bcrypt}$2a$10$... |

---

**Authorities.java** (권한 엔티티):

```java
package com.example.springscuritySample.model;

import jakarta.persistence.*;
import lombok.*;

@Entity
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Data
public class Authorities {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String authority;
    
    @ManyToOne
    @JoinColumn(name = "user_id")
    private User user;
}
```

---

### 엔티티 관계 분석

**관계 설정**:

```
User (1) ←──→ (N) Authorities

한 명의 사용자는 여러 권한을 가질 수 있음
```

**@ManyToOne의 의미**:

| 측면 | 설명 |
|-----|------|
| **Authorities 관점** | 여러 Authorities가 하나의 User를 참조 |
| **관계 방향** | Authorities → User (단방향) |
| **외래 키** | Authorities 테이블의 user_id 칼럼 |

---

**@JoinColumn의 역할**:

```java
@JoinColumn(name = "user_id")
```

| 항목 | 설명 |
|-----|------|
| **name** | 외래 키 칼럼명 지정 |
| **생략 시** | 기본값: `user_id` (필드명 + `_id`) |
| **명시적 지정 이유** | 코드 가독성 향상 |

---

### 다대다 관계가 아닌 이유

**질문**: 권한은 Role 테이블로 분리하고 User-Role을 다대다로 설계하는 것이 정규화 관점에서 더 좋지 않나요?

**답변**: 맞습니다. 하지만 이번 예제에서는 **학습 단순화**를 위해 1:N 구조를 선택했습니다.

**현재 구조의 장단점**:

| 장점 | 단점 |
|-----|------|
| **단순한 구현** | 권한 문자열 중복 저장 |
| **빠른 학습** | 권한 관리 어려움 |
| **인증 연동 용이** | 정규화 위반 |

**실무 권장 구조**:

```
User (N) ←──→ (M) Role (N)
         UserRole
       (중간 테이블)

Role 테이블에 권한 종류만 저장
UserRole 테이블로 매핑
```

---

### Repository 작성

**UserRepository.java**:

```java
package com.example.springscuritySample.repository;

import com.example.springscuritySample.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    // 이메일로 사용자 조회
    User findByEmail(String email);
}
```

---

**AuthoritiesRepository.java**:

```java
package com.example.springscuritySample.repository;

import com.example.springscuritySample.model.Authorities;
import com.example.springscuritySample.model.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

@Repository
public interface AuthoritiesRepository extends JpaRepository<Authorities, Long> {
    
    // 특정 사용자의 권한 목록 조회
    List<Authorities> findByUser(User user);
}
```

**핵심**: 
- Spring Data JPA의 메서드 이름 규칙 사용
- 자동으로 SQL 생성

---

### MyUserDetails 구현

**정의**: UserDetails 인터페이스를 구현한 **커스텀 사용자 정보 클래스**

**MyUserDetails.java**:

```java
package com.example.springscuritySample.model;

import lombok.Data;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

@Data
public class MyUserDetails implements UserDetails {
    
    // 필수 필드 (UserDetails 메서드와 매핑)
    private String username;
    private String password;
    private List<SimpleGrantedAuthority> authorities;
    
    // 추가 필드 (비즈니스 로직용)
    private String displayName;
    private Long userId;
    
    // 생성자
    public MyUserDetails(User user, List<Authorities> authoritiesList) {
        this.username = user.getEmail();  // 이메일을 username으로 사용
        this.password = user.getPassword();
        this.displayName = user.getName();
        this.userId = user.getId();
        
        // Authorities 리스트를 SimpleGrantedAuthority 리스트로 변환
        this.authorities = authoritiesList.stream()
                .map(auth -> new SimpleGrantedAuthority(auth.getAuthority()))
                .collect(Collectors.toList());
    }
}
```

---

### MyUserDetails 코드 분석

**필드 역할 분류**:

| 필드 | 필수/추가 | 역할 | 출처 |
|-----|----------|------|------|
| **username** | 필수 | 로그인 ID | `user.getEmail()` |
| **password** | 필수 | 암호화된 비밀번호 | `user.getPassword()` |
| **authorities** | 필수 | 권한 목록 | `authoritiesList` 변환 |
| **displayName** | 추가 | 화면 표시용 이름 | `user.getName()` |
| **userId** | 추가 | DB 기본 키 | `user.getId()` |

---

**username을 email로 설정한 이유**:

```java
this.username = user.getEmail();
```

| 이유 | 설명 |
|-----|------|
| **고유성 보장** | 이메일은 중복되지 않음 |
| **동명이인 문제 해결** | 이름은 중복 가능 |
| **실무 관례** | 대부분의 서비스가 이메일 로그인 사용 |

**핵심**: username은 "사용자 이름"이 아니라 "로그인 ID"를 의미!

---

**authorities 변환 과정**:

```java
this.authorities = authoritiesList.stream()
    .map(auth -> new SimpleGrantedAuthority(auth.getAuthority()))
    .collect(Collectors.toList());
```

**단계별 분석**:

```
1. authoritiesList (List<Authorities>)
   [
       Authorities { authority: "ROLE_USER", user: ... },
       Authorities { authority: "ROLE_ADMIN", user: ... }
   ]
    ↓
2. stream() - 스트림 변환
    ↓
3. map() - 각 요소 변환
   Authorities → SimpleGrantedAuthority
    ↓
4. collect() - 리스트로 수집
   List<SimpleGrantedAuthority>
   [
       SimpleGrantedAuthority("ROLE_USER"),
       SimpleGrantedAuthority("ROLE_ADMIN")
   ]
```

**핵심**: 
- JPA 엔티티(Authorities)를 스프링 시큐리티 객체(SimpleGrantedAuthority)로 변환
- getAuthorities() 메서드가 자동으로 이 필드를 반환

---

### Lombok의 역할

**@Data 어노테이션의 효과**:

```java
@Data
public class MyUserDetails implements UserDetails {
    private String username;
    private String password;
    private List<SimpleGrantedAuthority> authorities;
}
```

**자동 생성되는 메서드**:

| 메서드 | 역할 |
|-------|------|
| `getUsername()` | UserDetails 인터페이스 구현 |
| `getPassword()` | UserDetails 인터페이스 구현 |
| `getAuthorities()` | UserDetails 인터페이스 구현 |

**핵심**: 
- 필드명을 정확히 지정하면 Lombok이 인터페이스 메서드를 자동 구현
- 직접 오버라이드할 필요 없음

---

### 커스텀 UserDetailsService 구현

**SecurityConfiguration.java**:

```java
@Configuration
public class SecurityConfiguration {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
    public UserDetailsService userDetailsService(
            AuthoritiesRepository authoritiesRepository, 
            UserRepository userRepository) {
        
        return new UserDetailsService() {
            @Override
            public UserDetails loadUserByUsername(String username) 
                    throws UsernameNotFoundException {
                
                // 1. 이메일로 사용자 조회
                User user = userRepository.findByEmail(username);
                
                // 2. 사용자 존재 확인
                if (user == null) {
                    throw new UsernameNotFoundException(
                        "사용자를 찾을 수 없습니다: " + username
                    );
                }
                
                // 3. 사용자의 권한 목록 조회
                List<Authorities> authorities = 
                    authoritiesRepository.findByUser(user);
                
                // 4. MyUserDetails 객체 생성 및 반환
                return new MyUserDetails(user, authorities);
            }
        };
    }
}
```

---

### 코드 상세 분석

**익명 클래스 사용**:

```java
return new UserDetailsService() {
    @Override
    public UserDetails loadUserByUsername(String username) {
        // 구현
    }
};
```

**이유**: 
- UserDetailsService는 메서드가 하나뿐인 인터페이스
- 간단한 구현이므로 익명 클래스 사용

---

**의존성 주입**:

```java
public UserDetailsService userDetailsService(
    AuthoritiesRepository authoritiesRepository, 
    UserRepository userRepository)
```

| 매개변수 | 역할 |
|---------|------|
| **UserRepository** | 사용자 정보 조회 |
| **AuthoritiesRepository** | 권한 정보 조회 |

**스프링의 자동 주입**: 
- @Repository 빈들을 자동으로 주입
- 개발자는 사용만 하면 됨

---

**로그인 처리 과정**:

```
1. 사용자 로그인 시도
   ID: hyechang@spring.ac.kr
   PW: password
    ↓
2. loadUserByUsername("hyechang@spring.ac.kr") 호출
    ↓
3. userRepository.findByEmail("hyechang@spring.ac.kr")
   SELECT * FROM user WHERE email = ?
    ↓
4. User 엔티티 조회
   { id: 1, name: "홍혜창", email: "hyechang@...", password: "{bcrypt}..." }
    ↓
5. authoritiesRepository.findByUser(user)
   SELECT * FROM authorities WHERE user_id = ?
    ↓
6. Authorities 리스트 조회
   [ { authority: "ROLE_USER" }, { authority: "ROLE_ADMIN" } ]
    ↓
7. new MyUserDetails(user, authorities)
   username: hyechang@spring.ac.kr
   password: {bcrypt}$2a$10$...
   authorities: [ROLE_USER, ROLE_ADMIN]
   displayName: 홍혜창
   userId: 1
    ↓
8. UserDetails 반환
    ↓
9. 스프링 시큐리티가 비밀번호 검증
    ↓
10. 인증 성공 → SecurityContext 저장
```

---

### 커스텀 구현의 장점

**유연성**:

| 항목 | 표준 방식 | 커스텀 구현 |
|-----|----------|-----------|
| **테이블 구조** | 고정 | 자유 |
| **ORM 사용** | 불가 | 가능 (JPA) |
| **추가 필드** | 제한적 | 무제한 |
| **비즈니스 로직** | 불가능 | 자유롭게 추가 |

**실무 활용 예시**:

```java
@Override
public UserDetails loadUserByUsername(String username) {
    User user = userRepository.findByEmail(username);
    
    // 커스텀 로직 추가 가능
    if (user.getLastPasswordChangeDate().isBefore(sixMonthsAgo)) {
        throw new CredentialsExpiredException("비밀번호를 변경해주세요");
    }
    
    // 로그 기록
    log.info("로그인 시도: {}", username);
    
    // 복잡한 권한 로직
    List<Authorities> authorities = calculateAuthorities(user);
    
    return new MyUserDetails(user, authorities);
}
```

---

## 5.3.10 핵심 정리

### 스프링 시큐리티 인증 메커니즘

**핵심 개념**:

| 개념 | 역할 | 구현 |
|-----|------|------|
| **UserDetails** | 사용자 정보 모델 | 인터페이스 구현 필요 |
| **UserDetailsService** | 사용자 조회 서비스 | `loadUserByUsername()` 구현 |
| **PasswordEncoder** | 비밀번호 암호화/검증 | BCryptPasswordEncoder 사용 |

---

### 세 가지 구현 방식 비교

| 방식 | 저장소 | 장점 | 단점 | 사용 시기 |
|-----|--------|------|------|----------|
| **메모리 기반** | 애플리케이션 메모리 | 빠름, 간단 | 휘발성, 확장 불가 | 개발/테스트 |
| **JDBC 기반** | DB (표준 스키마) | 영속성, 간단 설정 | 스키마 고정 | 간단한 프로젝트 |
| **커스텀 구현** | DB (자유 스키마) | 최대 유연성 | 구현 복잡도 높음 | 실무 프로젝트 |

---

### 인증 과정 4단계 요약

```
1. 사용자 정보 조회
   └─ UserDetailsService.loadUserByUsername()
       └─ UserDetails 반환

2. 비밀번호 검증
   └─ PasswordEncoder.matches()
       └─ true/false 반환

3. 계정 상태 확인
   └─ isEnabled(), isAccountNonLocked() 등
       └─ 모두 true여야 함

4. 인증 성공 처리
   └─ SecurityContext에 저장
       └─ 세션에 보관
```

---

### PasswordEncoder의 중요성

**두 가지 사용 시점**:

| 시점 | 메서드 | 주체 | 목적 |
|-----|--------|------|------|
| **회원가입** | `encode()` | 애플리케이션 | 평문을 암호화하여 DB 저장 |
| **로그인** | `matches()` | 스프링 시큐리티 | 입력 비밀번호와 저장된 해시 비교 |

**핵심**: 
- 동일한 PasswordEncoder 빈을 두 시점에서 사용
- 일관성 보장이 중요

---

### 실무 권장 사항

**인증 구현 선택**:

```
프로젝트 초기/프로토타입:
    └─ 메모리 기반 (빠른 검증)

표준 스키마 사용 가능:
    └─ JDBC 기반 (간단한 설정)

실제 서비스:
    └─ 커스텀 구현 (최대 유연성)
```

---

**보안 체크리스트**:

| 항목 | 권장 사항 |
|-----|----------|
| **비밀번호 암호화** | BCryptPasswordEncoder 사용 |
| **{noop} 사용** | 개발 환경에서만, 운영 금지 |
| **세션 공유** | spring-session-jdbc 사용 |
| **HTTPS** | 운영 환경 필수 |
| **비밀번호 정책** | 최소 8자, 특수문자 포함 등 |

---

### 자주 하는 실수

**1. UserDetails 필드명 오류**:

```java
// ❌ 잘못됨
private String userId;  // getUsername() 구현 안 됨

// ✅ 올바름
private String username;  // getUsername() 자동 구현
```

---

**2. PasswordEncoder 빈 미등록**:

```
에러: No PasswordEncoder mapped for id "null"

해결: @Bean으로 PasswordEncoder 등록 필수
```

---

**3. 이메일을 username으로 사용 시 Repository 메서드 오류**:

```java
// ❌ 잘못됨
User findByUsername(String username);  // username 필드가 없음

// ✅ 올바름
User findByEmail(String email);  // 실제 필드명 사용
```

---

**4. authorities를 List<String>으로 저장**:

```java
// ❌ 잘못됨
private List<String> authorities;  // GrantedAuthority 타입이 아님

// ✅ 올바름
private List<SimpleGrantedAuthority> authorities;
```

---

**결론**: 

스프링 시큐리티의 인증 시스템은 UserDetailsService와 UserDetails라는 **두 가지 핵심 인터페이스**를 중심으로 작동합니다. 

메모리 기반, JDBC 기반, 커스텀 구현이라는 **세 가지 방식**을 통해 프로젝트 요구사항에 맞는 인증 시스템을 구축할 수 있으며, 실무에서는 **커스텀 구현 방식**이 가장 많이 사용됩니다.

PasswordEncoder를 통한 안전한 비밀번호 관리와 세션 기반 인증 메커니즘을 이해하면, 견고하고 확장 가능한 보안 시스템을 구축할 수 있습니다.





# 5.3.11 인가(Authorization)와 접근 제어

## 5.3.11.1 인증(Authentication)과 인가(Authorization)의 차이

지금까지 우리는 **인증(Authentication)** 과정, 즉 "사용자가 누구인지 확인하는 과정"을 학습했습니다. UserDetails와 UserDetailsService를 통해 로그인 기능을 구현하는 방법을 배웠습니다.

이제부터는 **인가(Authorization)**, 즉 "인증된 사용자가 무엇을 할 수 있는지 결정하는 과정"을 학습합니다.

**개념 비교**:

| 개념 | 영문 | 질문 | 예시 | 처리 시점 |
|-----|------|------|------|----------|
| **인증** | Authentication | "당신은 누구인가?" | 로그인 (ID/비밀번호 확인) | 로그인 시 |
| **인가** | Authorization | "당신은 무엇을 할 수 있는가?" | 관리자만 회원 목록 조회 가능 | 요청마다 |

**핵심**: 
- 인증은 **한 번** (로그인 시)
- 인가는 **매 요청마다** (URL 접근 시마다)

---

## 5.3.11.2 URL 기반 접근 제어의 3가지 범주

Spring Security는 URL 요청이 들어왔을 때 **세 가지 범주** 중 하나를 적용하여 접근을 허용하거나 거부합니다.

### 1. 🟢 인증 없이 접근 가능 (Public Access)

| 설명 | Spring Security 함수 |
|-----|---------------------|
| 로그인 여부와 상관없이 누구나 접근 가능 | `permitAll()` |

**예시 페이지**:
- 메인 페이지: `/`
- 로그인 페이지: `/login`
- 회원가입 페이지: `/signup`

---

### 2. 🟡 인증 필수, 권한 불필요 (Authenticated Access)

| 설명 | Spring Security 함수 |
|-----|---------------------|
| 로그인만 성공했다면 권한과 관계없이 접근 가능 | `authenticated()` |

**예시 페이지**:
- 마이 페이지: `/mypage`
- 개인 설정: `/settings`

---

### 3. 🔴 인증 필수, 권한 확인 (Authorized Access)

| 설명 | Spring Security 함수 |
|-----|---------------------|
| 로그인 + 특정 권한 보유 시에만 접근 가능 | `hasRole()`, `hasAuthority()`, `hasAnyRole()`, `hasAnyAuthority()` |

**예시 페이지**:
- 관리자 대시보드: `/admin/**`
- 회원 목록 조회: `/member/list`
- 데이터 삭제 기능: `/data/delete`

---

## 5.3.11.3 HttpSecurity와 SecurityFilterChain

### SecurityFilterChain이란?

**정의**: HTTP 요청을 처리할 보안 필터들의 **집합(체인)**을 정의하는 인터페이스

**역할**:

| 개념 | 역할 |
|-----|------|
| **SecurityFilterChain** | 최종 목표 (인터페이스) |
| **HttpSecurity** | 설정 빌더 (클래스) |

---

### HttpSecurity의 역할

**HttpSecurity**는 SecurityFilterChain 객체를 **생성(Build)**하기 위한 설정 도구입니다.

**빌더 패턴**:

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(...)  // 접근 제어 설정
        .formLogin(...)               // 로그인 설정
        .logout(...);                 // 로그아웃 설정
    
    return http.build();  // SecurityFilterChain 객체 생성
}
```

**동작 방식**:

```
1. HttpSecurity 객체 주입 (Spring이 자동으로)
    ↓
2. 체인 형식으로 설정 추가
   .authorizeHttpRequests()
   .formLogin()
   .logout()
    ↓
3. .build() 메서드 호출
    ↓
4. SecurityFilterChain 인터페이스를 구현한 객체 생성 및 반환
    ↓
5. Spring Security가 이 빈을 사용하여 모든 요청 처리
```

**핵심**: 
- HttpSecurity는 **빌더(Builder)**
- SecurityFilterChain은 **최종 결과물**

---

## 5.3.11.4 authorizeHttpRequests()를 통한 접근 제어

### 기본 구조

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(
            auth -> {
                auth.requestMatchers("/", "/home").permitAll()
                    .requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")
                    .anyRequest().authenticated();
            }
        );
    
    return http.build();
}
```

---

### authorizeHttpRequests() 분석

**메서드 시그니처**:

```java
authorizeHttpRequests(Customizer<AuthorizeHttpRequestsConfigurer> customizer)
```

**람다식의 매개변수 auth**:

| 항목 | 설명 |
|-----|------|
| **타입** | `AuthorizationManagerRequestMatcherRegistry` |
| **역할** | URL 패턴과 권한 규칙을 정의하는 빌더 객체 |
| **생성 시점** | 빈 생성 시 Spring Security가 자동 제공 |
| **사용 시점** | 애플리케이션 시작 시 한 번 (요청마다가 아님!) |

---

### 접근 제어 규칙 정의

**기본 형태**:

```
auth.requestMatchers(URL패턴).권한함수()
```

**예시**:

| 코드 | URL 패턴 | 권한 규칙 | 의미 |
|-----|---------|----------|------|
| `.requestMatchers("/", "/home").permitAll()` | `/`, `/home` | 모두 접근 가능 | 인증 불필요 |
| `.requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")` | `/member/**` | ADMIN 권한 필요 | 인증 + 권한 확인 |
| `.anyRequest().authenticated()` | 위에 정의하지 않은 모든 경로 | 로그인만 필요 | 인증 필수 |

---

## 5.3.11.5 requestMatchers와 anyRequest

### requestMatchers()

**정의**: 특정 URL 패턴에 대한 접근 규칙을 정의

**사용 형태**:

```java
// 단일 경로
.requestMatchers("/admin")

// 여러 경로
.requestMatchers("/", "/home", "/about")

// 와일드카드 사용
.requestMatchers("/member/**")

// HTTP 메서드 지정
.requestMatchers(HttpMethod.GET, "/api/**")
```

---

### URL 패턴 매칭: * vs **

**와일드카드 비교**:

| 패턴 | 의미 | 예시 | 일치하는 URL | 일치하지 않는 URL |
|-----|------|------|------------|----------------|
| **`*`** (Single Wildcard) | 1단계 하위 경로만 | `/member/*` | `/member/profile`<br>`/member/settings` | `/member/admin/users`<br>`/member/` |
| **`**`** (Double Wildcard) | 모든 하위 경로 | `/member/**` | `/member/profile`<br>`/member/admin/users`<br>`/member/a/b/c` | (없음) |

**핵심**: 
- `*`: 경로 구분자(`/`)를 포함하지 않는 한 단계만
- `**`: 경로 구분자를 포함한 모든 하위 경로

---

### anyRequest()

**정의**: 위에 정의되지 않은 **모든 나머지 요청**을 포괄적으로 매칭

**중요한 원칙**:

| 원칙 | 설명 |
|-----|------|
| **순서** | 반드시 **가장 마지막**에 위치 |
| **이유** | 앞에 오면 모든 요청을 가로채서 뒤의 규칙 무시 |

**잘못된 예시**:

```java
// ❌ 잘못된 순서
auth.anyRequest().authenticated()  // 모든 요청 먼저 매칭
    .requestMatchers("/", "/home").permitAll();  // 이 규칙은 무시됨!
```

**올바른 예시**:

```java
// ✅ 올바른 순서
auth.requestMatchers("/", "/home").permitAll()
    .requestMatchers("/admin/**").hasAuthority("ROLE_ADMIN")
    .anyRequest().authenticated();  // 마지막에 위치
```

---

### 규칙 검사 순서

**처리 과정**:

```
요청: /member/list
    ↓
1. /나 /home에 일치? NO
    ↓
2. /member/**에 일치? YES
    ↓
3. hasAuthority("ROLE_ADMIN") 검사
    ↓
4. 권한 있음 → 허용
   권한 없음 → 403 Forbidden
```

**핵심**: 
- 규칙은 **선언 순서대로** 검사
- **가장 먼저 일치**하는 규칙 적용
- 일치하는 규칙이 없으면 `anyRequest()` 적용

---

## 5.3.11.6 권한 검사 함수

### permitAll()

**정의**: 인증 없이 모든 사용자 접근 가능

```java
.requestMatchers("/", "/home").permitAll()
```

**사용 시기**:
- 메인 페이지
- 로그인/회원가입 페이지
- 공지사항, FAQ 등

---

### authenticated()

**정의**: 로그인만 성공하면 권한과 관계없이 접근 가능

```java
.anyRequest().authenticated()
```

**사용 시기**:
- 마이 페이지
- 개인 설정
- 일반적인 내부 페이지

---

### hasAuthority() (직접 비교)

**정의**: 지정된 **권한 문자열 그대로** 사용자의 권한 목록과 비교

```java
.requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")
```

**비교 방식**:

```
사용자 권한: ["ROLE_USER", "ROLE_ADMIN"]
    ↓
hasAuthority("ROLE_ADMIN") 검사
    ↓
"ROLE_ADMIN" 문자열이 권한 목록에 있는가?
    ↓
있음 → 접근 허용
없음 → 403 Forbidden
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **비교 방식** | 완전히 일치해야 함 (정확한 문자열 비교) |
| **접두사** | 자동으로 추가하지 않음 |
| **저장된 권한** | DB의 `authorities` 테이블에 저장된 값 그대로 |

---

### hasRole() (접두사 자동 추가)

**정의**: `ROLE_` 접두사를 **자동으로 추가**하여 비교

```java
.requestMatchers("/admin/**").hasRole("ADMIN")
```

**내부 작동**:

```
hasRole("ADMIN") 호출
    ↓
내부적으로 "ROLE_" 접두사 추가
    ↓
실제 비교: hasAuthority("ROLE_ADMIN")
```

**비교 표**:

| 코드 | 실제 비교 문자열 | 결과 |
|-----|----------------|------|
| `hasRole("ADMIN")` | `"ROLE_ADMIN"` | 사용자가 `"ROLE_ADMIN"` 보유 시 허용 |
| `hasRole("USER")` | `"ROLE_USER"` | 사용자가 `"ROLE_USER"` 보유 시 허용 |

**주의사항**: 
- DB에 저장된 권한이 `"ROLE_USER"` 형식이어야 함
- `hasRole("USER")`를 사용하려면 DB에 `"ROLE_USER"`로 저장되어 있어야 함

---

### hasAuthority vs hasRole 비교

| 구분 | hasAuthority | hasRole |
|-----|-------------|---------|
| **문법** | `hasAuthority("ROLE_ADMIN")` | `hasRole("ADMIN")` |
| **접두사 처리** | 직접 작성 | 자동 추가 (`ROLE_`) |
| **DB 저장 형식** | 자유 (권장: `ROLE_` 포함) | 반드시 `ROLE_` 포함 |
| **유연성** | 높음 (커스텀 권한 가능) | 낮음 (역할 기반만) |
| **권장 사용** | 실무 권장 | 간단한 프로젝트 |

**동일한 결과**:

```java
// 두 코드는 완전히 동일하게 작동
.hasAuthority("ROLE_ADMIN")
.hasRole("ADMIN")
```

---

### hasAnyAuthority() (다중 권한 OR 조건)

**정의**: 여러 권한 중 **하나라도** 가지고 있으면 접근 허용

```java
.requestMatchers("/board/**").hasAnyAuthority("ROLE_ADMIN", "ROLE_MANAGER")
```

**작동 방식**:

```
사용자 권한: ["ROLE_USER", "ROLE_MANAGER"]
    ↓
hasAnyAuthority("ROLE_ADMIN", "ROLE_MANAGER") 검사
    ↓
"ROLE_ADMIN" 있는가? NO
"ROLE_MANAGER" 있는가? YES
    ↓
하나라도 일치 → 접근 허용
```

**사용 시기**:
- 여러 역할이 동일한 기능에 접근해야 할 때
- 관리자와 매니저 모두 게시판 관리 가능

---

### hasAnyRole() (다중 역할 OR 조건)

**정의**: 여러 역할 중 **하나라도** 가지고 있으면 접근 허용 (자동 접두사 추가)

```java
.requestMatchers("/board/**").hasAnyRole("ADMIN", "MANAGER")
```

**내부 작동**:

```
hasAnyRole("ADMIN", "MANAGER") 호출
    ↓
내부적으로 접두사 추가
    ↓
실제 비교: hasAnyAuthority("ROLE_ADMIN", "ROLE_MANAGER")
```

---

### 권한 검사 함수 총정리

| 함수 | 접두사 | 조건 | 사용 예시 |
|-----|--------|------|----------|
| **hasAuthority("권한")** | 직접 작성 | 단일 권한 | `hasAuthority("ROLE_ADMIN")` |
| **hasRole("역할")** | 자동 추가 | 단일 역할 | `hasRole("ADMIN")` |
| **hasAnyAuthority("권한1", "권한2")** | 직접 작성 | 다중 권한 (OR) | `hasAnyAuthority("ROLE_ADMIN", "ROLE_MANAGER")` |
| **hasAnyRole("역할1", "역할2")** | 자동 추가 | 다중 역할 (OR) | `hasAnyRole("ADMIN", "MANAGER")` |

---

## 5.3.11.7 권한 확인 과정

### UserDetails의 권한 정보

**질문**: Spring Security는 사용자의 권한을 어디서 가져올까?

**답변**: **UserDetails 인터페이스의 `getAuthorities()` 메서드**

**UserDetails 인터페이스**:

```java
public interface UserDetails {
    Collection<? extends GrantedAuthority> getAuthorities();
    String getPassword();
    String getUsername();
    // ...
}
```

---

### 권한 확인 흐름

**전체 과정**:

```
1. 사용자 로그인 성공
    ↓
2. UserDetailsService.loadUserByUsername() 호출
    ↓
3. DB에서 사용자 정보 + 권한 정보 조회
    ↓
4. MyUserDetails 객체 생성
   - username: "hyechang@spring.ac.kr"
   - password: "{bcrypt}$2a$10$..."
   - authorities: [ROLE_USER, ROLE_ADMIN]
    ↓
5. Authentication 객체에 담김
    ↓
6. SecurityContext에 저장
    ↓
7. 세션에 보관
    ↓
8. 이후 요청 시 권한 확인
    ↓
9. SecurityContext에서 Authentication 가져오기
    ↓
10. Authentication.getAuthorities() 호출
    ↓
11. 반환된 권한 목록과 hasAuthority() 비교
    ↓
12. 일치 여부에 따라 접근 허용/거부
```

---

### 코드로 확인

**MyUserDetails 클래스**:

```java
@Data
public class MyUserDetails implements UserDetails {
    private String username;
    private String password;
    private List<SimpleGrantedAuthority> authorities;  // 권한 목록
    
    public MyUserDetails(User user, List<Authorities> authoritiesList) {
        this.username = user.getEmail();
        this.password = user.getPassword();
        
        // Authorities 엔티티를 SimpleGrantedAuthority로 변환
        this.authorities = authoritiesList.stream()
                .map(auth -> new SimpleGrantedAuthority(auth.getAuthority()))
                .collect(Collectors.toList());
    }
}
```

**권한 변환 과정**:

```
DB: authorities 테이블
[
    { authority: "ROLE_USER" },
    { authority: "ROLE_ADMIN" }
]
    ↓
Stream 변환
    ↓
SimpleGrantedAuthority 객체로 변환
[
    SimpleGrantedAuthority("ROLE_USER"),
    SimpleGrantedAuthority("ROLE_ADMIN")
]
    ↓
MyUserDetails의 authorities 필드에 저장
    ↓
getAuthorities() 메서드가 자동으로 반환
```

---

### 실제 권한 확인

**요청 예시**:

```
요청: GET /member/list
    ↓
SecurityFilterChain 규칙 확인
.requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")
    ↓
SecurityContext에서 Authentication 가져오기
    ↓
Authentication.getAuthorities() 호출
반환: [ROLE_USER, ROLE_ADMIN]
    ↓
"ROLE_ADMIN"이 목록에 있는가?
    ↓
YES → 접근 허용
NO → 403 Forbidden
```

**핵심**: 
- 권한 확인은 **매 요청마다** 발생
- UserDetails에 저장된 권한 목록 사용
- 권한이 없으면 자동으로 거부

---

## 5.3.11.8 접근 제어 실무 예제

### 완전한 SecurityConfiguration

```java
@Configuration
public class SecurityConfiguration {
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(
                auth -> {
                    // 1. 인증 없이 접근 가능
                    auth.requestMatchers("/", "/home").permitAll()
                        
                        // 2. 관리자만 접근 가능
                        .requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")
                        
                        // 3. 나머지는 로그인 필요
                        .anyRequest().authenticated();
                }
            )
            .formLogin(Customizer.withDefaults())
            .logout(Customizer.withDefaults());
        
        return http.build();
    }
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

### 접근 제어 시나리오

**시나리오 1: 비로그인 사용자**

```
요청: GET /
    ↓
규칙 확인: .requestMatchers("/", "/home").permitAll()
    ↓
결과: 접근 허용 (인증 불필요)
```

---

**시나리오 2: 일반 사용자 (ROLE_USER만 보유)**

```
요청: GET /member/list
    ↓
규칙 확인: .requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")
    ↓
권한 확인: 사용자 권한 = [ROLE_USER]
    ↓
"ROLE_ADMIN" 없음
    ↓
결과: 403 Forbidden
```

---

**시나리오 3: 관리자 (ROLE_ADMIN 보유)**

```
요청: GET /member/list
    ↓
규칙 확인: .requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")
    ↓
권한 확인: 사용자 권한 = [ROLE_USER, ROLE_ADMIN]
    ↓
"ROLE_ADMIN" 있음
    ↓
결과: 접근 허용
```

---

### 실무 권장 패턴

**계층적 URL 구조**:

```java
auth
    // Public (인증 불필요)
    .requestMatchers("/", "/home", "/about").permitAll()
    .requestMatchers("/api/public/**").permitAll()
    
    // Admin (관리자 전용)
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .requestMatchers("/member/**").hasRole("ADMIN")
    
    // Manager (관리자 또는 매니저)
    .requestMatchers("/board/manage/**").hasAnyRole("ADMIN", "MANAGER")
    
    // Authenticated (로그인 사용자)
    .requestMatchers("/mypage/**").authenticated()
    .requestMatchers("/api/user/**").authenticated()
    
    // Default
    .anyRequest().authenticated();
```

**핵심 원칙**:
1. 구체적인 경로를 먼저 정의
2. 넓은 범위는 나중에 정의
3. `anyRequest()`는 항상 마지막

---

## 5.3.11.9 핵심 정리

### 인가(Authorization) 요약

| 개념 | 설명 |
|-----|------|
| **목적** | 인증된 사용자가 특정 리소스에 접근 가능한지 결정 |
| **확인 시점** | 매 요청마다 |
| **확인 대상** | UserDetails의 `getAuthorities()` 반환 값 |
| **설정 위치** | `HttpSecurity.authorizeHttpRequests()` |

---

### URL 접근 제어 3단계

| 범주 | 함수 | 설명 |
|-----|------|------|
| **1. Public** | `permitAll()` | 인증 불필요 |
| **2. Authenticated** | `authenticated()` | 로그인만 필요 |
| **3. Authorized** | `hasRole()`, `hasAuthority()` | 로그인 + 권한 필요 |

---

### 권한 검사 함수 요약

| 함수 | 접두사 | 조건 | 사용 예시 |
|-----|--------|------|----------|
| `hasAuthority()` | 직접 작성 | 단일 | `hasAuthority("ROLE_ADMIN")` |
| `hasRole()` | 자동 (`ROLE_`) | 단일 | `hasRole("ADMIN")` |
| `hasAnyAuthority()` | 직접 작성 | 다중 (OR) | `hasAnyAuthority("ROLE_ADMIN", "ROLE_MANAGER")` |
| `hasAnyRole()` | 자동 (`ROLE_`) | 다중 (OR) | `hasAnyRole("ADMIN", "MANAGER")` |

---

### 중요한 원칙

**1. 순서가 중요**:
```java
// ✅ 구체적 → 일반적
.requestMatchers("/admin/**").hasRole("ADMIN")
.anyRequest().authenticated()

// ❌ 일반적 → 구체적 (뒤의 규칙 무시됨)
.anyRequest().authenticated()
.requestMatchers("/admin/**").hasRole("ADMIN")
```

---

**2. anyRequest()는 마지막**:
```java
// ✅ 올바른 위치
.requestMatchers("/", "/home").permitAll()
.anyRequest().authenticated()

// ❌ 잘못된 위치
.anyRequest().authenticated()
.requestMatchers("/", "/home").permitAll()
```

---

**3. 권한은 UserDetails에서**:
- Spring Security는 `UserDetails.getAuthorities()` 호출
- 반환된 권한 목록과 비교
- DB에 저장된 권한 문자열이 정확해야 함

---

# 5.3.12 로그인 사용자 정보 사용

## 5.3.12.1 세션에 저장된 인증 정보

### SecurityContext의 저장 위치

**로그인 성공 후 저장 구조**:

```
HTTP Session (서버 메모리 또는 DB)
    └── SecurityContext
            └── Authentication
                    ├── UserDetails (Principal)
                    │       ├── username
                    │       ├── password
                    │       └── authorities
                    └── authenticated: true
```

**핵심**: 
- **HTTP 세션**에 SecurityContext 저장
- **SecurityContext** 안에 Authentication 저장
- **Authentication** 안에 UserDetails (Principal) 저장

---

### 왜 UserDetails를 웹에서 사용해야 하는가?

**지금까지의 역할**:
1. 로그인 시: UserDetailsService가 DB에서 조회하여 반환
2. 권한 확인: `getAuthorities()`로 권한 목록 제공

**추가로 필요한 역할**:
3. 화면 출력: 현재 로그인한 사용자 이름 표시
4. 비즈니스 로직: 작성자 ID 기록, 본인 확인 등

**필요한 정보 예시**:

| 사용 목적 | 필요한 정보 | 예시 |
|---------|-----------|------|
| **화면 출력** | 사용자 이름 | "안녕하세요, 홍길동 님!" |
| **게시물 작성** | 사용자 ID | `writer_id = 현재 로그인한 사용자 ID` |
| **본인 확인** | 사용자 ID | "이 게시물의 작성자만 수정 가능" |

**핵심**: UserDetails는 **인증/인가뿐만 아니라 애플리케이션 전반에서 활용**되어야 합니다!

---

## 5.3.12.2 컨트롤러에서 로그인 사용자 정보 획득

### @AuthenticationPrincipal 어노테이션

**정의**: SecurityContext에 저장된 UserDetails를 컨트롤러 메서드에 자동으로 주입받는 어노테이션

**기본 사용법**:

```java
@GetMapping("/home")
public String home(@AuthenticationPrincipal UserDetails userDetails) {
    log.info("userDetails={}", userDetails);
    return "home";
}
```

---

### 작동 원리

**전체 흐름**:

```
1. 클라이언트 요청 (쿠키에 세션ID 포함)
    ↓
2. Spring Security 필터 체인 작동
    ↓
3. 세션 ID로 HTTP 세션 조회
    ↓
4. 세션에서 SecurityContext 로드
    ↓
5. SecurityContext에서 Authentication 추출
    ↓
6. Authentication.getPrincipal() 호출
    ↓
7. UserDetails 객체 반환
    ↓
8. @AuthenticationPrincipal이 메서드 매개변수에 주입
    ↓
9. 컨트롤러 메서드 실행
```

**핵심**: 
- Spring이 자동으로 처리
- 개발자는 매개변수만 선언하면 됨
- **로그인 상태에서만 UserDetails가 주입됨**

---

### 로그인 여부에 따른 동작

**케이스 1: 로그인한 사용자**

```java
@GetMapping("/home")
public String home(@AuthenticationPrincipal UserDetails userDetails, Model model) {
    if (userDetails != null) {
        // UserDetails가 주입됨
        log.info("로그인 사용자: {}", userDetails.getUsername());
        model.addAttribute("message", userDetails.getUsername() + "님 환영합니다!");
    }
    return "home";
}
```

**결과**:
```
로그인 사용자: hyechang@spring.ac.kr
화면 출력: hyechang@spring.ac.kr님 환영합니다!
```

---

**케이스 2: 비로그인 사용자**

```java
@GetMapping("/home")
public String home(@AuthenticationPrincipal UserDetails userDetails, Model model) {
    if (userDetails == null) {
        // UserDetails가 null
        log.info("비로그인 사용자");
        model.addAttribute("message", "로그인해 주세요.");
    }
    return "home";
}
```

**결과**:
```
비로그인 사용자
화면 출력: 로그인해 주세요.
```

---

### 커스텀 UserDetails 사용

**MyUserDetails 활용**:

```java
@GetMapping("/home")
public String home(@AuthenticationPrincipal MyUserDetails myUserDetails, Model model) {
    if (myUserDetails != null) {
        // MyUserDetails의 추가 필드 접근 가능
        log.info("사용자 이름: {}", myUserDetails.getDisplayName());
        log.info("사용자 ID: {}", myUserDetails.getUserId());
        
        model.addAttribute("displayName", myUserDetails.getDisplayName());
        model.addAttribute("userId", myUserDetails.getUserId());
    }
    return "home";
}
```

**MyUserDetails 구조**:

```java
@Data
public class MyUserDetails implements UserDetails {
    private String username;          // 필수
    private String password;          // 필수
    private List<SimpleGrantedAuthority> authorities;  // 필수
    
    // 커스텀 필드
    private String displayName;       // 화면 표시용 이름
    private Long userId;              // DB 기본 키
}
```

**장점**:
- DB에서 조회한 모든 정보 활용 가능
- 추가 DB 조회 불필요

---

### @AuthenticationPrincipal 사용 시 주의사항

**경로 접근 제어와의 관계**:

**문제 상황**:

```java
@Configuration
public class SecurityConfiguration {
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .authorizeHttpRequests(
                auth -> {
                    auth.requestMatchers("/home").permitAll()  // ⚠️ 주의!
                        .anyRequest().authenticated();
                }
            );
        return http.build();
    }
}
```

```java
@GetMapping("/home")
public String home(@AuthenticationPrincipal UserDetails userDetails) {
    // userDetails는 null일 수 있음!
    log.info("userDetails={}", userDetails);
    return "home";
}
```

**문제점**:
- `/home`은 `permitAll()`로 설정 → 비로그인 사용자도 접근 가능
- 비로그인 사용자의 경우 `userDetails`는 `null`
- `userDetails.getUsername()` 호출 시 `NullPointerException` 발생

---

**해결 방법 1: null 체크**

```java
@GetMapping("/home")
public String home(@AuthenticationPrincipal UserDetails userDetails, Model model) {
    if (userDetails != null) {
        // 로그인 사용자
        model.addAttribute("message", userDetails.getUsername() + "님 환영합니다!");
    } else {
        // 비로그인 사용자
        model.addAttribute("message", "로그인해 주세요.");
    }
    return "home";
}
```

---

**해결 방법 2: 인증 필수로 변경**

```java
auth.requestMatchers("/home").authenticated()  // ✅ 로그인 필수
```

**권장 사항**:

| 상황 | 권장 방법 |
|-----|----------|
| **로그인/비로그인 모두 접근** | null 체크 필수 |
| **UserDetails 필수 사용** | `authenticated()` 설정 |

**핵심**: @AuthenticationPrincipal을 사용하는 경로는 **최소한 `authenticated()` 이상**으로 보호하거나 **null 체크**를 반드시 해야 합니다!

---

### Model에 담아 View로 전달

**일반적인 패턴**:

```java
@GetMapping("/mypage")
public String mypage(@AuthenticationPrincipal MyUserDetails myUserDetails, Model model) {
    // Model에 담기
    model.addAttribute("displayName", myUserDetails.getDisplayName());
    model.addAttribute("userId", myUserDetails.getUserId());
    model.addAttribute("email", myUserDetails.getUsername());
    
    return "mypage";
}
```

**View (Thymeleaf)**:

```html
<h1>마이 페이지</h1>
<p>이름: <span th:text="${displayName}"></span></p>
<p>이메일: <span th:text="${email}"></span></p>
<p>사용자 ID: <span th:text="${userId}"></span></p>
```

---

## 5.3.12.3 타임리프에서 로그인 사용자 정보 사용

### 의존성 추가

**build.gradle**:

```gradle
implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6'
```

**역할**: 타임리프에서 Spring Security 정보에 직접 접근할 수 있게 해주는 통합 라이브러리

---

### xmlns 네임스페이스 선언

**HTML 파일 상단**:

```html
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
```

**효과**: 
- `sec:authorize` 속성 사용 가능
- `sec:authentication` 속성 사용 가능

---

### 타임리프의 자동 접근 메커니즘

**핵심 원리**:

```
View 렌더링 시:
    ↓
Spring Security 모듈 개입
    ↓
현재 스레드의 SecurityContext 접근
    ↓
Authentication 객체 가져오기
    ↓
타임리프 내장 객체 #authentication에 자동 저장
    ↓
View에서 바로 사용 가능
```

**핵심**: 
- 컨트롤러에서 Model에 담지 않아도 됨
- View가 SecurityContext에 직접 접근
- `#authentication` 유틸리티 객체 자동 제공

---

### sec:authorize - 사용자 상태 확인

**정의**: 현재 사용자의 **인증 상태 및 권한**을 확인하여 조건부 렌더링

**기본 사용법**:

```html
<li sec:authorize="isAuthenticated()">
    로그인한 사용자만 보임
</li>

<li sec:authorize="isAnonymous()">
    비로그인 사용자만 보임
</li>
```

---

### sec:authorize 주요 함수

| 함수 | 의미 | 사용 시기 |
|-----|------|----------|
| **isAuthenticated()** | 로그인한 사용자인가? | 로그인 사용자에게만 표시 |
| **isAnonymous()** | 비로그인 사용자인가? | 로그인 유도 메시지 |
| **hasAuthority('권한')** | 특정 권한 보유? | 관리자 전용 메뉴 |
| **hasRole('역할')** | 특정 역할 보유? | 역할 기반 메뉴 |
| **hasAnyAuthority('권한1', '권한2')** | 여러 권한 중 하나? | 다중 권한 메뉴 |
| **hasAnyRole('역할1', '역할2')** | 여러 역할 중 하나? | 다중 역할 메뉴 |

---

### sec:authorize 실전 예제

**예제 HTML**:

```html
<ul>
    <!-- 비로그인 사용자 -->
    <li sec:authorize="isAnonymous()">
        손님 반갑습니다. 로그인부터 해주세요.
        <a th:href="@{/login}">로그인</a>
    </li>

    <!-- 로그인 사용자 -->
    <li sec:authorize="isAuthenticated()">
        <span sec:authentication="principal.displayName">이름</span> 님 반갑습니다.
    </li>

    <!-- ADMIN 권한 보유자 -->
    <li sec:authorize="hasAuthority('ROLE_ADMIN')">
        ADMIN 권한이 있으시군요
    </li>

    <!-- 로그인 사용자 메뉴 -->
    <li sec:authorize="isAuthenticated()">
        <a th:href="@{/product/list}">상품 목록</a>
    </li>
    
    <!-- 관리자 메뉴 -->
    <li sec:authorize="hasAuthority('ROLE_ADMIN')">
        <a th:href="@{/member/list}">회원 목록</a>
    </li>
</ul>
```

**실행 결과 (비로그인)**:

```
손님 반갑습니다. 로그인부터 해주세요.
로그인
```

**실행 결과 (일반 사용자 - ROLE_USER)**:

```
홍혜창 님 반갑습니다.
상품 목록
```

**실행 결과 (관리자 - ROLE_ADMIN)**:

```
김우현 님 반갑습니다.
ADMIN 권한이 있으시군요
상품 목록
회원 목록
```

---

### sec:authentication - 정보 접근 및 출력

**정의**: `#authentication` 객체의 정보를 **추출하여 출력**하는 속성

**기본 구조**:

```html
<span sec:authentication="경로">기본값</span>
```

---

### Authentication 객체 구조

**이해해야 할 구조**:

```
#authentication (Authentication 객체)
    ├── principal (UserDetails 객체)
    │       ├── username
    │       ├── password
    │       ├── authorities
    │       └── displayName (커스텀 필드)
    ├── name (username의 별칭)
    └── authenticated (boolean)
```

**핵심**: 
- `principal`은 **UserDetails 객체**를 가리킴
- UserDetails에 접근하려면 `principal` 경로 사용

---

### sec:authentication 사용 방법

**방법 1: principal을 통한 접근 (권장)**

```html
<span sec:authentication="principal.username">이메일</span>
<span sec:authentication="principal.displayName">이름</span>
```

**방법 2: name 속성 (간결한 방법)**

```html
<span sec:authentication="name">이메일</span>
```

**name의 작동 원리**:

```
sec:authentication="name"
    ↓
내부적으로 Authentication.getName() 호출
    ↓
getName()은 내부적으로 principal.getUsername() 호출
    ↓
결과: username (이메일) 반환
```

---

### principal 접근의 중요성

**왜 principal을 명시해야 하는가?**

```
Authentication 객체 구조:
    ├── principal (UserDetails) ← 여기에 사용자 정보가 있음
    └── credentials (비밀번호)
```

**principal 없이 접근하면**:

```html
<!-- ❌ 작동하지 않음 -->
<span sec:authentication="displayName">이름</span>
```

**principal과 함께 접근**:

```html
<!-- ✅ 올바른 방법 -->
<span sec:authentication="principal.displayName">이름</span>
```

**이유**: 
- `displayName`은 Authentication 객체의 직접 속성이 아님
- **UserDetails(principal) 안에 있는 속성**
- 따라서 `principal.displayName`으로 접근해야 함

---

### sec:authentication vs th:text 비교

**방법 1: sec:authentication (간결)**

```html
<span sec:authentication="principal.displayName">이름</span>
```

**방법 2: th:text + #authentication (명시적)**

```html
<span th:text="${#authentication.principal.displayName}">이름</span>
```

**차이점**:

| 방식 | # 사용 | 위치 | 특징 |
|-----|--------|------|------|
| **sec:authentication** | 불필요 | 속성 값 | 인증 정보 전용, 간결함 |
| **th:text="${#authentication...}"** | 필요 | 표현식 내부 | 범용성, 명시적 |

**핵심**: 
- `sec:authentication` 속성 자체가 `#authentication` 객체 접근을 내포
- 따라서 `#` 접두사 생략 가능

---

### 타임리프 사용 예제 (완전한 코드)

**thymeleaf-springsecurity.html**:

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
<head>
    <meta charset="UTF-8">
    <title>Spring Security 통합</title>
</head>
<body>
<h1>Spring Security + Thymeleaf</h1>

<ul>
    <!-- 비로그인 사용자 전용 -->
    <li sec:authorize="isAnonymous()">
        손님 반갑습니다. 로그인부터 해주세요.
        <a th:href="@{/login}">로그인</a>
    </li>

    <!-- 로그인 사용자 전용 -->
    <li sec:authorize="isAuthenticated()">
        <!-- 방법 1: sec:authentication -->
        <span sec:authentication="principal.displayName">이름</span> 님 반갑습니다.
        
        <!-- 방법 2: th:text + #authentication -->
        <!-- <span th:text="${#authentication.principal.displayName}">이름</span> 님 반갑습니다. -->
    </li>

    <!-- ADMIN 권한 보유자만 -->
    <li sec:authorize="hasAuthority('ROLE_ADMIN')">
        ADMIN 권한이 있으시군요
    </li>

    <!-- 로그인 사용자 메뉴 -->
    <li sec:authorize="isAuthenticated()">
        <a th:href="@{/product/list}">상품 목록</a>
    </li>
    
    <!-- 관리자 메뉴 -->
    <li sec:authorize="hasAuthority('ROLE_ADMIN')">
        <a th:href="@{/member/list}">회원 목록</a>
    </li>
</ul>

</body>
</html>
```

---

### 작동 원리 총정리

**View 렌더링 과정**:

```
1. 클라이언트 요청
    ↓
2. Controller 메서드 실행
    ↓
3. View 이름 반환 ("home")
    ↓
4. 타임리프 엔진 시작
    ↓
5. Spring Security 모듈 개입
    ↓
6. SecurityContext에서 Authentication 가져오기
    ↓
7. #authentication 객체로 타임리프에 제공
    ↓
8. sec:authorize 조건 평가
   - isAuthenticated() 확인
   - hasAuthority() 확인
    ↓
9. 조건이 true인 태그만 렌더링
    ↓
10. sec:authentication으로 정보 출력
    ↓
11. 최종 HTML 생성
    ↓
12. 클라이언트에 전송
```

**핵심**: 
- 타임리프가 SecurityContext에 **직접 접근**
- 컨트롤러에서 Model에 담을 필요 없음
- View만으로 인증/인가 제어 가능

---

## 5.3.12.4 핵심 정리

### 로그인 사용자 정보 사용 요약

**두 가지 방법**:

| 방법 | 위치 | 사용법 | 장점 |
|-----|------|--------|------|
| **@AuthenticationPrincipal** | 컨트롤러 | 매개변수로 주입 | 비즈니스 로직에서 활용 |
| **sec:authorize / sec:authentication** | View (Thymeleaf) | 타임리프 속성 | View만으로 제어 가능 |

---

### @AuthenticationPrincipal 핵심

**사용법**:

```java
@GetMapping("/mypage")
public String mypage(@AuthenticationPrincipal MyUserDetails myUserDetails) {
    // UserDetails 직접 사용
}
```

**주의사항**:
- `permitAll()` 경로에서는 null 체크 필수
- `authenticated()` 경로에서는 항상 주입됨

---

### 타임리프 통합 핵심

**필수 설정**:

```gradle
// build.gradle
implementation 'org.thymeleaf.extras:thymeleaf-extras-springsecurity6'
```

```html
<!-- HTML -->
<html xmlns:sec="http://www.thymeleaf.org/extras/spring-security">
```

**주요 속성**:

| 속성 | 역할 | 예시 |
|-----|------|------|
| **sec:authorize** | 조건부 렌더링 | `sec:authorize="isAuthenticated()"` |
| **sec:authentication** | 정보 출력 | `sec:authentication="principal.displayName"` |

---

### 실무 권장 패턴

**컨트롤러**:
- 비즈니스 로직에서 사용자 정보 필요 시 사용
- DB 저장, 권한 확인 등

**View**:
- 화면 표시용으로 사용
- 메뉴 제어, 환영 메시지 등

---

# 5.3.13 자동 로그인 (Remember-Me)

## 5.3.13.1 세션의 한계와 Remember-Me의 필요성

### 기본 세션의 문제점

**세션의 특성**:

| 항목 | 설명 |
|-----|------|
| **유효 기간** | 기본 30분 (설정 가능) |
| **저장 위치** | 서버 메모리 (또는 외부 DB) |
| **종료 조건** | 타임아웃, 브라우저 종료, 서버 재시작 |

**문제 상황**:

```
사용자가 로그인
    ↓
30분 후 세션 만료
    ↓
다음 페이지 접근 시
    ↓
미인증 상태로 간주
    ↓
로그인 페이지로 리다이렉트
```

**사용자 경험 문제**:
- 자주 재로그인해야 함
- 불편함 증가

---

### Remember-Me 기능이란?

**정의**: **세션이 만료되어도** 사용자를 자동으로 재인증하여 로그인 상태를 유지하는 기능

**작동 원리**:

```
로그인 시 "로그인 유지" 체크
    ↓
서버: 영구 쿠키 발급 (예: 14일)
    ↓
브라우저: 쿠키 저장
    ↓
세션 만료 후 요청
    ↓
서버: Remember-Me 쿠키 확인
    ↓
쿠키 유효 시: 자동 재로그인
```

---

### 세션 저장 (spring-session-jdbc) vs Remember-Me 비교

**헷갈리기 쉬운 두 기능**:

| 구분 | spring-session-jdbc | Remember-Me |
|-----|-------------------|------------|
| **목적** | 세션 공유 (서버 간/재시작) | 세션 만료 후 자동 재로그인 |
| **해결 문제** | 분산 환경의 세션 불일치 | 세션 유효 기간 문제 |
| **저장 대상** | SecurityContext 전체 | 토큰 정보 |
| **유효 기간** | 세션과 동일 (30분) | 길게 설정 (14일 등) |
| **쿠키** | JSESSIONID (세션 쿠키) | remember-me (영구 쿠키) |

**핵심 차이**:
- **spring-session-jdbc**: 세션 **저장 위치**를 메모리에서 DB로 변경
- **Remember-Me**: 세션 **유효 기간 문제** 해결

---

### 쿠키의 종류: 세션 쿠키 vs 영구 쿠키

**중요한 개념**:

| 쿠키 종류 | 만료 시간 | 저장 위치 | 수명 | 예시 |
|---------|---------|---------|------|------|
| **세션 쿠키** | 없음 (or 0) | 브라우저 메모리 | 브라우저 종료 시 삭제 | `JSESSIONID` |
| **영구 쿠키** | 미래 날짜 설정 | 하드디스크 | 만료 시간까지 유지 | `remember-me` |

**핵심**: 
- **세션 쿠키**: 브라우저 끄면 사라짐
- **영구 쿠키**: 브라우저 껐다 켜도 남아있음

**Remember-Me는 영구 쿠키를 사용**하므로 브라우저를 껐다 켜도 자동 로그인됩니다!

---

## 5.3.13.2 Remember-Me의 두 가지 방식

### 1. 단순 해시 기반 (Hash-Based Token)

**작동 방식**:

```
로그인 시:
    ↓
username + password + 만료시간 + 비밀키
    ↓
해시 함수로 암호화
    ↓
쿠키로 전송
```

**장점**:
- 설정 간단
- DB 불필요

**단점** (심각한 보안 문제):

| 문제 | 설명 |
|-----|------|
| **토큰 탈취 위험** | 쿠키가 탈취되면 해커도 로그인 가능 |
| **비밀번호 변경 무효화 안 됨** | 비밀번호를 바꿔도 기존 토큰은 유효 |
| **무효화 불가능** | 관리자가 강제 로그아웃 시킬 수 없음 |

**결론**: **운영 환경에서 사용 금지!**

---

### 2. 영속적 토큰 기반 (Persistent Token)

**작동 방식**:

```
로그인 시:
    ↓
DB에 토큰 정보 저장
- username: 사용자 식별
- series: 로그인 세션 식별자
- token: 검증용 토큰
- last_used: 마지막 사용 시간
    ↓
쿠키에 series + token만 전송
```

**장점**:

| 장점 | 설명 |
|-----|------|
| **토큰 회전** | 사용할 때마다 token 갱신 |
| **탈취 감지** | 이전 토큰 사용 시 탈취로 판단 |
| **강제 무효화** | DB에서 삭제하면 즉시 무효화 |
| **보안성** | 해시 방식보다 훨씬 안전 |

**핵심**: **실무에서는 반드시 영속적 토큰 방식 사용!**

---

## 5.3.13.3 영속적 토큰 기반 Remember-Me 구현

### 필수 테이블 생성

**schema.sql**:

```sql
CREATE TABLE persistent_logins (
    username VARCHAR(64) NOT NULL,
    series VARCHAR(64) PRIMARY KEY,
    token VARCHAR(64) NOT NULL,
    last_used TIMESTAMP NOT NULL
);
```

**칼럼 설명**:

| 칼럼 | 타입 | 역할 |
|-----|------|------|
| **username** | VARCHAR(64) | 사용자 식별 (이메일 또는 ID) |
| **series** | VARCHAR(64) | Remember-Me 세션 식별자 (거의 고정) |
| **token** | VARCHAR(64) | 검증용 토큰 (매번 갱신) |
| **last_used** | TIMESTAMP | 마지막 사용 시각 (토큰 회전 시 갱신) |

**주의**: 
- 테이블 이름은 반드시 **`persistent_logins`**
- Spring Security가 하드코딩된 이름 사용

---

### JPA 엔티티 작성

**PersistentLogin.java**:

```java
@Entity
@Table(name = "persistent_logins")
@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class PersistentLogin {
    @Id
    @Column(length = 64)
    private String series;

    @Column(length = 64, nullable = false)
    private String token;

    @Column(length = 64, nullable = false)
    private String username;
    
    @Column(name = "last_used", nullable = false)
    private LocalDateTime lastUsed;
}
```

**핵심**: 
- `series`가 기본 키
- 테이블 이름과 칼럼 이름 정확히 일치해야 함

---

### PersistentTokenRepository 빈 등록

**역할**: DB의 `persistent_logins` 테이블에 접근하여 토큰 CRUD 작업 수행

**SecurityConfiguration.java**:

```java
@Bean
PersistentTokenRepository persistentTokenRepository(DataSource dataSource) {
    JdbcTokenRepositoryImpl tokenRepository = new JdbcTokenRepositoryImpl();
    tokenRepository.setDataSource(dataSource);
    return tokenRepository;
}
```

**JdbcTokenRepositoryImpl의 역할**:

| 메서드 | 역할 | SQL |
|-------|------|-----|
| **createNewToken()** | 토큰 저장 | `INSERT INTO persistent_logins ...` |
| **getTokenForSeries()** | 토큰 조회 | `SELECT * FROM persistent_logins WHERE series = ?` |
| **updateToken()** | 토큰 갱신 | `UPDATE persistent_logins SET token = ?, last_used = ? WHERE series = ?` |
| **removeUserTokens()** | 토큰 삭제 | `DELETE FROM persistent_logins WHERE username = ?` |

**핵심**: 
- 개발자가 SQL을 작성할 필요 없음
- Spring Security가 자동으로 처리

---

### RememberMeServices 빈 등록

**역할**: Remember-Me의 **비즈니스 로직** 담당 (토큰 검증, UserDetails 생성 등)

**SecurityConfiguration.java**:

```java
@Bean
RememberMeServices rememberMeServices(
        UserDetailsService userDetailsService,
        PersistentTokenRepository persistentTokenRepository) {
    
    return new PersistentTokenBasedRememberMeServices(
            "hyechangRememberMe",  // 비밀 키
            userDetailsService,
            persistentTokenRepository
    );
}
```

**생성자 매개변수**:

| 매개변수 | 타입 | 역할 |
|---------|------|------|
| **key** | String | 토큰 서명용 비밀 키 (무결성 보장) |
| **userDetailsService** | UserDetailsService | username으로 UserDetails 로드 |
| **persistentTokenRepository** | PersistentTokenRepository | DB 토큰 저장소 |

**PersistentTokenBasedRememberMeServices의 역할**:

```
1. Remember-Me 쿠키 수신
    ↓
2. 쿠키에서 series + token 추출
    ↓
3. persistentTokenRepository로 DB 조회
    ↓
4. DB의 token과 쿠키의 token 비교
    ↓
5. 일치 시:
   - username으로 userDetailsService 호출
   - 새로운 UserDetails 생성
   - 새로운 SecurityContext 생성
   - 새로운 세션 발급
   - DB의 token 갱신 (토큰 회전)
    ↓
6. 불일치 시:
   - 토큰 탈취로 판단
   - DB에서 series 삭제
   - 인증 실패
```

---

### SecurityFilterChain에 Remember-Me 등록

**SecurityConfiguration.java**:

```java
@Bean
public SecurityFilterChain securityFilterChain(
        HttpSecurity http,
        RememberMeServices rememberMeServices) throws Exception {
    
    http
        .authorizeHttpRequests(/* ... */)
        .rememberMe(r -> r.rememberMeServices(rememberMeServices))
        .formLogin(/* ... */)
        .logout(/* ... */);
    
    return http.build();
}
```

**설정 의미**:

```java
.rememberMe(r -> r.rememberMeServices(rememberMeServices))
```

| 항목 | 설명 |
|-----|------|
| **역할** | Remember-Me 기능 활성화 |
| **서비스 지정** | 우리가 만든 `rememberMeServices` 빈 사용 |
| **효과** | 로그인 폼에 "로그인 유지" 체크박스 자동 추가 |

---

## 5.3.13.4 Remember-Me 작동 원리 상세

### series vs token

**핵심 개념**:

| 항목 | 역할 | 변경 시점 | 비유 |
|-----|------|----------|------|
| **series** | Remember-Me 세션 식별자 | 거의 바뀌지 않음 | 열쇠꾸러미 ID |
| **token** | 1회성 검증 토큰 | 매번 자동 로그인 시마다 | 오늘의 열쇠 |
| **username** | 사용자 식별자 | 불변 | 주인 이름 |

**작동 방식**:

```
series = "열쇠꾸러미 ID" (고정)
token = "오늘 사용할 열쇠" (매번 바뀜)
```

**왜 이렇게 설계했는가?**

| 이유 | 설명 |
|-----|------|
| **보안** | token을 매번 바꿔서 탈취 시 한 번만 사용 가능 |
| **효율성** | series는 고정하여 DB record 유지 (insert/delete 불필요) |
| **탈취 감지** | 이전 token 사용 시 즉시 탈취 감지 가능 |

---

### 로그인 시 (Remember-Me 활성화)

**과정**:

```
1. 사용자가 "로그인 유지" 체크박스 선택
    ↓
2. 로그인 성공
    ↓
3. PersistentTokenBasedRememberMeServices 작동
    ↓
4. 새로운 series 생성 (예: "AAAA...")
   새로운 token 생성 (예: "ZZZZ...")
    ↓
5. DB에 저장
   INSERT INTO persistent_logins 
   VALUES ('hyechang@spring.ac.kr', 'AAAA...', 'ZZZZ...', NOW())
    ↓
6. 쿠키 생성 및 전송
   Cookie: remember-me=Base64(series + ":" + token)
   만료: 14일 후
    ↓
7. 브라우저가 하드디스크에 저장 (영구 쿠키)
```

**결과**:

| 저장소 | 저장 내용 |
|-------|---------|
| **DB** | username, series, token, last_used |
| **클라이언트 쿠키** | series + token (Base64 인코딩) |

---

### 세션 만료 후 자동 로그인

**과정**:

```
1. 브라우저 종료 또는 세션 타임아웃
    ↓
2. JSESSIONID 쿠키 삭제 (세션 쿠키)
    ↓
3. 다음 요청 시
    ↓
4. 세션 없음 → 미인증 상태
    ↓
5. Remember-Me 필터 작동
    ↓
6. remember-me 쿠키 확인 (영구 쿠키는 남아있음)
    ↓
7. 쿠키에서 series + token 추출
   series = "AAAA..."
   token = "ZZZZ..."
    ↓
8. DB 조회
   SELECT * FROM persistent_logins WHERE series = 'AAAA...'
    ↓
9. DB의 token과 쿠키의 token 비교
   DB: "ZZZZ..."
   쿠키: "ZZZZ..."
    ↓
10. 일치 확인 → 정상 사용자
    ↓
11. DB의 username으로 UserDetailsService 호출
    loadUserByUsername("hyechang@spring.ac.kr")
    ↓
12. 새로운 UserDetails 생성
    ↓
13. 새로운 Authentication 생성
    ↓
14. 새로운 SecurityContext 생성
    ↓
15. 새로운 HTTP 세션 발급 (새로운 JSESSIONID)
    ↓
16. 토큰 회전 (보안 강화)
    새로운 token 생성: "XXXX..."
    UPDATE persistent_logins 
    SET token = 'XXXX...', last_used = NOW() 
    WHERE series = 'AAAA...'
    ↓
17. 새로운 remember-me 쿠키 전송
    Cookie: remember-me=Base64('AAAA...' + ':' + 'XXXX...')
    ↓
18. 브라우저가 쿠키 갱신
    ↓
19. 요청 처리 계속 (로그인 상태 유지)
```

**핵심**: 
- **완전히 새로운** UserDetails, Authentication, SecurityContext, 세션 생성
- 이전 세션을 "복원"하는 것이 아님!

---

### 토큰 회전 (Token Rotation)

**보안 메커니즘**:

```
매번 자동 로그인 성공 시:
    ↓
DB의 token 값 갱신
    ↓
이전 token은 즉시 폐기
    ↓
다음 로그인 시 새로운 token 사용
```

**시나리오 분석**:

```
Day 1: 로그인
series = "AAAA", token = "1111"

Day 2: 자동 로그인 성공
series = "AAAA" (유지), token = "2222" (갱신)

Day 3: 자동 로그인 성공
series = "AAAA" (유지), token = "3333" (갱신)
```

**보안 효과**:

| 상황 | 결과 |
|-----|------|
| **정상 사용자** | 항상 최신 token 보유 → 성공 |
| **해커 (쿠키 탈취)** | 이전 token 보유 → 실패 + series 삭제 |

---

### 토큰 탈취 감지

**해커의 공격 시나리오**:

```
Day 1: 사용자 로그인
DB: series="AAAA", token="1111"
사용자 쿠키: "AAAA:1111"

Day 2: 해커가 쿠키 탈취
해커 쿠키: "AAAA:1111" (복사본)

Day 3: 사용자가 자동 로그인
DB: series="AAAA", token="2222" (갱신됨)
사용자 쿠키: "AAAA:2222" (갱신됨)

Day 4: 해커가 탈취한 쿠키로 로그인 시도
해커 쿠키: "AAAA:1111" (이전 token)
    ↓
DB 조회: series="AAAA" 찾음
DB token: "2222"
해커 token: "1111"
    ↓
불일치 → 토큰 탈취로 판단!
    ↓
DELETE FROM persistent_logins WHERE series = 'AAAA'
    ↓
해커: 인증 실패
사용자: 다음 요청 시 자동 로그아웃 (series 삭제됨)
```

**핵심**: 
- 이전 token 사용 = 탈취 의심
- 즉시 series 삭제로 강제 로그아웃

---

## 5.3.13.5 Remember-Me 실습

### 초기 데이터 준비

**DataInitializer.java**:

```java
@Component
@RequiredArgsConstructor
public class DataInitializer implements ApplicationRunner {
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;
    private final AuthoritiesRepository authoritiesRepository;

    @Override
    public void run(ApplicationArguments args) throws Exception {
        // 사용자 생성
        User user1 = User.builder()
                .name("홍혜창")
                .email("hyechang@spring.ac.kr")
                .password(passwordEncoder.encode("password"))
                .build();
        
        User user2 = User.builder()
                .name("김우현")
                .email("woo@spring.ac.kr")
                .password(passwordEncoder.encode("password"))
                .build();
        
        User user3 = User.builder()
                .name("손흥민")
                .email("sonny@spring.ac.kr")
                .password(passwordEncoder.encode("password"))
                .build();

        userRepository.save(user1);
        userRepository.save(user2);
        userRepository.save(user3);

        // 권한 생성
        Authorities authorities1 = Authorities.builder()
                .authority("ROLE_USER")
                .user(user1)
                .build();
        
        Authorities authorities2 = Authorities.builder()
                .authority("ROLE_ADMIN")
                .user(user2)
                .build();
        
        Authorities authorities3 = Authorities.builder()
                .authority("ROLE_USER")
                .user(user3)
                .build();

        authoritiesRepository.save(authorities1);
        authoritiesRepository.save(authorities2);
        authoritiesRepository.save(authorities3);
    }
}
```

**역할**: 
- 애플리케이션 시작 시 자동 실행
- 테스트용 사용자 및 권한 데이터 생성

---

### 로그인 폼에 체크박스 추가

**hyechang-login.html**:

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>로그인</title>
</head>
<body>
<form th:action="@{/hyechangLogin}" method="post">
    <div>
        아이디 : <input type="text" name="username">
    </div>
    <div>
        비밀번호 : <input type="password" name="password">
    </div>
    <div>
        자동로그인 <input type="checkbox" name="remember-me">
    </div>
    <button type="submit">버튼</button>
</form>
</body>
</html>
```

**중요한 name 속성**:

| name | 역할 | Spring Security 기대값 |
|------|------|----------------------|
| **username** | 사용자 ID | 필수 (기본값) |
| **password** | 비밀번호 | 필수 (기본값) |
| **remember-me** | 자동 로그인 체크 | 체크 시 Remember-Me 활성화 |

**핵심**: 
- `name="remember-me"` 정확히 일치해야 함
- 체크 시 값 "on" 또는 "true" 전송

---

### 실행 결과 분석

**로그인 페이지 HTML 소스 보기**:

```html
<form action="/hyechangLogin" method="post">
    <input type="hidden" name="_csrf" value="Ziq500ZpJ0NZ4c0JiQQ6P0p9..."/>
    <div>
        아이디 : <input type="text" name="username">
    </div>
    <div>
        비밀번호 : <input type="password" name="password">
    </div>
    <div>
        자동로그인 <input type="checkbox" name="remember-me">
    </div>
    <button type="submit">버튼</button>
</form>
```

**확인 사항**:
- ✅ CSRF 토큰 자동 삽입됨
- ✅ remember-me 체크박스 표시됨

---

**로그인 성공 후 쿠키 확인**:

```
브라우저 개발자 도구 → Application → Cookies → localhost

쿠키 목록:
1. SESSION: NjMzMmJlZWQtZTc3ZS00MzhlLTkwOTEtY2E4OWEwYjUzNmYz
   (세션 쿠키 - 브라우저 종료 시 삭제)

2. remember-me: M2pRRkNNQjRqbHR5Z1lYRVE4Tm1PUSUzRCUzRDprb1N6OENnbzNaOWNmZE8...
   (영구 쿠키 - 14일 후 만료)
```

---

**DB 확인**:

```sql
SELECT * FROM persistent_logins;
```

**결과**:

| username | series | token | last_used |
|---------|--------|-------|----------|
| woo@spring.ac.kr | 3jRFCMB4... | koSz8Cgo3Z9... | 2025-11-05 14:30:00 |

**확인 사항**:
- ✅ DB에 토큰 정보 저장됨
- ✅ username, series, token 모두 존재

---

**브라우저 종료 후 재접속**:

```
1. 브라우저 완전 종료
    ↓
2. 브라우저 재시작
    ↓
3. http://localhost:8080/member/list 접속
    ↓
4. 자동 로그인 성공!
```

**쿠키 확인**:

```
1. SESSION: NmNmZmQwZmYtMGE4Ni00NDAxLWIwOTktZTgyYWM3MjJmNTQ5
   (새로운 세션 ID - 변경됨!)

2. remember-me: M2pRRkNNQjRqbHR5Z1lYRVE4Tm1PUSUzRCUzRDolMkZwc1VkczVNMSUy...
   (remember-me 쿠키 - token 부분이 변경됨!)
```

**핵심**: 
- SESSION ID가 **변경됨** → 새로운 세션 생성
- remember-me 쿠키의 token 부분이 **변경됨** → 토큰 회전 발생

---

**DB 변경 확인**:

```sql
SELECT * FROM persistent_logins;
```

**결과**:

| username | series | token | last_used |
|---------|--------|-------|----------|
| woo@spring.ac.kr | 3jRFCMB4... (동일) | /psUds5M1/ee... (변경됨!) | 2025-11-05 15:00:00 (갱신됨!) |

**확인 사항**:
- ✅ series는 동일 (고정 식별자)
- ✅ token은 변경됨 (토큰 회전)
- ✅ last_used 갱신됨

---

## 5.3.13.6 Remember-Me 핵심 정리

### 작동 원리 요약

**로그인 시**:

```
사용자 로그인 + "로그인 유지" 체크
    ↓
DB에 series + token 저장
    ↓
클라이언트에 remember-me 쿠키 전송 (영구)
```

**세션 만료 후**:

```
세션 없음 → 미인증 상태
    ↓
remember-me 쿠키 확인
    ↓
series로 DB 조회
    ↓
token 비교
    ↓
일치 → 새로운 UserDetails + 세션 생성 + token 회전
불일치 → 탈취로 판단 + series 삭제
```

---

### 핵심 개념

| 개념 | 설명 |
|-----|------|
| **series** | Remember-Me 세션 식별자 (고정) |
| **token** | 1회성 검증 토큰 (매번 갱신) |
| **토큰 회전** | 사용할 때마다 token 값 변경 |
| **탈취 감지** | 이전 token 사용 시 즉시 감지 및 무효화 |
| **영구 쿠키** | 브라우저 껐다 켜도 유지 |

---

### spring-session-jdbc vs Remember-Me 최종 비교

| 구분 | spring-session-jdbc | Remember-Me |
|-----|-------------------|------------|
| **해결 문제** | 분산 환경 세션 공유 | 세션 만료 문제 |
| **저장 대상** | SecurityContext 전체 | username + series + token |
| **쿠키 종류** | 세션 쿠키 (JSESSIONID) | 영구 쿠키 (remember-me) |
| **수명** | 30분 (세션과 동일) | 14일 (설정 가능) |
| **브라우저 종료** | 쿠키 삭제 → 세션 유지 | 쿠키 유지 → 자동 재로그인 |

**함께 사용 가능**:
- spring-session-jdbc: 서버 재시작 대응
- Remember-Me: 세션 만료 대응

---

# 5.3.14 로그인/로그아웃 페이지 커스터마이징

## 5.3.14.1 기본 제공 페이지의 한계

**현재 상황**:

```java
.formLogin(Customizer.withDefaults())
.logout(Customizer.withDefaults())
```

**문제점**:

| 항목 | 기본 제공 | 문제 |
|-----|---------|------|
| **로그인 페이지** | Spring Security 자동 생성 | 디자인 불가, 브랜딩 불가 |
| **로그아웃 처리** | `/logout` 경로 고정 | 커스텀 경로 불가 |
| **성공 후 이동** | 이전 페이지 또는 `/` | 원하는 페이지 지정 불가 |

**필요성**: 
- 회사 브랜딩에 맞는 디자인
- 사용자 경험(UX) 개선
- 특정 페이지로 리다이렉트

---

## 5.3.14.2 커스텀 로그인/로그아웃 설정

### SecurityConfiguration 설정

```java
@Bean
public SecurityFilterChain securityFilterChain(
        HttpSecurity http,
        RememberMeServices rememberMeServices) throws Exception {
    
    http
        .authorizeHttpRequests(
            auth -> {
                auth.requestMatchers("/", "/home").permitAll()
                    .requestMatchers("/member/**").hasAuthority("ROLE_ADMIN")
                    .anyRequest().authenticated();
            }
        )
        .rememberMe(r -> r.rememberMeServices(rememberMeServices))
        .formLogin(login -> login
                .loginPage("/hyechangLogin")
                .defaultSuccessUrl("/hyechangIntro", true)
                .permitAll())
        .logout(logout -> logout
                .logoutUrl("/hyechangLogout")
                .logoutSuccessUrl("/hyechangHome")
                .permitAll());
    
    return http.build();
}
```

---

### formLogin() 설정 분석

**기본 형태**:

```java
.formLogin(login -> login
        .loginPage("/hyechangLogin")
        .defaultSuccessUrl("/hyechangIntro", true)
        .permitAll())
```

---

#### loginPage() 메서드

**정의**: 로그인 폼을 제공하는 URL **AND** 인증을 처리하는 URL

**이중 역할** (매우 중요!):

| HTTP 메서드 | 역할 | 처리 주체 |
|-----------|------|----------|
| **GET** | 로그인 폼 HTML 반환 | **개발자의 @GetMapping 컨트롤러** |
| **POST** | 실제 인증 처리 | **Spring Security 필터** (자동) |

**작동 방식**:

```
사용자가 인증 필요 페이지 접근
    ↓
Spring Security가 /hyechangLogin으로 리다이렉트 (GET)
    ↓
개발자의 @GetMapping("/hyechangLogin") 실행
    ↓
로그인 폼 HTML 반환
    ↓
사용자가 ID/PW 입력 후 제출 (POST)
    ↓
Spring Security의 UsernamePasswordAuthenticationFilter가 가로챔
    ↓
자동으로 인증 처리 (UserDetailsService 호출)
    ↓
성공 → defaultSuccessUrl로 리다이렉트
실패 → /hyechangLogin?error로 리다이렉트
```

**핵심**: 
- **GET**은 개발자가 컨트롤러 작성 필요
- **POST**는 Spring Security가 자동 처리 (컨트롤러 불필요!)

---

#### defaultSuccessUrl() 메서드

**정의**: 로그인 성공 후 이동할 URL 지정

**문법**:

```java
.defaultSuccessUrl(URL, alwaysUse)
```

| 매개변수 | 타입 | 역할 |
|---------|------|------|
| **URL** | String | 이동할 경로 |
| **alwaysUse** | boolean | 강제 이동 여부 |

---

**alwaysUse = false (기본값)**:

```
로그인 전에 접근하려던 페이지가 있는가?
    ↓
YES → 그 페이지로 이동 (Saved Request 우선)
NO → defaultSuccessUrl로 이동
```

**예시**:

```
사용자가 /admin/users 접근 시도
    ↓
인증 필요 → 로그인 페이지로 리다이렉트
    ↓
로그인 성공
    ↓
/admin/users로 이동 (원래 가려던 곳)
```

---

**alwaysUse = true (권장)**:

```
무조건 지정한 URL로 이동
(Saved Request 무시)
```

**예시**:

```
사용자가 /admin/users 접근 시도
    ↓
인증 필요 → 로그인 페이지로 리다이렉트
    ↓
로그인 성공
    ↓
/hyechangIntro로 이동 (Saved Request 무시)
```

**문제 상황과 해결**:

```
// ❌ alwaysUse = false 일 때
로그인 폼에서 직접 로그인
    ↓
Saved Request 없음
    ↓
기본값인 "/"로 이동 (예상과 다름!)

// ✅ alwaysUse = true 일 때
어떤 경로로 로그인하든
    ↓
항상 /hyechangIntro로 이동 (일관성!)
```

**권장 설정**:

```java
.defaultSuccessUrl("/hyechangIntro", true)  // ✅ true 명시
```

---

#### permitAll() 메서드

**정의**: 로그인 페이지는 인증 없이 접근 가능하도록 설정

**이유**:

```
로그인 페이지가 authenticated() 설정이면?
    ↓
로그인 페이지 접근 시 인증 필요
    ↓
다시 로그인 페이지로 리다이렉트
    ↓
무한 루프!
```

**해결**:

```java
.formLogin(login -> login
        .loginPage("/hyechangLogin")
        .permitAll())  // ← 로그인 페이지는 인증 불필요
```

**효과**:

```
.authorizeHttpRequests(
    auth -> auth
        .requestMatchers("/hyechangLogin").permitAll()  // 자동 추가됨!
        // ...
)
```

---

### logout() 설정 분석

**기본 형태**:

```java
.logout(logout -> logout
        .logoutUrl("/hyechangLogout")
        .logoutSuccessUrl("/hyechangHome")
        .permitAll())
```

---

#### logoutUrl() 메서드

**정의**: 로그아웃을 **트리거**하는 URL (액션)

**중요한 오해 방지**:

| 잘못된 이해 | 올바른 이해 |
|-----------|-----------|
| "로그아웃 페이지를 보여주는 URL" | "로그아웃 **기능을 실행**하는 URL" |
| "@GetMapping 필요" | **컨트롤러 불필요!** |

**작동 방식**:

```
POST /hyechangLogout 요청
    ↓
LogoutFilter가 요청 가로챔 (자동)
    ↓
다음 작업 자동 수행:
1. SecurityContext에서 Authentication 제거
2. HTTP 세션 무효화 (invalidate)
3. JSESSIONID 쿠키 삭제
4. remember-me 쿠키 삭제
    ↓
logoutSuccessUrl로 리다이렉트
```

**핵심**: 
- **POST 요청**이어야 함 (CSRF 보호)
- **컨트롤러 작성 불필요** (Spring Security가 처리)
- 자동으로 복잡한 로그아웃 로직 수행

---

#### logoutSuccessUrl() 메서드

**정의**: 로그아웃 완료 후 이동할 URL (GET 요청)

```java
.logoutSuccessUrl("/hyechangHome")
```

**작동 방식**:

```
로그아웃 처리 완료
    ↓
GET /hyechangHome으로 리다이렉트
    ↓
개발자의 @GetMapping("/hyechangHome") 실행
    ↓
로그아웃 완료 페이지 표시
```

**주의**: 
- 이 URL은 **컨트롤러 작성 필요** (GET 요청 처리)
- 일반적으로 메인 페이지 또는 로그인 페이지로 설정

---

#### permitAll() 메서드

**정의**: 로그아웃 관련 URL은 인증 없이 접근 가능

**적용 범위**:
- `/hyechangLogout` (로그아웃 액션)
- `/hyechangHome` (로그아웃 후 페이지)

**이유**: 
- 로그아웃 후에는 미인증 상태
- 로그아웃 완료 페이지는 누구나 볼 수 있어야 함

---

## 5.3.14.3 컨트롤러 작성

### MemberController.java

```java
@Controller
public class MemberController {
    
    // ... (기존 코드)
    
    // 로그인 폼 표시 (GET)
    @GetMapping("/hyechangLogin")
    public String hyechangLogin() {
        return "hong/hyechang-login";
    }
    
    // 로그인 성공 후 페이지 (GET)
    @GetMapping("/hyechangIntro")
    public String hyechangIntro() {
        return "hong/hyechang-intro";
    }
    
    // 로그아웃 완료 후 페이지 (GET)
    @GetMapping("/hyechangHome")
    public String hyechangHome() {
        return "hong/hyechang-home";
    }
}
```

**중요**: 
- `/hyechangLogin` POST는 **컨트롤러 불필요** (Spring Security 자동 처리)
- `/hyechangLogout` POST도 **컨트롤러 불필요** (LogoutFilter 자동 처리)

---

## 5.3.14.4 View 파일 작성

### 로그인 폼 (hyechang-login.html)

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>로그인</title>
</head>
<body>
<h2>커스텀 로그인 페이지</h2>

<form th:action="@{/hyechangLogin}" method="post">
    <div>
        아이디 : <input type="text" name="username">
    </div>
    <div>
        비밀번호 : <input type="password" name="password">
    </div>
    <div>
        자동로그인 <input type="checkbox" name="remember-me">
    </div>
    <button type="submit">로그인</button>
</form>
</body>
</html>
```

**중요한 name 속성**:

| name | Spring Security 기대값 | 설명 |
|------|----------------------|------|
| **username** | 필수 (변경 가능) | 사용자 ID |
| **password** | 필수 (변경 가능) | 비밀번호 |
| **remember-me** | 선택 | 자동 로그인 체크 시 "on" 전송 |

**핵심**: 
- `th:action="@{/hyechangLogin}"` 사용 (Context Path 자동 포함)
- `method="post"` 필수
- CSRF 토큰 자동 삽입됨 (th:action 사용 시)

---

### 로그인 성공 페이지 (hyechang-intro.html)

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>로그인 성공</title>
</head>
<body>
<h3>로그인 성공</h3>

<p>로그아웃 하실래요?</p>
<form th:action="@{/hyechangLogout}" method="post">
    <button type="submit">로그아웃</button>
</form>
</body>
</html>
```

**중요**: 
- 로그아웃도 `th:action` 사용
- `method="post"` 필수 (CSRF 보호)

---

### 로그아웃 완료 페이지 (hyechang-home.html)

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>로그아웃 완료</title>
</head>
<body>
<h3>로그아웃 완료</h3>
<p>안전하게 로그아웃되었습니다.</p>
<a th:href="@{/hyechangLogin}">다시 로그인</a>
</body>
</html>
```

---

## 5.3.14.5 전체 흐름 정리

### 로그인 흐름

```
1. 사용자: http://localhost:8080/member/list 접근
    ↓
2. Spring Security: 인증 필요 → /hyechangLogin으로 리다이렉트 (GET)
    ↓
3. MemberController.hyechangLogin() 실행
    ↓
4. hyechang-login.html 반환
    ↓
5. 브라우저: 로그인 폼 표시
    ↓
6. 사용자: ID/PW 입력 후 제출 (POST /hyechangLogin)
    ↓
7. UsernamePasswordAuthenticationFilter 가로챔
    ↓
8. UserDetailsService.loadUserByUsername() 호출
    ↓
9. PasswordEncoder.matches() 검증
    ↓
10. 인증 성공 → SecurityContext 생성 + 세션 저장
    ↓
11. /hyechangIntro로 리다이렉트 (GET)
    ↓
12. MemberController.hyechangIntro() 실행
    ↓
13. hyechang-intro.html 반환
    ↓
14. 브라우저: 로그인 성공 페이지 표시
```

---

### 로그아웃 흐름

```
1. 사용자: 로그아웃 버튼 클릭
    ↓
2. POST /hyechangLogout 요청
    ↓
3. LogoutFilter 가로챔
    ↓
4. 다음 작업 자동 수행:
   - SecurityContext에서 Authentication 제거
   - HTTP 세션 무효화
   - JSESSIONID 쿠키 삭제
   - remember-me 쿠키 삭제
    ↓
5. /hyechangHome으로 리다이렉트 (GET)
    ↓
6. MemberController.hyechangHome() 실행
    ↓
7. hyechang-home.html 반환
    ↓
8. 브라우저: 로그아웃 완료 페이지 표시
```

---

## 5.3.14.6 실행 결과 확인

**시나리오 1: 로그인 시도**

```
접속: http://localhost:8080/member/list
    ↓
결과: http://localhost:8080/hyechangLogin (로그인 폼)
```

**로그인 폼 HTML 소스**:

```html
<form action="/hyechangLogin" method="post">
    <input type="hidden" name="_csrf" value="Ziq500ZpJ0NZ4c0JiQQ6P0p9-iCXsE6VUwcM59133PIpo5a6BxmN4CMMFyB0hKxtuCkODysY1xmmhX24MmE60-sTvZAflK_Z"/>
    <div>
        아이디 : <input type="text" name="username">
    </div>
    <div>
        비밀번호 : <input type="password" name="password">
    </div>
    <div>
        자동로그인 <input type="checkbox" name="remember-me">
    </div>
    <button type="submit">로그인</button>
</form>
```

**확인 사항**:
- ✅ CSRF 토큰 자동 삽입됨
- ✅ action 경로 정확함
- ✅ remember-me 체크박스 표시됨

---

**시나리오 2: 로그인 성공**

```
입력: woo@spring.ac.kr / password
    ↓
결과: http://localhost:8080/hyechangIntro?continue
```

**쿠키 확인**:

```
SESSION: NjMzMmJlZWQtZTc3ZS00MzhlLTkwOTEtY2E4OWEwYjUzNmYz
remember-me: M2pRRkNNQjRqbHR5Z1lYRVE4Tm1PUSUzRCUzRDprb1N6OENnbzNaOWNmZE8...
```

---

**시나리오 3: 로그아웃**

```
로그아웃 버튼 클릭
    ↓
결과: http://localhost:8080/hyechangHome
```

**쿠키 확인**:

```
SESSION: (삭제됨)
remember-me: (삭제됨)
```

**확인 사항**:
- ✅ 모든 인증 관련 쿠키 삭제됨
- ✅ 로그아웃 완료 페이지 표시

---

## 5.3.14.7 핵심 정리

### 커스텀 로그인/로그아웃 요약

**설정 필수 사항**:

| 설정 | 메서드 | 역할 |
|-----|--------|------|
| **로그인 폼 URL** | `.loginPage("/hyechangLogin")` | GET: 폼 표시, POST: 인증 처리 |
| **성공 후 이동** | `.defaultSuccessUrl("/hyechangIntro", true)` | 로그인 성공 시 항상 이동 |
| **로그아웃 URL** | `.logoutUrl("/hyechangLogout")` | POST: 로그아웃 실행 |
| **로그아웃 후 이동** | `.logoutSuccessUrl("/hyechangHome")` | 로그아웃 성공 시 이동 |

---

### 컨트롤러 작성 필요 여부

| URL | HTTP 메서드 | 컨트롤러 필요 | 처리 주체 |
|-----|-----------|------------|----------|
| `/hyechangLogin` | **GET** | ✅ 필요 | 개발자 |
| `/hyechangLogin` | **POST** | ❌ 불필요 | Spring Security |
| `/hyechangIntro` | **GET** | ✅ 필요 | 개발자 |
| `/hyechangLogout` | **POST** | ❌ 불필요 | Spring Security |
| `/hyechangHome` | **GET** | ✅ 필요 | 개발자 |

---

### HTML 작성 시 주의사항

**필수 사항**:

```html
<!-- ✅ 올바른 예시 -->
<form th:action="@{/hyechangLogin}" method="post">
    <input type="text" name="username">
    <input type="password" name="password">
    <input type="checkbox" name="remember-me">
    <button type="submit">로그인</button>
</form>
```

**주의 사항**:

| 항목 | 올바른 값 | 잘못된 예시 |
|-----|----------|-----------|
| **th:action** | 반드시 사용 | `action="/hyechangLogin"` |
| **method** | `"post"` | `"get"` |
| **name="username"** | 정확히 일치 | `name="email"` |
| **name="password"** | 정확히 일치 | `name="pwd"` |
| **name="remember-me"** | 정확히 일치 | `name="auto-login"` |

---

# 5.3.15 CSRF (Cross-Site Request Forgery)

## 5.3.15.1 CSRF란 무엇인가?

**정의**: 사이트 간 요청 위조 공격. 인증된 사용자의 권한을 도용하여 의도하지 않은 행위를 수행하게 만드는 공격

**공격 원리**:

```
1. 사용자가 신뢰하는 사이트(A)에 로그인
    ↓
2. 사용자 브라우저에 세션 쿠키 저장
    ↓
3. 공격자가 악성 사이트(B)에 위조 요청 숨김
    ↓
4. 사용자가 악성 사이트(B) 방문
    ↓
5. 악성 사이트가 사이트(A)로 자동 요청 전송
    ↓
6. 브라우저가 자동으로 세션 쿠키 포함
    ↓
7. 사이트(A)는 유효한 세션으로 인식
    ↓
8. 의도하지 않은 작업 실행 (돈 이체, 비밀번호 변경 등)
```

---

### 공격 예시

**악성 사이트의 숨겨진 코드**:

```html
<!-- 공격자의 악성 사이트 -->
<h1>무료 쿠폰 받기!</h1>

<!-- 숨겨진 위조 요청 -->
<form id="evil" action="https://bank.com/transfer" method="post">
    <input type="hidden" name="to" value="해커계좌">
    <input type="hidden" name="amount" value="1000000">
</form>

<script>
    // 페이지 로드 시 자동 제출
    document.getElementById('evil').submit();
</script>
```

**피해자 입장**:

```
1. 은행 사이트에 로그인한 상태 (세션 유효)
    ↓
2. 악성 사이트 방문
    ↓
3. 숨겨진 폼이 자동으로 은행 사이트로 POST 요청
    ↓
4. 브라우저가 은행 세션 쿠키 자동 포함
    ↓
5. 은행 서버: "유효한 세션이네. 승인!"
    ↓
6. 의도하지 않은 송금 실행
```

**핵심 문제**: 
- 브라우저는 **자동으로 쿠키를 요청에 포함**
- 서버는 **세션 쿠키만으로** 요청의 정당성 판단
- 사용자의 **의도 여부를 확인할 방법 없음**

---

## 5.3.15.2 세션 하이재킹과의 관계

### 세션 하이재킹이란?

**정의**: 공격자가 사용자의 **세션 ID를 탈취**하여 그 사용자인 것처럼 행세하는 공격

**세션 ID 탈취 방법**:

| 방법 | 설명 |
|-----|------|
| **네트워크 감청** | HTTP 통신 시 세션 ID 가로채기 (HTTPS로 방지) |
| **XSS 공격** | 악성 스크립트로 `document.cookie` 읽기 |
| **세션 고정** | 공격자가 알고 있는 세션 ID를 피해자에게 사용하게 만듦 |

---

### 세션 하이재킹 → CSRF 가능성

**문제의 연쇄**:

```
1. 세션 하이재킹 성공
   공격자가 사용자의 세션 ID 획득
    ↓
2. 공격자가 자신의 브라우저에 세션 ID 설정
    ↓
3. 서버는 공격자를 정상 사용자로 인식
    ↓
4. 공격자가 악성 요청 전송 가능
    ↓
5. CSRF 공격 성공
```

**핵심**: 
- 세션 ID만으로는 **요청의 출처**를 확인할 수 없음
- 추가적인 검증 수단 필요 → **CSRF 토큰**

---

## 5.3.15.3 CSRF 토큰 방어 메커니즘

### CSRF 토큰이란?

**정의**: 서버가 생성한 **예측 불가능한 임의의 값**으로, 정당한 요청임을 증명하는 비밀 키

**작동 원리**:

```
1. 로그인 성공 시
    ↓
2. 서버: CSRF 토큰 생성 및 세션에 저장
   토큰: "Ziq500ZpJ0NZ4c0JiQQ6P0p9..."
    ↓
3. 서버: HTML 폼에 토큰 포함하여 전송
   <input type="hidden" name="_csrf" value="Ziq500Zp...">
    ↓
4. 클라이언트: 폼 제출 시 토큰도 함께 전송
    ↓
5. 서버: 요청의 토큰과 세션의 토큰 비교
    ↓
6. 일치 → 정당한 요청으로 판단 → 처리
   불일치 → 위조 요청으로 판단 → 403 Forbidden
```

---

### CSRF 토큰 vs 세션 ID

| 구분 | 세션 ID (JSESSIONID) | CSRF 토큰 (_csrf) |
|-----|---------------------|------------------|
| **저장 위치 (서버)** | 세션 저장소 | 세션 저장소 (세션 ID에 연결) |
| **전달 방식 (클라이언트)** | 쿠키 (자동 전송) | 폼 데이터 또는 헤더 (수동 포함) |
| **역할** | 사용자 식별 (인증) | 요청 출처 검증 (위조 방지) |
| **악용 가능성** | 세션 하이재킹 시 악용 | 예측 불가능하여 악용 어려움 |

**핵심 차이**:
- **세션 ID**: 브라우저가 **자동으로** 쿠키에 포함
- **CSRF 토큰**: 개발자가 **수동으로** 폼에 포함

**악성 사이트의 한계**:

```
악성 사이트 입장:
    ↓
세션 ID는 브라우저가 자동으로 전송 (획득 가능)
    ↓
CSRF 토큰은 수동으로 포함해야 함
    ↓
악성 사이트는 피해자의 CSRF 토큰을 알 수 없음!
    ↓
CSRF 공격 실패
```

---

## 5.3.15.4 타임리프의 CSRF 토큰 자동 처리

### th:action의 역할

**타임리프 템플릿**:

```html
<form th:action="@{/hyechangLogin}" method="post">
    <input type="text" name="username">
    <input type="password" name="password">
    <button type="submit">로그인</button>
</form>
```

**렌더링 후 HTML**:

```html
<form action="/hyechangLogin" method="post">
    <input type="hidden" name="_csrf" value="Ziq500ZpJ0NZ4c0JiQQ6P0p9-iCXsE6VUwcM59133PIpo5a6BxmN4CMMFyB0hKxtuCkODysY1xmmhX24MmE60-sTvZAflK_Z"/>
    <input type="text" name="username">
    <input type="password" name="password">
    <button type="submit">로그인</button>
</form>
```

**자동 삽입 조건**:

| 조건 | 필수 여부 |
|-----|----------|
| `th:action` 속성 사용 | ✅ 필수 |
| `method="post"` | ✅ 필수 |
| Spring Security 활성화 | ✅ 필수 |

---

### th:action의 두 가지 역할

**1. Context Path 자동 포함**:

```
애플리케이션이 /myapp에 배포된 경우:
    ↓
th:action="@{/hyechangLogin}"
    ↓
렌더링: action="/myapp/hyechangLogin"
```

**2. CSRF 토큰 자동 삽입**:

```
method="post" + th:action 사용 시:
    ↓
타임리프가 세션에서 CSRF 토큰 읽기
    ↓
<input type="hidden" name="_csrf" value="..."> 자동 삽입
```

**핵심**: 
- `th:action` 사용 → CSRF 토큰 자동 처리
- 일반 `action` 사용 → CSRF 토큰 수동 추가 필요

---

### 수동으로 CSRF 토큰 추가

**th:action을 사용하지 않는 경우**:

```html
<form action="/hyechangLogin" method="post">
    <!-- 수동으로 CSRF 토큰 추가 -->
    <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>
    
    <input type="text" name="username">
    <input type="password" name="password">
    <button type="submit">로그인</button>
</form>
```

**권장**: 
- 항상 `th:action` 사용
- 자동 처리가 안전하고 편리

---

## 5.3.15.5 CSRF 토큰의 수명과 갱신

### 토큰 생성 및 저장 시점

**생성 시점**:

```
로그인 성공 시 (세션 생성 시)
    ↓
CSRF 토큰 생성
    ↓
HTTP 세션에 저장
    key: "org.springframework.security.web.csrf.HttpSessionCsrfTokenRepository.CSRF_TOKEN"
    value: CsrfToken 객체
```

**저장 구조**:

```
HTTP Session
    └── SecurityContext (인증 정보)
    └── CSRF Token (위조 방지 토큰)
```

---

### 토큰의 수명

**유효 기간**: 

```
세션과 동일 (기본 30분)
```

**갱신 시점**:

| 시점 | 동작 |
|-----|------|
| **로그인 성공** | 새로운 세션 + 새로운 CSRF 토큰 생성 |
| **세션 연장** | CSRF 토큰도 함께 유지 |
| **로그아웃** | 세션 삭제 + CSRF 토큰도 삭제 |

**핵심**: 
- CSRF 토큰은 **세션에 종속**
- 세션이 유효한 동안 토큰도 유효

---

### 페이지 렌더링 시 토큰 주입

**동작 흐름**:

```
1. 클라이언트: GET /home
    ↓
2. Controller: "home" 반환
    ↓
3. 타임리프 렌더링 시작
    ↓
4. <form th:action method="post"> 발견
    ↓
5. 타임리프가 세션에서 CSRF 토큰 읽기
    ↓
6. HTML에 토큰 주입
   <input type="hidden" name="_csrf" value="현재 세션의 토큰">
    ↓
7. 클라이언트에게 HTML 전송
```

**핵심**: 
- 페이지를 열 때마다 **현재 세션의 유효한 CSRF 토큰** 주입
- 클라이언트가 토큰을 관리할 필요 없음

---

## 5.3.15.6 CSRF 설정 변경

### CSRF 보호 비활성화 (비권장)

**전체 비활성화**:

```java
http
    .csrf(csrf -> csrf.disable())
```

**결과**:
- 모든 POST, PUT, DELETE 요청에서 CSRF 토큰 불필요
- 편리하지만 **보안 위험** 증가

**사용 시기**:
- RESTful API 전용 서버 (토큰 기반 인증 사용 시)
- 테스트 환경

**주의**: **일반 웹 애플리케이션에서는 절대 비활성화 금지!**

---

### 특정 경로만 CSRF 보호 제외

**설정**:

```java
http
    .csrf(csrf -> csrf
            .ignoringRequestMatchers("/api/**"))
```

**의미**:
- `/api/**` 경로는 CSRF 토큰 불필요
- 나머지 경로는 CSRF 보호 유지

**사용 시기**:

| 경로 | CSRF 보호 | 이유 |
|-----|----------|------|
| `/api/**` | 제외 | RESTful API (Bearer Token 사용) |
| `/login`, `/logout` 등 | 유지 | 세션 기반 인증 |

**핵심**: 
- RESTful API와 일반 웹을 함께 운영 시 유용
- API는 세션 쿠키를 사용하지 않으므로 CSRF 공격 대상 아님

---

### 실무 권장 설정

```java
@Bean
public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
    http
        .csrf(csrf -> csrf
                .ignoringRequestMatchers("/api/**"))  // API만 제외
        .authorizeHttpRequests(/* ... */)
        .formLogin(/* ... */)
        .logout(/* ... */);
    
    return http.build();
}
```

---

## 5.3.15.7 CSRF 핵심 정리

### CSRF 방어 원리

**문제**:
- 세션 ID만으로는 요청의 출처 확인 불가능
- 악성 사이트도 세션 쿠키를 이용한 요청 가능

**해결**:
- CSRF 토큰이라는 **추가 비밀 키** 사용
- 악성 사이트는 토큰을 알 수 없음

---

### CSRF vs 세션 ID 비교

| 항목 | 세션 ID | CSRF 토큰 |
|-----|---------|-----------|
| **역할** | 사용자 식별 (인증) | 요청 출처 검증 |
| **전달** | 쿠키 (자동) | 폼 데이터 (수동) |
| **공격자 접근** | 가능 (하이재킹) | 불가능 (예측 불가) |
| **보호 대상** | 인증 상태 | 요청 무결성 |

---

### 타임리프 자동 처리

**th:action 사용 시**:

```
th:action="@{/login}" + method="post"
    ↓
자동으로 CSRF 토큰 삽입
    ↓
개발자는 신경 쓸 필요 없음
```

**핵심**: 
- Spring Security + Thymeleaf 조합 시 CSRF 보호 자동
- 별도 코드 작성 불필요

---

# 5.3.16 CORS (Cross-Origin Resource Sharing)

## 5.3.16.1 CORS란 무엇인가?

**정의**: 다른 출처(Origin)의 리소스에 접근할 수 있도록 **서버가 명시적으로 허용**하는 HTTP 기반 메커니즘

### 동일 출처 정책 (SOP: Same-Origin Policy)

**브라우저의 기본 보안 정책**:

```
한 출처에서 로드된 문서나 스크립트가
다른 출처의 리소스와 상호작용하는 것을 제한
```

**목적**: 
- 악성 사이트가 다른 사이트의 데이터에 무단 접근하는 것을 방지
- 사용자 데이터 보호

**문제점**:
- 현대 웹 애플리케이션(특히 SPA)은 여러 출처 간 통신 필수
- 프론트엔드와 백엔드가 다른 도메인에서 실행되는 경우 많음

**해결책**: 
- CORS를 통해 **서버가 명시적으로 허용한 경우**에만 교차 출처 통신 가능

---

## 5.3.16.2 출처(Origin)란?

### Origin의 구성 요소

**정의**: 다음 세 가지 요소의 조합

```
프로토콜 + 호스트 + 포트
```

| 요소 | 예시 |
|-----|------|
| **프로토콜 (Protocol)** | `http`, `https` |
| **호스트 (Host/Domain)** | `example.com`, `localhost` |
| **포트 (Port)** | `:80`, `:8080` (표준 포트 80/443은 생략 가능) |

---

### 동일 출처 vs 다른 출처

**동일 출처 판단 기준**: 위 세 가지가 **모두 동일**해야 함

**비교 예시**:

| 요청 출처 | 접근 대상 | 동일 출처 여부 | 이유 |
|---------|---------|--------------|------|
| `https://a.com:8080` | `https://a.com:8080` | ✅ O | 모두 동일 |
| `http://a.com` | `https://a.com` | ❌ X | 프로토콜 다름 |
| `https://a.com` | `https://b.com` | ❌ X | 도메인 다름 |
| `https://a.com:80` | `https://a.com:8080` | ❌ X | 포트 다름 |

---

## 5.3.16.3 CORS의 작동 원리

### 기본 흐름

```
1. 클라이언트 (https://client.com)
   JavaScript가 https://api.server.com으로 요청
    ↓
2. 브라우저가 요청 헤더에 Origin 추가
   Origin: https://client.com
    ↓
3. 서버 (https://api.server.com)
   요청 받고 허용된 출처인지 확인
    ↓
4. 허용된 경우: 응답 헤더에 추가
   Access-Control-Allow-Origin: https://client.com
    ↓
5. 허용되지 않은 경우: 헤더 생략 또는 다른 값
    ↓
6. 브라우저가 응답 헤더 확인
    ↓
7. Origin이 일치하면 → JavaScript에 데이터 전달
   Origin이 불일치하면 → 차단 + CORS 오류
```

**핵심**: 
- 서버가 응답 헤더로 "이 출처는 허용한다"고 명시
- 브라우저가 최종 판단 및 차단

---

### 서버의 역할

**서버가 허용하는 방법**:

```
응답 헤더 추가:
Access-Control-Allow-Origin: https://client.com
```

**허용 패턴**:

| 헤더 값 | 의미 |
|--------|------|
| `https://client.com` | 특정 출처만 허용 |
| `*` | 모든 출처 허용 (공개 API) |

**주의**: 
- 와일드카드(`*`)는 보안상 신중하게 사용
- 인증이 필요한 API는 특정 출처만 허용 권장

---

## 5.3.16.4 페이지 이동 vs API 요청

**중요한 구분**:

### 1. 페이지 이동 (Top-level Navigation)

**예시**:
- 브라우저 주소창에 URL 입력
- `<a href="...">` 링크 클릭

**CORS 적용**: ❌ **적용되지 않음**

**이유**:
- 사용자의 명시적 의사에 따른 최상위 탐색
- 웹의 기본 탐색 기능 보장

```
사용자: https://example.com 접속
    ↓
브라우저: 페이지 로드 및 표시
    ↓
CORS 검사 없음 (항상 허용)
```

---

### 2. API 요청 (비동기 통신)

**예시**:
- JavaScript `fetch()` 호출
- `XMLHttpRequest` 사용

**CORS 적용**: ✅ **적용됨**

**이유**:
- 스크립트를 통한 데이터 접근 통제
- SOP의 제약 대상

```
JavaScript: fetch('https://api.server.com/data')
    ↓
브라우저: CORS 검사 수행
    ↓
서버 허용 여부에 따라 차단 또는 허용
```

---

### 비교표

| 요청 방식 | 주체 | 목적 | CORS 적용 | 결과 (기본 정책) |
|---------|------|------|----------|----------------|
| **페이지 이동** | 사용자 (브라우저 자체) | 웹 탐색 및 문서 로드 | ❌ X | 항상 허용 |
| **RESTful API 요청** | 스크립트 (JavaScript) | 데이터 접근 및 교환 | ✅ O | 다른 출처는 차단 |

---

## 5.3.16.5 Spring Security에서 CORS 설정

### CORS 설정 빈 생성

**CorsConfigurationSource 빈**:

```java
@Bean
CorsConfigurationSource corsConfigurationSource() {
    CorsConfiguration conf = new CorsConfiguration();
    
    // 허용할 출처 설정
    conf.setAllowedOrigins(
            List.of("https://hyechang.co.kr",
                    "https://woohyun.co.kr")
    );
    
    // 허용할 HTTP 메서드 설정
    conf.setAllowedMethods(
            List.of("GET", "POST")
    );
    
    // URL 패턴에 CORS 설정 적용
    UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
    source.registerCorsConfiguration("/**", conf);
    
    return source;
}
```

---

### SecurityFilterChain에 적용

```java
@Bean
public SecurityFilterChain securityFilterChain(
        HttpSecurity http,
        RememberMeServices rememberMeServices,
        CorsConfigurationSource corsConfigurationSource) throws Exception {
    
    http
        .cors(cors -> cors.configurationSource(corsConfigurationSource))
        .authorizeHttpRequests(/* ... */)
        .rememberMe(/* ... */)
        .formLogin(/* ... */)
        .logout(/* ... */);
    
    return http.build();
}
```

---

### 설정 분석

**1. 허용 출처 (AllowedOrigins)**:

```java
conf.setAllowedOrigins(
        List.of("https://hyechang.co.kr",
                "https://woohyun.co.kr")
);
```

**의미**:
- 오직 이 두 출처에서 들어오는 API 요청만 허용
- 다른 모든 출처는 차단

**차단되는 예시**:
- `https://naver.com`
- `http://localhost:3000`
- `https://hyechang.ac.kr` (하위 도메인도 별도 등록 필요)

---

**2. 허용 메서드 (AllowedMethods)**:

```java
conf.setAllowedMethods(
        List.of("GET", "POST")
);
```

**의미**:
- 허용된 출처에서도 `GET`, `POST` 메서드만 허용
- 다른 메서드는 차단

**차단되는 메서드**:
- `PUT`
- `DELETE`
- `PATCH`

---

**3. 경로 적용 (registerCorsConfiguration)**:

```java
source.registerCorsConfiguration("/**", conf);
```

**의미**:
- 위 CORS 규칙을 애플리케이션의 **모든 URL 경로**에 적용

**적용 범위**:
- `/api/members`
- `/api/products`
- `/member/list` 등 모든 경로

---

## 5.3.16.6 CORS 검증 시나리오

### 시나리오 1: 출처 불일치

**요청**:

```
GET http://localhost:8080/api/members
Header: Origin: https://sonny.co.kr
```

**서버 판단**:

```
허용된 출처 목록:
- https://hyechang.co.kr
- https://woohyun.co.kr
    ↓
https://sonny.co.kr는 목록에 없음
    ↓
Access-Control-Allow-Origin 헤더 생략
```

**결과**:

```
브라우저: CORS 정책 위반
    ↓
JavaScript 접근 차단
    ↓
콘솔 오류: "Invalid CORS request"
```

---

### 시나리오 2: 메서드 불일치

**요청**:

```
PUT http://localhost:8080/api/members
Header: Origin: https://hyechang.co.kr
```

**서버 판단**:

```
출처: https://hyechang.co.kr (✅ 허용됨)
메서드: PUT
    ↓
허용된 메서드 목록:
- GET
- POST
    ↓
PUT은 목록에 없음
    ↓
Access-Control-Allow-Methods 헤더에 PUT 미포함
```

**결과**:

```
브라우저: CORS 정책 위반
    ↓
콘솔 오류: "Invalid CORS request"
```

---

### 시나리오 3: 모두 일치 (성공)

**요청**:

```
POST http://localhost:8080/api/members
Header: Origin: https://hyechang.co.kr
```

**서버 판단**:

```
출처: https://hyechang.co.kr (✅ 허용됨)
메서드: POST (✅ 허용됨)
    ↓
응답 헤더 추가:
Access-Control-Allow-Origin: https://hyechang.co.kr
Access-Control-Allow-Methods: GET, POST
```

**결과**:

```
HTTP 200 OK
    ↓
브라우저: 헤더 확인
    ↓
Origin 일치 + Method 허용
    ↓
JavaScript에 데이터 전달 (성공)
```

---

## 5.3.16.7 실행 결과

### 테스트 환경

**API 엔드포인트**: `http://localhost:8080/api/members`

**테스트 도구**: Postman 또는 브라우저 개발자 도구

---

### 테스트 1: 출처 불일치

**요청**:

```http
GET /api/members HTTP/1.1
Host: localhost:8080
Origin: https://sonny.co.kr
```

**응답**:

```
Status: 403 Forbidden
Body: Invalid CORS request
```

**브라우저 콘솔**:

```
Access to fetch at 'http://localhost:8080/api/members' from origin 
'https://sonny.co.kr' has been blocked by CORS policy: 
No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

---

### 테스트 2: 메서드 불일치

**요청**:

```http
PUT /api/members HTTP/1.1
Host: localhost:8080
Origin: https://hyechang.co.kr
```

**응답**:

```
Status: 403 Forbidden
Body: Invalid CORS request
```

**브라우저 콘솔**:

```
Access to fetch at 'http://localhost:8080/api/members' from origin 
'https://hyechang.co.kr' has been blocked by CORS policy: 
Method PUT is not allowed by Access-Control-Allow-Methods.
```

---

### 테스트 3: 성공 케이스

**요청**:

```http
POST /api/members HTTP/1.1
Host: localhost:8080
Origin: https://hyechang.co.kr
Content-Type: application/json

{
  "name": "홍혜창",
  "email": "hyechang@spring.ac.kr"
}
```

**응답**:

```http
HTTP/1.1 200 OK
Access-Control-Allow-Origin: https://hyechang.co.kr
Access-Control-Allow-Methods: GET, POST
Content-Type: application/json

{
  "id": 1,
  "name": "홍혜창",
  "email": "hyechang@spring.ac.kr"
}
```

**결과**: ✅ 성공

---

## 5.3.16.8 CORS 허용 조건 표

**최종 정리**:

| 조건 | 요청 허용 여부 | 이유 |
|-----|--------------|------|
| **출처 불일치** | ❌ 거부 (차단) | AllowedOrigins에 없는 출처 |
| **메서드 불일치** | ❌ 거부 (차단) | AllowedMethods에 없는 메서드 |
| **출처 O + 메서드 O** | ✅ 허용 (통과) | 모든 조건 만족 |

---

## 5.3.16.9 CSRF vs CORS 비교

**헷갈리기 쉬운 두 개념**:

| 구분 | CSRF | CORS |
|-----|------|------|
| **정의** | 사이트 간 요청 위조 공격 | 교차 출처 리소스 공유 |
| **목적** | 위조 요청 방어 | 다른 출처 접근 허용 |
| **적용 대상** | 상태 변경 요청 (POST, PUT 등) | 모든 교차 출처 요청 |
| **검증 수단** | CSRF 토큰 | Origin 헤더 + 서버 응답 헤더 |
| **적용 시점** | 서버 측 검증 | 브라우저 측 차단 |
| **해결 방식** | 폼에 토큰 포함 | 서버가 허용 헤더 전송 |

---

### 함께 사용

**실무 설정**:

```java
@Bean
public SecurityFilterChain securityFilterChain(
        HttpSecurity http,
        CorsConfigurationSource corsConfigurationSource) throws Exception {
    
    http
        // CORS 설정 (교차 출처 허용)
        .cors(cors -> cors.configurationSource(corsConfigurationSource))
        
        // CSRF 설정 (위조 요청 방어)
        .csrf(csrf -> csrf
                .ignoringRequestMatchers("/api/**"))  // API는 CSRF 제외
        
        .authorizeHttpRequests(/* ... */)
        .formLogin(/* ... */)
        .logout(/* ... */);
    
    return http.build();
}
```

**패턴**:
- **일반 웹 페이지**: CSRF 보호 유지
- **RESTful API**: CORS 허용 + CSRF 제외

---

## 5.3.16.10 CORS 핵심 정리

### 작동 원리 요약

```
1. JavaScript가 다른 출처로 API 요청
    ↓
2. 브라우저가 Origin 헤더 추가
    ↓
3. 서버가 허용 여부 확인
    ↓
4. 허용 시: Access-Control-Allow-Origin 헤더 추가
   거부 시: 헤더 생략
    ↓
5. 브라우저가 헤더 확인
    ↓
6. 일치 → JavaScript에 데이터 전달
   불일치 → 차단 + CORS 오류
```

---

### Spring Security 설정 핵심

**필수 3단계**:

```java
// 1. CorsConfiguration 생성
CorsConfiguration conf = new CorsConfiguration();
conf.setAllowedOrigins(List.of("https://example.com"));
conf.setAllowedMethods(List.of("GET", "POST"));

// 2. UrlBasedCorsConfigurationSource 생성
UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
source.registerCorsConfiguration("/**", conf);

// 3. SecurityFilterChain에 적용
http.cors(cors -> cors.configurationSource(source))
```

---

### 중요 개념

| 개념 | 설명 |
|-----|------|
| **Origin** | 프로토콜 + 호스트 + 포트 |
| **SOP** | 브라우저의 동일 출처 정책 (기본 차단) |
| **CORS** | 서버가 명시적으로 허용 (SOP 완화) |
| **페이지 이동** | CORS 적용 안 됨 |
| **API 요청** | CORS 적용됨 |

---


