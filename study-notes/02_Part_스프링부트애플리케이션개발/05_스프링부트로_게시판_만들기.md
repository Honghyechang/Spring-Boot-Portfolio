# 05_스프링부트로_게시판_만들기

<!--
# 첫 작성 (5.1)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 웹 애플리케이션과 MVC 모델 추가

# 다음 업데이트 (5.2 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 템플릿 엔진과 타임리프 추가

# 다음 업데이트 (5.3 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 스프링 시큐리티 추가

# 마지막 완료 (5.4 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 게시판 애플리케이션 구현 완료
-->

## 📌 학습 목표
스프링 부트를 기반으로 한 웹 애플리케이션 개발 과정을 실전 프로젝트를 통해 익혀본다. 게시판 기능 구현을 통해 MVC 패턴, 타임리프 템플릿 엔진, 스프링 시큐리티, 데이터베이스 연동 등의 핵심 기술을 습득하고 실무에서 활용 가능한 웹 애플리케이션 설계 및 구현 능력을 체계적으로 학습한다.

---

## 목차

- [5.1 웹 애플리케이션과 MVC 모델](#51-웹-애플리케이션과-mvc-모델)
- [5.2 템플릿 엔진과 타임리프](#52-템플릿-엔진과-타임리프)
- [5.3 스프링 시큐리티](#53-스프링-시큐리티)
- [5.4 스프링 부트 게시판 애플리케이션 만들기](#54-스프링-부트-게시판-애플리케이션-만들기)

---

## 5.1 웹 애플리케이션과 MVC 모델

### 5.1.1 웹 애플리케이션 개발 방식의 이해

#### CSR vs SSR: 두 가지 웹 애플리케이션 개발 방식

현대 웹 애플리케이션 개발은 크게 두 가지 방식으로 나뉩니다.

| 구분 | RESTful API 서버 (CSR) | 웹 애플리케이션 서버 (SSR) |
|-----|----------------------|------------------------|
| **주요 역할** | 순수한 데이터(JSON, XML) 제공 | 완성된 View (HTML) 제공 |
| **렌더링 주체** | 클라이언트(브라우저) 측 렌더링 (CSR) | 서버 측 렌더링 (SSR) |
| **Spring 어노테이션** | `@RestController` 사용 | `@Controller` 사용 |
| **MVC View 역할** | 데이터를 담는 그릇 역할 (JSON/XML 데이터) | UI 화면을 구성하는 역할 (JSP, Thymeleaf 등 템플릿) |
| **협업 방식** | 프론트엔드/백엔드 역할 분리가 명확하여 협업 용이 | View 작업에서 백엔드 개발자와 디자이너의 협업 필요 |

---

#### CSR (Client-Side Rendering)

**정의**: 서버는 데이터만 제공하고, 클라이언트(브라우저)가 JavaScript를 사용하여 화면을 렌더링

**동작 흐름**:
```
1. 클라이언트 → 서버: HTTP 요청
2. 서버 → 클라이언트: JSON 데이터 응답
3. 클라이언트: JavaScript로 DOM 조작하여 화면 렌더링
```

**예시 (RESTful API)**:
```java
@RestController
@RequestMapping("/api/members")
public class MemberController {
    @GetMapping
    public List<MemberResponse> getMembers() {
        // JSON 데이터 반환
        return memberService.findAll();
    }
}
```

**장점**:
- ✅ 서버와 클라이언트의 역할이 명확히 분리
- ✅ 다양한 클라이언트 지원 가능 (웹, 모바일 앱, IoT)
- ✅ 초기 로딩 후 빠른 화면 전환

**단점**:
- ⚠️ 초기 로딩 속도가 느림 (JavaScript 다운로드 및 실행 필요)
- ⚠️ SEO(검색 엔진 최적화)에 불리

---

#### SSR (Server-Side Rendering)

**정의**: 서버가 완성된 HTML을 생성하여 클라이언트에게 전달

**동작 흐름**:
```
1. 클라이언트 → 서버: HTTP 요청
2. 서버: 템플릿 엔진으로 HTML 생성
3. 서버 → 클라이언트: 완성된 HTML 응답
4. 클라이언트: HTML을 바로 표시
```

**예시 (Spring MVC)**:
```java
@Controller
@RequestMapping("/members")
public class MemberController {
    @GetMapping("/list")
    public String getMembers(Model model) {
        // Model에 데이터 담기
        model.addAttribute("members", memberService.findAll());
        // View 이름 반환
        return "member-list";
    }
}
```

**장점**:
- ✅ 초기 로딩 속도가 빠름
- ✅ SEO(검색 엔진 최적화)에 유리
- ✅ JavaScript 없이도 동작 가능

**단점**:
- ⚠️ 서버 부하가 큼 (매번 HTML 생성)
- ⚠️ 화면 전환 시 전체 페이지 새로고침 필요

---

#### MVC 패턴은 CSR과 SSR 모두에서 사용

**중요한 개념**: RESTful API 서버(CSR)와 웹 애플리케이션 서버(SSR) 모두 MVC 패턴을 사용합니다!

**공통점**:
- Controller → Service → Repository 구조는 동일
- 비즈니스 로직과 데이터 처리 방식은 동일

**차이점**:
- **View의 역할**만 다름

| 구분 | RESTful API (@RestController) | 웹 애플리케이션 (@Controller) |
|-----|------------------------------|------------------------------|
| **Model** | DTO (Data Transfer Object) | DTO + Spring의 Model 객체 |
| **View** | JSON, XML (데이터 직렬화) | JSP, Thymeleaf (HTML 템플릿) |
| **Controller 반환** | DTO 객체 (자동으로 JSON 변환) | View 이름 (문자열) |

---

#### @RestController와 @Controller의 차이

**@RestController**:
```java
@RestController  // = @Controller + @ResponseBody
public class ApiController {
    @GetMapping("/api/members")
    public List<MemberResponse> getMembers() {
        return memberService.findAll();  // 자동으로 JSON 변환
    }
}
```

**작동 방식**:
1. 메서드 반환 값을 HTTP 응답 본문(Body)에 직접 쓰기
2. Jackson 라이브러리가 객체를 JSON으로 자동 변환
3. View Resolver를 거치지 않음

---

**@Controller**:
```java
@Controller
public class WebController {
    @GetMapping("/members/list")
    public String getMembers(Model model) {
        model.addAttribute("members", memberService.findAll());
        return "member-list";  // View 이름 반환
    }
}
```

**작동 방식**:
1. Model 객체에 데이터 저장
2. View 이름(문자열) 반환
3. View Resolver가 View를 찾아 렌더링
4. 완성된 HTML을 응답

---

#### 핵심 비교 표

| 항목 | @RestController (CSR) | @Controller (SSR) |
|-----|---------------------|------------------|
| **반환 값** | 데이터 객체 (DTO) | View 이름 (문자열) |
| **데이터 전달** | JSON으로 직렬화 | Model 객체에 담기 |
| **View 처리** | 없음 (JSON 응답) | View Resolver로 템플릿 찾기 |
| **최종 응답** | JSON 데이터 | 완성된 HTML |
| **클라이언트 역할** | JavaScript로 화면 렌더링 | HTML을 바로 표시 |

---

### 5.1.2 MVC 패턴의 이해

#### MVC 패턴이란?

**MVC (Model-View-Controller)**: 애플리케이션의 복잡성을 분리하고 관심사를 명확히 하기 위한 디자인 패턴

**핵심 목적**:
- 코드의 역할을 명확히 분리
- 유지보수성 향상
- 협업 효율성 증대

---

#### MVC의 세 가지 구성 요소

**1. Model (모델) - 데이터**

| 항목 | 설명 |
|-----|------|
| **역할** | 애플리케이션의 데이터와 비즈니스 로직 담당 |
| **책임** | - 데이터베이스에서 가져온 순수한 데이터<br>- View에 전달할 데이터를 담는 객체<br>- 비즈니스 규칙 처리 |
| **예시** | Entity, DTO, Service 계층 |
| **Spring 구현** | `Model` 인터페이스로 View에 데이터 전달 |

---

**2. View (뷰) - 화면**

| 항목 | 설명 |
|-----|------|
| **역할** | 사용자에게 보여줄 UI 화면 담당 |
| **책임** | - Model이 제공하는 데이터를 이용해 동적으로 HTML 생성<br>- 사용자 인터페이스 표현 |
| **예시** | JSP, Thymeleaf, HTML 템플릿 |
| **핵심 원칙** | 비즈니스 로직을 포함하지 않고 표현만 담당 |

---

**3. Controller (컨트롤러) - 로직**

| 항목 | 설명 |
|-----|------|
| **역할** | 클라이언트의 요청을 받아 처리하고 결과를 Model과 View에 전달하는 중개자 |
| **책임** | - HTTP 요청 수신<br>- Service 계층과 연동하여 비즈니스 로직 호출<br>- 처리 결과를 Model에 담아 View에 전달 |
| **예시** | `@Controller`, `@RestController` |
| **핵심 원칙** | 얇은 계층 유지 (비즈니스 로직은 Service에 위임) |

---

#### MVC 패턴의 데이터 흐름

```
클라이언트 (HTTP 요청)
    ↓
Controller (요청 수신, 흐름 제어)
    ↓
Service (비즈니스 로직 처리)
    ↓
Repository (데이터베이스 접근)
    ↓
Service (데이터 가공)
    ↓
Controller (Model에 데이터 담기)
    ↓
View (Model 데이터로 HTML 생성)
    ↓
클라이언트 (HTML 응답)
```

---

#### MVC 패턴의 장점

| 장점 | 설명 |
|-----|------|
| **관심사 분리** | 각 계층이 자신의 역할만 담당하여 코드가 명확 |
| **재사용성** | Model과 Controller는 여러 View에서 재사용 가능 |
| **유지보수성** | 한 계층의 변경이 다른 계층에 영향을 주지 않음 |
| **협업 효율** | 백엔드 개발자는 Controller와 Model, 프론트엔드 개발자는 View 담당 |
| **테스트 용이** | 각 계층을 독립적으로 테스트 가능 |

---

### 5.1.3 Model 1 vs Model 2 아키텍처

#### Model 1 아키텍처 (Java-in-HTML)

**특징**: HTML 코드 내에 Java 코드를 직접 삽입하여 데이터 처리와 화면 생성을 동시에 처리

**구조**:
```
클라이언트 → JSP (Java 코드 + HTML) → 데이터베이스
```

**예시 (fortune.jsp)**:

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>오늘의 운세</title>
</head>
<body>
<%
    // ⚠️ 비즈니스 로직이 HTML과 혼재
    String[] fortunes = {
        "오늘은 운이 아주 좋습니다",
        "무난한 하루!",
        "밤길을.. 조심하세요.",
        "컨디션 최고!"
    };
    int randomIndex = (int)(Math.random() * fortunes.length);
    String f = fortunes[randomIndex];
%>

<h2>오늘의 운세</h2>
<p><%= f %></p>
</body>
</html>
```

---

#### JSP 기본 문법

**1. 스크립틀릿 (Scriptlet): `<% Java 코드 %>`**

| 항목 | 설명 |
|-----|------|
| **형태** | `<% Java 코드 %>` |
| **역할** | 서버에서 실행할 순수한 Java 코드 블록 |
| **용도** | 변수 선언, 제어문(if, for), 객체 생성 등 |
| **출력** | 화면에 직접 출력하지 않음 |

**예시**:
```jsp
<%
    String name = "홍길동";
    int age = 30;
    
    if (age >= 20) {
        out.println("성인입니다.");
    }
%>
```

---

**2. 표현식 (Expression): `<%= 표현식 %>`**

| 항목 | 설명 |
|-----|------|
| **형태** | `<%= 표현식 %>` |
| **역할** | 결과를 웹 페이지에 출력할 Java 표현식 |
| **용도** | 변수 값, 메서드 호출 결과 출력 |
| **주의** | 세미콜론(`;`)을 붙이지 않음 |

**예시**:
```jsp
<p>이름: <%= name %></p>
<p>나이: <%= age %></p>
<p>현재 시간: <%= new java.util.Date() %></p>
```

---

#### Model 1 아키텍처의 문제점

| 문제점 | 설명 |
|-------|------|
| **관심사 혼재** | 웹 디자이너의 관심사(HTML)와 백엔드 개발자의 관심사(Java 로직)가 하나의 파일에 혼재 |
| **복잡도 증가** | Java 코드와 HTML이 뒤섞여 코드 가독성 저하 |
| **협업 어려움** | 디자이너가 Java 코드를 이해해야 하고, 개발자가 HTML 구조를 파악해야 함 |
| **유지보수 어려움** | 로직 변경 시 HTML 구조에 영향을 줄 수 있음 |
| **재사용성 낮음** | 비즈니스 로직이 JSP에 종속되어 다른 곳에서 재사용 불가 |

---

#### Model 2 아키텍처 (MVC 패턴)

**특징**: Controller와 View의 역할을 명확하게 분리하여 Model 1의 문제점 해결

**구조**:
```
클라이언트
    ↓
Controller (Java 클래스) - 로직 처리
    ↓
Model (데이터)
    ↓
View (JSP/Thymeleaf) - 화면 표현만 담당
```

---

#### Model 2 아키텍처의 장점

| 장점 | 설명 |
|-----|------|
| **역할 분리** | Controller는 데이터 처리 로직만, View는 화면 생성만 담당 |
| **협업 용이** | 백엔드 개발자는 Controller와 Model, 웹 디자이너는 View 전담 |
| **유지보수성** | 로직 변경 시 View에 영향 없음 |
| **재사용성** | 비즈니스 로직을 여러 View에서 공유 가능 |
| **테스트 편의** | Controller를 독립적으로 테스트 가능 |

---

#### Model 1 vs Model 2 비교

| 구분 | Model 1 | Model 2 (MVC) |
|-----|---------|--------------|
| **구조** | JSP (Java + HTML) | Controller (Java) + View (HTML) |
| **로직 위치** | JSP 내부 | Controller와 Service 계층 |
| **View 역할** | 로직 + 화면 | 화면 표현만 |
| **복잡도** | 높음 (혼재) | 낮음 (분리) |
| **협업** | 어려움 | 용이함 |
| **권장 여부** | ❌ 비권장 | ✅ 권장 |

---

### 5.1.4 Spring MVC의 동작 원리

#### Spring MVC 요청 처리 흐름 (7단계)

```
1. HTTP 요청
   ↓
2. DispatcherServlet (Front Controller)
   ↓
3. Controller 매핑
   ↓
4. Controller 실행 (로직 처리 + Model 준비)
   ↓
5. View Resolver (View 탐색)
   ↓
6. View 렌더링 (HTML 생성)
   ↓
7. HTTP 응답 (완성된 HTML)
```

---

#### 각 단계 상세 설명

**1단계: HTTP 요청**

```
클라이언트 (브라우저)
    ↓
GET /members/list HTTP/1.1
Host: localhost:8080
```

**설명**:
- 사용자가 브라우저에서 URL 입력 또는 링크 클릭
- HTTP 요청이 서버로 전송

---

**2단계: DispatcherServlet 처리**

```
톰캣 (서블릿 컨테이너)
    ↓
DispatcherServlet (Front Controller)
```

**DispatcherServlet의 역할**:

| 역할 | 설명 |
|-----|------|
| **Front Controller** | 모든 HTTP 요청을 가장 먼저 받는 단일 진입점 |
| **요청 분석** | URL, HTTP 메서드, 파라미터 분석 |
| **Controller 탐색** | 요청을 처리할 적절한 Controller 메서드 찾기 |
| **응답 관리** | 최종 응답을 클라이언트에게 전달 |

**핵심**: 개발자는 DispatcherServlet을 직접 다루지 않음. Spring Boot가 자동으로 설정!

---

**3단계: Controller 매핑**

```
DispatcherServlet
    ↓
HandlerMapping (요청 URL과 Controller 매핑)
    ↓
적절한 Controller 메서드 찾기
```

**동작 방식**:

| 요청 URL | HTTP 메서드 | 매핑되는 Controller 메서드 |
|---------|-----------|-------------------------|
| `/members/list` | GET | `@GetMapping("/members/list")` |
| `/members/create` | POST | `@PostMapping("/members/create")` |

---

**4단계: 로직 처리 및 Model 준비**

```java
@Controller
public class MemberController {
    @GetMapping("/members/list")
    public String memberList(Model model) {
        // 1. Service 호출
        List<Member> members = memberService.findAll();
        
        // 2. Model에 데이터 담기
        model.addAttribute("members", members);
        
        // 3. View 이름 반환
        return "member-list";
    }
}
```

**동작 순서**:

| 순서 | 동작 | 설명 |
|-----|------|------|
| 1 | Service/Repository 호출 | 비즈니스 로직 실행, 데이터베이스 조회 |
| 2 | Model에 데이터 저장 | `model.addAttribute("key", value)` |
| 3 | View 이름 반환 | 문자열로 View 이름 반환 (예: "member-list") |

---

#### Model 객체의 작동 원리

**Model 객체**: Spring이 제공하는 데이터 전달 객체

**생명주기**:

```
HTTP 요청 수신
    ↓
Spring이 새로운 Model 객체 생성
    ↓
Controller 메서드에 주입 (매개변수)
    ↓
개발자가 Model에 데이터 저장
    ↓
View로 Model 전달
    ↓
View가 Model에서 데이터 추출
    ↓
요청 종료 후 Model 객체 소멸
```

**핵심**: Model은 요청당 1개씩 생성되며, View에 데이터를 전달하는 임시 저장소 역할!

---

**Model 사용 예시**:

```java
// Controller
@GetMapping("/members/list")
public String memberList(Model model) {
    List<Member> members = memberService.findAll();
    
    // Model에 데이터 저장
    model.addAttribute("members", members);
    model.addAttribute("title", "회원 목록");
    
    return "member-list";
}
```

```jsp
<!-- View (JSP) -->
<h1>${title}</h1>  <!-- "회원 목록" 출력 -->

<table>
    <c:forEach items="${members}" var="member">
        <tr>
            <td>${member.name}</td>
        </tr>
    </c:forEach>
</table>
```

---

**5단계: View 탐색 및 Model 전달**

```
DispatcherServlet
    ↓
ViewResolver (View 이름으로 실제 파일 찾기)
    ↓
View 파일 로딩 (JSP, Thymeleaf 등)
    ↓
Model 데이터를 View에 전달
```

**ViewResolver 설정 (application.properties)**:

```properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

**동작 예시**:

| Controller 반환 값 | 설정 | 최종 View 경로 |
|------------------|------|--------------|
| `"member-list"` | prefix + suffix | `/WEB-INF/views/member-list.jsp` |
| `"members/detail"` | prefix + suffix | `/WEB-INF/views/members/detail.jsp` |

**핵심**: 개발자는 View 이름만 반환하면, ViewResolver가 실제 파일을 찾아줌!

---

**6단계: View 렌더링**

```
View (JSP/Thymeleaf)
    ↓
Model 데이터 추출
    ↓
동적 코드를 데이터로 치환
    ↓
최종 HTML 생성
```

**렌더링 과정 예시**:

```jsp
<!-- 렌더링 전 (JSP 템플릿) -->
<h1>${title}</h1>
<p>회원 수: ${members.size()}</p>

<!-- 렌더링 후 (순수 HTML) -->
<h1>회원 목록</h1>
<p>회원 수: 4</p>
```

**핵심**: 
- `${}` 같은 동적 코드는 서버에서 실제 데이터로 치환
- 클라이언트는 순수한 HTML만 받음

---

**7단계: 클라이언트 전달**

```
View 렌더링 완료
    ↓
DispatcherServlet이 최종 HTML 수신
    ↓
HTTP 응답으로 클라이언트에 전송
    ↓
브라우저가 HTML 표시
```

**HTTP 응답 예시**:

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8

<!DOCTYPE html>
<html>
<head><title>회원 목록</title></head>
<body>
    <h1>회원 목록</h1>
    <table>
        <tr><td>홍길동</td></tr>
        <tr><td>김철수</td></tr>
    </table>
</body>
</html>
```

---

#### Spring MVC 전체 흐름 다이어그램

```
┌─────────────┐
│ 클라이언트    │
│ (브라우저)    │
└──────┬──────┘
       │ HTTP GET /members/list
       ↓
┌─────────────────────────────────┐
│ 톰캣 (서블릿 컨테이너)             │
│  ┌───────────────────────────┐  │
│  │ DispatcherServlet         │  │
│  │ (Front Controller)        │  │
│  └───────────┬───────────────┘  │
└──────────────┼──────────────────┘
               │
               ↓
       ┌───────────────┐
       │ HandlerMapping │
       │ (Controller 찾기) │
       └───────┬───────┘
               ↓
       ┌───────────────────┐
       │ MemberController  │
       │ (로직 처리)         │
       └───────┬───────────┘
               │
               ↓
       ┌───────────────┐
       │ Service 계층   │
       └───────┬───────┘
               │
               ↓
       ┌───────────────┐
       │ Repository     │
       │ (DB 조회)      │
       └───────┬───────┘
               │
               ↓ (데이터 반환)
       ┌───────────────────┐
       │ Controller        │
       │ Model에 데이터 담기 │
       │ "member-list" 반환 │
       └───────┬───────────┘
               │
               ↓
       ┌───────────────┐
       │ ViewResolver  │
       │ (View 찾기)    │
       └───────┬───────┘
               │
               ↓
       ┌──────────────────────┐
       │ member-list.jsp      │
       │ (HTML 생성)          │
       └──────────┬───────────┘
                  │
                  ↓
┌─────────────────────────────────┐
│ DispatcherServlet               │
│ (최종 HTML 수신)                 │
└─────────────┬───────────────────┘
              │ HTML 응답
              ↓
       ┌─────────────┐
       │ 클라이언트    │
       │```
       │ (HTML 표시)  │
       └─────────────┘
```

---

### 5.1.5 JSP로 MVC 프로젝트 만들기

#### 프로젝트 생성 및 환경 설정

**1단계: Spring Initializr로 프로젝트 생성**

**중요한 설정**:

| 항목 | 설정 값 | 이유 |
|-----|---------|------|
| **Packaging** | **WAR** | JSP 사용을 위해 필수 (JAR로는 JSP 불가) |
| **Dependencies** | Spring Web, Lombok | 웹 애플리케이션 개발을 위한 최소 의존성 |

**주의**: Spring Boot 애플리케이션에서 JSP를 사용하려면 반드시 **WAR 파일**로 패키징해야 합니다!

---

#### WAR vs JAR: 패키징 방식의 이해

**JAR (Java Archive)**:

| 항목 | 설명 |
|-----|------|
| **정의** | Java 클래스, 리소스를 압축한 파일 |
| **용도** | 독립 실행형 애플리케이션 (내장 WAS 포함) |
| **실행 방식** | `java -jar app.jar` |
| **JSP 지원** | ❌ 불가능 (기술적 제약) |
| **권장 사용** | RESTful API 서버, Spring Boot 기본 |

---

**WAR (Web Application Archive)**:

| 항목 | 설명 |
|-----|------|
| **정의** | 웹 애플리케이션을 압축한 파일 |
| **용도** | 외부 WAS(Tomcat 등)에 배포 |
| **실행 방식** | 외부 Tomcat에 배포 후 실행 |
| **JSP 지원** | ✅ 가능 |
| **권장 사용** | JSP, 전통적인 MVC 웹 애플리케이션 |

---

#### 개발 환경과 배포 환경 분리

**현재 설정의 의미**:

```gradle
plugins {
    id 'java'
    id 'war'  // ← WAR 플러그인 사용
    id 'org.springframework.boot' version '3.5.7'
    id 'io.spring.dependency-management' version '1.1.7'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'  // ← 핵심!
    // ...
}
```

---

**개발/테스트 단계 (내장 Tomcat 사용)**:

| 항목 | 상태 | 설명 |
|-----|------|------|
| **실행 방식** | 내장 Tomcat 사용 | IntelliJ에서 실행하거나 테스트 시, Spring Boot가 제공하는 내장 Tomcat을 구동 |
| **Tomcat WAS** | 포함됨 (일시적) | `spring-boot-starter-web`에 의해 내장 Tomcat이 로드됨 |
| **동작 방식** | JAR처럼 실행 | `bootRun` 또는 IDE 실행 버튼으로 즉시 실행 가능 |
| **JSP 지원** | implementation으로 추가 필요 | 내장 Tomcat에는 JSP 컴파일러가 없으므로 별도 추가 |

**핵심**: 개발 단계에서는 외부 Tomcat 설치 없이 내장 Tomcat으로 빠르게 개발/테스트 가능!

---

**최종 배포 단계 (외부 Tomcat 사용)**:

| 항목 | 상태 | 설명 |
|-----|------|------|
| **패키징** | WAR 파일 | `providedRuntime` 설정과 WAR 플러그인 사용으로 최종 아티팩트는 WAR 파일 |
| **Tomcat WAS** | 미포함 | `providedRuntime 'spring-boot-starter-tomcat'` 덕분에 내장 Tomcat은 WAR 파일에서 제외됨 |
| **JSP 지원** | 외부 Tomcat에 의존 | 외부 Tomcat은 이미 자체 JSP 엔진(Jasper)을 가지고 있음 |
| **배포 방식** | WAR 파일을 외부 Tomcat에 배포 | 서버 리소스를 효율적으로 사용 가능 |

**핵심**: 배포 시에는 서버의 Tomcat을 사용하므로 애플리케이션에 Tomcat을 포함하지 않음!

---

#### 정리: JAR vs WAR 개발 방식

```
┌─────────────────────────────────────────┐
│ 개발/테스트 단계                          │
├─────────────────────────────────────────┤
│ - 내장 Tomcat 사용 (JAR처럼 동작)         │
│ - IDE에서 즉시 실행 가능                  │
│ - JSP 기능을 위해 Jasper 의존성 추가      │
│ - 빠른 개발과 테스트                      │
└─────────────────────────────────────────┘
                   ↓
                 빌드
                   ↓
┌─────────────────────────────────────────┐
│ 배포 단계                                 │
├─────────────────────────────────────────┤
│ - WAR 파일 생성                           │
│ - 내장 Tomcat 제외 (providedRuntime)     │
│ - 외부 Tomcat에 배포                      │
│ - 서버 자원 효율적 사용                    │
└─────────────────────────────────────────┘
```

**핵심 이해**:
- "개발 단계에서는 내장 Tomcat을 사용하는 JAR 상태이고"
- "배포 시에는 외부 Tomcat을 사용하는 WAR 파일로 배포된다!"

---

#### 2단계: 필수 의존성 추가

**build.gradle에 추가할 의존성**:

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
    
    // ✅ JSP 사용을 위한 필수 의존성 3가지
    implementation 'org.apache.tomcat.embed:tomcat-embed-jasper:10.1.40'
    implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:3.0.1'
    implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl:3.0.1'
}
```

---

#### JSP 관련 의존성 상세 설명

**1. tomcat-embed-jasper (JSP 엔진)**

```gradle
implementation 'org.apache.tomcat.embed:tomcat-embed-jasper:10.1.40'
```

**역할**: JSP 파일을 HTML로 변환하는 컴파일러

**필요한 이유**:

| 항목 | 설명 |
|-----|------|
| **Jasper란?** | JSP 파일을 서블릿(Java 클래스)으로 변환한 후 실행하여 HTML을 생성하는 Tomcat의 핵심 모듈 |
| **내장 Tomcat의 문제** | Spring Boot의 내장 Tomcat에는 Jasper 기능이 **기본적으로 빠져있음** |
| **해결 방법** | 수동으로 Jasper 의존성을 추가하여 내장 Tomcat에 JSP 처리 능력 부여 |
| **배포 시** | 외부 Tomcat에는 이미 Jasper가 있으므로 이 의존성은 무의미 (providedRuntime으로 변경 가능) |

**핵심**: "개발 단계에서 내장 Tomcat이 JSP를 실행할 수 있도록 JSP 엔진을 수동으로 주입하는 것!"

---

**2. JSTL API (표준 규격)**

```gradle
implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:3.0.1'
```

**역할**: JSTL 태그의 표준 규격(API) 정의

**내용**:
- JSTL 태그가 무엇인지 정의
- 어떤 메서드를 호출해야 하는지 규격 제시
- **이것만으로는 실행되지 않음** (인터페이스와 유사)

---

**3. JSTL 구현체**

```gradle
implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl:3.0.1'
```

**역할**: JSTL API의 실제 구현체

**내용**:
- `<c:forEach>`, `<c:if>` 같은 태그를 실제로 Java 로직으로 변환하여 실행
- API 규격을 받아서 실제 기능을 수행하는 구현 코드

**핵심**: API(규격) + 구현체(실제 코드) 두 가지를 모두 추가해야 JSTL 사용 가능!

---

#### JSTL을 사용하는 이유

**JSTL (JSP Standard Tag Library)**: JSP에서 자바 코드 사용을 최소화하고, HTML과 유사한 태그로 로직을 표현하는 라이브러리

**목적**: Model 2 아키텍처(MVC 패턴)의 View 역할에 충실하기 위함

---

**JSP 스크립틀릿 vs JSTL 비교**:

| 구분 | JSP 스크립틀릿 (`<% %>`) | JSTL 태그 (`<c:태그>`) |
|-----|------------------------|----------------------|
| **코드 분리** | HTML과 Java 로직이 혼재되어 복잡함 | 로직을 태그 형태로 캡슐화하여 표현과 로직 분리 |
| **가독성** | Java 문법이 섞여 있어 디자인 작업이 어려움 | HTML과 유사한 형태로 가독성이 높아짐 |
| **유지보수** | 로직 수정 시 HTML 구조에 영향을 줄 수 있음 | View는 데이터만 전달받아 표현만 담당하므로 유지보수 용이 |
| **협업** | 웹 디자이너가 Java 코드를 이해해야 함 | 태그 형태로 디자이너도 쉽게 이해 가능 |

---

**예시 비교**:

**스크립틀릿 사용 (Model 1 방식)**:
```jsp
<%
    List<Member> members = (List<Member>) request.getAttribute("members");
    for (Member member : members) {
%>
    <tr>
        <td><%= member.getId() %></td>
        <td><%= member.getName() %></td>
    </tr>
<%
    }
%>
```

**JSTL 사용 (Model 2 방식)**:
```jsp
<c:forEach items="${members}" var="member">
    <tr>
        <td>${member.id}</td>
        <td>${member.name}</td>
    </tr>
</c:forEach>
```

**핵심**: JSTL을 사용하면 JSP 파일의 가독성이 높아지고, View는 순수하게 표현 역할만 담당!

---

#### 3단계: application.properties 설정

**프로젝트 루트 경로 설정**:

```properties
spring.application.name=jspSample

# ViewResolver 설정
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

---

**설정 의미**:

| 설정 | 값 | 의미 |
|-----|-----|------|
| **prefix** | `/WEB-INF/views/` | JSP 파일이 위치한 디렉토리의 기본 경로 |
| **suffix** | `.jsp` | View 파일의 확장자 |

**작동 방식**:

```java
// Controller
return "member-list";

// ViewResolver가 자동 변환
// "/WEB-INF/views/" + "member-list" + ".jsp"
// = /WEB-INF/views/member-list.jsp
```

---

#### webapp 폴더 생성 이유

**중요**: Spring Boot 프로젝트 생성 시 `src/main/webapp` 폴더는 **자동으로 생성되지 않습니다**!

**이유**:

| 항목 | 설명 |
|-----|------|
| **Spring Boot 기본 방향** | JSP 대신 Thymeleaf 같은 템플릿 엔진 권장 |
| **WAR 파일 구조** | 웹 애플리케이션의 루트 디렉토리(`/`)는 관행적으로 `src/main/webapp`으로 지정됨 |
| **수동 생성 필요** | JSP를 사용하려면 개발자가 직접 폴더 구조를 만들어야 함 |

---

**필요한 폴더 구조**:

```
src/
└── main/
    ├── java/
    ├── resources/
    │   └── application.properties
    └── webapp/  ← 수동으로 생성!
        └── WEB-INF/  ← 수동으로 생성!
            └── views/  ← 수동으로 생성!
                └── member-list.jsp  ← JSP 파일 위치
```

**핵심**: JSP 파일은 반드시 `src/main/webapp/WEB-INF/views/` 경로에 위치해야 함!

---

#### WEB-INF 디렉토리의 특별한 의미

**WEB-INF**: 웹 애플리케이션의 보호된 영역

**특징**:

| 항목 | 설명 |
|-----|------|
| **직접 접근 불가** | 클라이언트가 브라우저에서 직접 접근할 수 없음 |
| **보안** | JSP 파일을 외부에 노출하지 않고 Controller를 통해서만 접근 가능 |
| **WAR 표준** | Java EE 웹 애플리케이션의 표준 디렉토리 구조 |

**예시**:

```
❌ 직접 접근 불가:
http://localhost:8080/WEB-INF/views/member-list.jsp
→ 404 Not Found

✅ Controller를 통한 접근만 가능:
http://localhost:8080/members/list
→ Controller가 member-list.jsp를 렌더링하여 응답
```

**핵심**: View 파일을 WEB-INF 안에 두면 보안성이 높아짐!

---

### 5.1.6 JSP와 JSTL을 사용한 View 작성

#### member-list.jsp 파일 작성

**파일 위치**: `src/main/webapp/WEB-INF/views/member-list.jsp`

```jsp
<%@ taglib prefix="c" uri="jakarta.tags.core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>회원 목록</title>
</head>
<body>
    <h1>회원 목록</h1>
    
    <table border="1">
        <thead>
            <tr>
                <th>ID</th>
                <th>이름</th>
                <th>이메일</th>
                <th>나이</th>
            </tr>
        </thead>
        <tbody>
            <c:forEach items="${members}" var="member">
                <tr>
                    <td>${member.id}</td>
                    <td>${member.name}</td>
                    <td>${member.email}</td>
                    <td>${member.age}</td>
                </tr>
            </c:forEach>
        </tbody>
    </table>
</body>
</html>
```

---

#### JSP 지시자 (Directive) 설명

**1. taglib 지시자**

```jsp
<%@ taglib prefix="c" uri="jakarta.tags.core" %>
```

**역할**: JSTL 라이브러리를 JSP 페이지에서 사용하겠다고 선언

| 속성 | 값 | 의미 |
|-----|-----|------|
| **prefix** | `"c"` | 이 라이브러리의 태그들을 `<c:태그이름>` 형태로 사용 |
| **uri** | `"jakarta.tags.core"` | 사용할 라이브러리의 종류 (Core 라이브러리) |

**핵심**: 이 선언 없이는 `<c:forEach>` 같은 JSTL 태그를 사용할 수 없음!

---

**2. page 지시자**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

**역할**: JSP 페이지의 설정 정보 지정

| 속성 | 값 | 의미 |
|-----|-----|------|
| **contentType** | `text/html;charset=UTF-8` | 응답의 콘텐츠 타입과 인코딩 지정 |
| **language** | `java` | JSP 페이지에서 사용할 스크립팅 언어 |

---

#### JSTL Core 태그 사용법

**<c:forEach> 태그**

```jsp
<c:forEach items="${members}" var="member">
    <!-- 반복할 내용 -->
</c:forEach>
```

**속성 설명**:

| 속성 | 설명 | 예시 |
|-----|------|------|
| **items** | 반복할 컬렉션 (Model에서 가져옴) | `${members}` |
| **var** | 현재 반복 요소를 담을 변수 이름 | `member` |

**동작 방식**:

```
1. Model에서 "members" 키로 저장된 List<Member> 가져오기
2. 리스트의 첫 번째 요소를 member 변수에 담기
3. <c:forEach> 블록 내부 실행
4. 다음 요소로 이동하여 2-3 반복
5. 모든 요소 처리 완료 시 종료
```

---

#### EL (Expression Language) 사용법

**${}의 역할**: Model이나 스코프에서 데이터를 읽어오는 표현식

**사용 시점**:

| 사용 목적 | 설명 | 예시 |
|---------|------|------|
| **Model 접근** | Controller가 Model에 담아준 데이터에 접근 | `${members}` |
| **속성 접근** | Java 객체의 속성(Property)에 접근 | `${member.id}` |

---

**1. Model에서 데이터 읽기**

```jsp
<c:forEach items="${members}" var="member">
```

**동작 과정**:

```
1. EL이 현재 JSP의 스코프를 탐색 (Page → Request → Session → Application)
2. "members"라는 이름의 객체를 찾음
3. 찾은 객체(List<Member>)를 items 속성에 할당
```

**핵심**: Controller가 `model.addAttribute("members", list)`로 저장한 데이터를 `${members}`로 읽어옴!

---

**2. 객체 속성 접근**

```jsp
${member.id}
${member.name}
```

**동작 원리**:

```
${member.id} 실행 시:
1. EL이 member 객체 찾기
2. .id를 만나면 자동으로 getId() 메서드 호출
3. 반환 값을 출력
```

**JavaBean 규약**:

| EL 표현식 | 실제 호출되는 메서드 | 필요한 어노테이션 |
|---------|------------------|----------------|
| `${member.id}` | `member.getId()` | `@Getter` (Lombok) |
| `${member.name}` | `member.getName()` | `@Getter` (Lombok) |
| `${member.email}` | `member.getEmail()` | `@Getter` (Lombok) |

**핵심**: 
- EL은 private 필드에 직접 접근하지 않음
- 반드시 Getter 메서드가 있어야 함
- Lombok의 `@Getter` 또는 `@Data`가 필요!

---

#### JSP 구문 요약

| 구문 | 형태 | 역할 | 예시 |
|-----|------|------|------|
| **지시자** | `<%@ ... %>` | JSP 페이지 설정 및 라이브러리 선언 | `<%@ taglib ... %>` |
| **JSTL 태그** | `<c:태그>` | 제어 구조, 반복문 등 로직 처리 | `<c:forEach ...>` |
| **EL** | `${}` | Model 데이터 또는 객체 속성 접근하여 값 출력 | `${member.name}` |

---

### 5.1.7 Model 객체 (DTO) 작성

#### Member.java 작성

**파일 위치**: `src/main/java/com/example/jspSample/model/Member.java`

```java
package com.example.jspSample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

---

#### Lombok 어노테이션 설명

**@Data**:

| 자동 생성 메서드 | 설명 |
|---------------|------|
| **Getter** | 모든 필드에 대한 getter 메서드 생성 |
| **Setter** | 모든 필드에 대한 setter 메서드 생성 |
| **toString()** | 객체의 문자열 표현 생성 |
| **equals()** | 객체 비교 메서드 |
| **hashCode()** | 해시코드 생성 |

**@AllArgsConstructor**: 모든 필드를 매개변수로 받는 생성자 자동 생성

```java
// 자동 생성되는 생성자
public Member(Long id, String name, String email, Integer age) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.age = age;
}
```

---

#### DTO와 Entity의 관계 (중요!)

**질문**: "이 Member 객체는 DTO인가요, Entity인가요?"

**답변**: 현재는 **DTO (Data Transfer Object)** 역할을 하고 있습니다.

---

**DTO vs Entity 비교**:

| 구분 | Entity (`@Entity`) | DTO (Data Transfer Object) |
|-----|-------------------|---------------------------|
| **역할** | 데이터베이스 테이블 매핑 | 계층 간 데이터 전송 |
| **사용 계층** | Repository, Service 내부 | Controller, View |
| **의존성** | JPA에 의존 (`@Entity`, `@Id` 등) | 순수 Java 객체 (POJO) |
| **목적** | 영속성 관리 (Persistence) | 데이터 전달 |
| **민감 정보** | 포함 가능 (password, 내부 필드 등) | 필요한 정보만 선택적으로 포함 |

---

**왜 Entity를 View에 직접 사용하지 않는가?**

이전 Chapter 4에서 배운 내용과 동일합니다!

| 이유 | 설명 |
|-----|------|
| **관심사 분리** | Entity는 DB 구조와 1:1 매핑. View가 Entity를 직접 알면 DB 변경 시 View도 수정해야 하는 강한 결합 발생 |
| **보안** | Entity에는 password, 내부 감사 필드 등 View에 불필요하거나 민감한 정보가 포함될 수 있음 |
| **유연성** | View는 표시에 필요한 필드만 포함한 DTO를 사용하여 독립적으로 변경 가능 |

---

**실무 사용 방식**:

```
┌────────────────────┐
│ Controller (표현)   │ ← DTO 사용
├────────────────────┤
│ Service (비즈니스)  │ ← Entity ↔ DTO 변환
├────────────────────┤
│ Repository (영속성) │ ← Entity 사용
└────────────────────┘
         ↕
    Database
```

**핵심**: 
- RESTful API든 SSR MVC든, DTO 패턴 사용은 동일!
- 차이점은 DTO를 **JSON으로 반환**하느냐, **Model에 담아 View로 전달**하느냐!

---

### 5.1.8 Controller 작성

#### MemberController.java 작성

**파일 위치**: `src/main/java/com/example/jspSample/controller/MemberController.java`

```java
package com.example.jspSample.controller;

import com.example.jspSample.model.Member;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

import java.util.List;

@Controller
public class MemberController {
    
    // 테스트용 더미 데이터
    List<Member> members = List.of(
            new Member(1L, "홍혜창", "hyechang@spring.ac.kr", 10),
            new Member(2L, "김우현", "kim@spring.ac.kr", 20),
            new Member(3L, "김구라", "gugu@spring.ac.kr", 15),
            new Member(4L, "홍길동", "hong@spring.ac.kr", 30)
    );

    @GetMapping("/members/list")
    public String memberList(Model model) {
        // Model에 데이터 담기
        model.addAttribute("members", members);
        
        // View 이름 반환
        return "member-list";
    }
}
```

---

#### @Controller와 Model 객체

**@Controller의 역할**:

| 역할 | 설명 |
|-----|------|
| **요청 매핑** | HTTP 요청 URL을 메서드와 연결 |
| **Service 호출** | 비즈니스 로직 처리를 Service에 위임 |
| **Model 준비** | View에 전달할 데이터를 Model에 담기 |
| **View 선택** | 렌더링할 View 이름 반환 |

**핵심**: Controller는 **얇은 계층(Thin Layer)**이어야 함. 비즈니스 로직은 Service에 위임!

---

#### Model 객체의 생명주기

**Model 객체**: Spring이 제공하는 데이터 컨테이너

**생명주기**:

```
HTTP 요청 수신
    ↓
Spring이 Model 객체 자동 생성
    ↓
Controller 메서드에 주입 (매개변수)
    ↓
개발자가 Model에 데이터 저장
    model.addAttribute("key", value);
    ↓
View에 Model 전달
    ↓
View가 Model에서 데이터 추출
    ${key}↓
요청 처리 완료 후 Model 객체 소멸
```

**핵심**: 
- Model은 요청당 1개씩 생성
- View에 데이터를 전달하는 임시 저장소
- 개발자는 생성/소멸을 신경 쓸 필요 없음

---

#### model.addAttribute() 메서드

```java
model.addAttribute("members", members);
```

**메서드 시그니처**:
```java
Model addAttribute(String name, Object value)
```

| 매개변수 | 타입 | 설명 | 예시 |
|---------|------|------|------|
| **name** | String | View에서 접근할 키 이름 | "members" |
| **value** | Object | 전달할 데이터 (모든 타입 가능) | List<Member> 객체 |

**사용 예시**:

```java
// 리스트 저장
model.addAttribute("members", memberList);

// 단일 객체 저장
model.addAttribute("member", member);

// 문자열 저장
model.addAttribute("title", "회원 목록");

// 숫자 저장
model.addAttribute("count", 100);
```

---

#### Controller 메서드 반환 값

**View 이름 반환**:

```java
return "member-list";
```

**처리 과정**:

```
1. Controller가 "member-list" 문자열 반환
    ↓
2. ViewResolver가 설정 확인
    prefix: /WEB-INF/views/
    suffix: .jsp
    ↓
3. 최종 경로 생성
    /WEB-INF/views/member-list.jsp
    ↓
4. 해당 JSP 파일 로딩 및 렌더링
```

**핵심**: 개발자는 View 이름만 반환하면, ViewResolver가 실제 파일을 찾아줌!

---

### 5.1.9 애플리케이션 실행 및 테스트

#### 메인 클래스 실행

**파일 위치**: `src/main/java/com/example/jspSample/JspSampleApplication.java`

```java
package com.example.jspSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JspSampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(JspSampleApplication.class, args);
    }
}
```

**실행 방법**:

| 방법 | 실행 방식 |
|-----|---------|
| **IDE** | IntelliJ의 Run 버튼 클릭 또는 `Shift + F10` |
| **Gradle** | Gradle 탭 → Tasks → application → bootRun 더블클릭 |
| **터미널** | `./gradlew bootRun` |

---

#### 브라우저에서 테스트

**접속 URL**:
```
http://localhost:8080/members/list
```

**브라우저의 동작**:
- 브라우저는 기본적으로 **GET 메서드**를 사용
- 주소창에 URL을 입력하면 자동으로 GET 요청 전송

---

**예상 결과**:

```
회원 목록

ID    이름      이메일                    나이
1     홍혜창    hyechang@spring.ac.kr    10
2     김우현    kim@spring.ac.kr         20
3     김구라    gugu@spring.ac.kr        15
4     홍길동    hong@spring.ac.kr        30
```

---

#### 전체 동작 흐름 확인

**요청부터 응답까지의 전체 과정**:

```
1. 브라우저
   GET http://localhost:8080/members/list
       ↓
2. 톰캣 (서블릿 컨테이너)
       ↓
3. DispatcherServlet (Front Controller)
       ↓
4. HandlerMapping
   "/members/list" → MemberController.memberList() 찾기
       ↓
5. MemberController.memberList(Model model) 실행
   - members 리스트 생성
   - model.addAttribute("members", members)
   - return "member-list"
       ↓
6. ViewResolver
   "member-list" → /WEB-INF/views/member-list.jsp
       ↓
7. JSP 엔진 (Jasper)
   - member-list.jsp 로딩
   - Model 데이터 전달
   - <c:forEach> 실행하여 HTML 생성
   - ${member.id} → getId() 호출
       ↓
8. 완성된 HTML
   <!DOCTYPE html>
   <html>
   <body>
       <table>
           <tr><td>1</td><td>홍혜창</td>...</tr>
           <tr><td>2</td><td>김우현</td>...</tr>
           ...
       </table>
   </body>
   </html>
       ↓
9. DispatcherServlet
   HTTP 응답으로 HTML 전송
       ↓
10. 브라우저
    HTML 렌더링 및 화면 표시
```

---

### 5.1.10 JSP의 한계와 문제점

지금까지 JSP를 사용한 MVC 패턴 구현을 학습했습니다. 하지만 JSP는 여러 가지 근본적인 한계를 가지고 있습니다.

---

#### 1. HTML과의 비호환성 (가장 큰 문제)

**문제의 본질**: JSP 파일 자체가 순수한 HTML이 아님

| 항목 | 설명 |
|-----|------|
| **JSP의 구성** | HTML + JSP 문법 (`<% %>`, `<%= %>`) + Java 코드 |
| **브라우저의 이해** | 브라우저는 오직 HTML, CSS, JavaScript만 해석 가능 |
| **결과** | JSP 파일을 로컬에서 바로 열면 브라우저가 JSP 문법을 무시하거나 텍스트로 표시 |

**예시**:

```jsp
<!-- JSP 파일 -->
<h1>회원 수: ${members.size()}</h1>

<!-- 브라우저에서 로컬 파일로 열면 -->
<h1>회원 수: ${members.size()}</h1>  ← 그대로 표시됨 (동작 안 함)
```

**핵심**: JSP는 반드시 서버를 거쳐 HTML로 변환되어야 함!

---

#### 2. 개발 및 디버깅의 비효율성

**서버 구동 필수**:

| 작업 | JSP | 순수 HTML |
|-----|-----|----------|
| **파일 수정** | 수정 | 수정 |
| **결과 확인** | 서버 재시작/리로딩 필요 | 브라우저 새로고침만으로 즉시 확인 |
| **개발 속도** | ⚠️ 느림 | ✅ 빠름 |

**문제 상황**:

```
1. CSS 색상 변경
    ↓
2. 서버 재시작 또는 리로딩
    ↓
3. 브라우저 새로고침
    ↓
4. 결과 확인
    ↓
5. 마음에 안 들면 1~4 반복
```

**핵심**: 간단한 UI 수정도 서버를 거쳐야 하므로 개발 피드백 주기가 느림!

---

#### 3. Jasper 엔진 의존성

**JSP 실행 과정**:

```
JSP 파일
    ↓
Jasper (JSP 컴파일러)
    ↓
서블릿 (Java 클래스)
    ↓
컴파일
    ↓
실행
    ↓
HTML 생성
```

**문제점**:

| 항목 | 설명 |
|-----|------|
| **복잡한 변환 과정** | JSP → 서블릿 → HTML의 다단계 변환 |
| **오버헤드** | 최초 요청 시 컴파일 시간 소요 |
| **디버깅 어려움** | 에러 발생 시 변환된 서블릿 코드를 확인해야 함 |
| **의존성** | Jasper 엔진이 없으면 JSP 실행 불가 (내장 Tomcat에 수동 추가 필요) |

---

#### 4. Model 1 문제의 잔재

**스크립틀릿의 유혹**:

JSP는 여전히 `<% %>` 스크립틀릿으로 Java 코드를 직접 작성할 수 있습니다.

```jsp
<%
    // ⚠️ View에 로직이 들어가는 안티 패턴
    if (members.size() > 10) {
        members = members.subList(0, 10);
    }
%>

<c:forEach items="${members}" var="member">
    <!-- ... -->
</c:forEach>
```

**문제점**:

| 문제 | 설명 |
|-----|------|
| **관심사 혼재** | View에 비즈니스 로직이 포함되어 MVC 원칙 위반 |
| **유지보수 어려움** | 로직이 Controller와 View에 분산 |
| **테스트 불가** | View의 로직은 단위 테스트 불가능 |

**핵심**: JSTL을 사용해도 스크립틀릿을 쓸 수 있어 개발자의 실수 가능성 존재!

---

#### 5. 현대적 프론트엔드와의 부조화

**프론트엔드 생태계**:

| 기술 | JSP와의 호환 | 이유 |
|-----|------------|------|
| **React, Vue, Angular** | ❌ 불가능 | JSP는 서버 렌더링 방식으로 JavaScript 프레임워크와 구조가 다름 |
| **npm, Webpack** | ❌ 어려움 | JSP는 Java 빌드 도구(Gradle, Maven)와 통합되어 있음 |
| **Component 기반 개발** | ❌ 불가능 | JSP는 페이지 기반 방식 |

**핵심**: 현대적 프론트엔드 기술과 함께 사용하기 어려움!

---

#### JSP 한계 요약

| 문제점 | 영향 | 대안 |
|-------|------|------|
| **HTML 비호환** | 로컬에서 확인 불가, 서버 필수 | Thymeleaf (Natural Templates) |
| **개발 속도 저하** | 피드백 주기 느림 | 핫 리로딩 지원 템플릿 엔진 |
| **Jasper 의존성** | 복잡한 변환 과정, 디버깅 어려움 | 단순한 템플릿 엔진 |
| **스크립틀릿 사용 가능** | MVC 원칙 위반 가능성 | 로직 실행 불가능한 템플릿 엔진 |
| **프론트엔드 부조화** | 현대 기술 스택과 통합 어려움 | RESTful API + SPA 또는 Thymeleaf |

---

### 5.1.11 핵심 정리

#### MVC 패턴의 핵심 개념

| 구성 요소 | 역할 | Spring 구현 |
|---------|------|-----------|
| **Model** | 데이터와 비즈니스 로직 | DTO, Entity, Service |
| **View** | 사용자 인터페이스 | JSP, Thymeleaf |
| **Controller** | 요청 처리 및 흐름 제어 | `@Controller`, `@RestController` |

**핵심**: 관심사를 명확히 분리하여 유지보수성과 협업 효율성 향상!

---

#### CSR vs SSR 비교

| 구분 | CSR (RESTful API) | SSR (Spring MVC) |
|-----|------------------|-----------------|
| **데이터 전달** | JSON | Model 객체 |
| **렌더링** | 클라이언트 (JavaScript) | 서버 (템플릿 엔진) |
| **반환 값** | 데이터 객체 (DTO) | View 이름 (문자열) |
| **어노테이션** | `@RestController` | `@Controller` |
| **최종 응답** | JSON | HTML |

**공통점**: 
- Controller → Service → Repository 구조는 동일
- DTO 패턴 사용은 동일

---

#### Model 1 vs Model 2

| 구분 | Model 1 | Model 2 (MVC) |
|-----|---------|--------------|
| **구조** | JSP (로직 + 화면) | Controller (로직) + View (화면) |
| **복잡도** | 높음 | 낮음 |
| **협업** | 어려움 | 용이함 |
| **유지보수** | 어려움 | 용이함 |
| **권장 여부** | ❌ | ✅ |

---

#### Spring MVC 요청 처리 흐름

```
클라이언트 요청
    ↓
DispatcherServlet (Front Controller)
    ↓
HandlerMapping (Controller 찾기)
    ↓
Controller (로직 처리, Model 준비)
    ↓
ViewResolver (View 찾기)
    ↓
View (HTML 생성)
    ↓
클라이언트 응답
```

---

#### JSP 프로젝트 설정 체크리스트

| 항목 | 설정 | 필수 여부 |
|-----|------|---------|
| **패키징** | WAR | ✅ 필수 |
| **Jasper 의존성** | `tomcat-embed-jasper` | ✅ 필수 |
| **JSTL 의존성** | API + 구현체 2개 | ✅ 필수 |
| **ViewResolver 설정** | prefix, suffix | ✅ 필수 |
| **webapp 폴더** | 수동 생성 | ✅ 필수 |
| **WEB-INF/views** | JSP 파일 위치 | ✅ 필수 |

---

#### JSP vs Thymeleaf 미리보기

다음 섹션(5.2)에서 학습할 Thymeleaf는 JSP의 한계를 극복한 현대적 템플릿 엔진입니다.

| 특징 | JSP | Thymeleaf |
|-----|-----|-----------|
| **HTML 호환성** | ❌ 비호환 | ✅ Natural Templates |
| **로컬 확인** | ❌ 불가능 | ✅ 가능 |
| **개발 속도** | ⚠️ 느림 | ✅ 빠름 |
| **로직 포함** | ⚠️ 가능 (스크립틀릿) | ❌ 불가능 (안전) |
| **Spring 통합** | ⚠️ 추가 설정 필요 | ✅ 기본 지원 |
| **권장 여부** | △ 레거시 | ✅ 권장 |

**핵심**: Thymeleaf는 JSP의 문제점을 해결하면서 MVC 패턴의 장점은 그대로 유지!
---

