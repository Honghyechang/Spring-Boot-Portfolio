# 05_스프링부트로_게시판_만들기

<!--
# 첫 작성 (5.1)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 웹 애플리케이션과 MVC 모델 추가

# 다음 업데이트 (5.2 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 템플릿 엔진과 타임리프 추가

# 다음 업데이트 (5.3 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 스프링 시큐리티 추가

# 마지막 완료 (5.4 추가)
docs: [Ch05] 스프링 부트로 게시판 만들기 - 게시판 애플리케이션 구현 완료
-->

## 📌 학습 목표
스프링 부트를 기반으로 한 웹 애플리케이션 개발 과정을 실전 프로젝트를 통해 익혀본다. 게시판 기능 구현을 통해 MVC 패턴, 타임리프 템플릿 엔진, 스프링 시큐리티, 데이터베이스 연동 등의 핵심 기술을 습득하고 실무에서 활용 가능한 웹 애플리케이션 설계 및 구현 능력을 체계적으로 학습한다.

---

## 목차

- [5.1 웹 애플리케이션과 MVC 모델](#51-웹-애플리케이션과-mvc-모델)
- [5.2 템플릿 엔진과 타임리프](#52-템플릿-엔진과-타임리프)
- [5.3 스프링 시큐리티](#53-스프링-시큐리티)
- [5.4 스프링 부트 게시판 애플리케이션 만들기](#54-스프링-부트-게시판-애플리케이션-만들기)

---

## 5.1 웹 애플리케이션과 MVC 모델

### 5.1.1 웹 애플리케이션 개발 방식의 이해

#### CSR vs SSR: 두 가지 웹 애플리케이션 개발 방식

현대 웹 애플리케이션 개발은 크게 두 가지 방식으로 나뉩니다.

| 구분 | RESTful API 서버 (CSR) | 웹 애플리케이션 서버 (SSR) |
|-----|----------------------|------------------------|
| **주요 역할** | 순수한 데이터(JSON, XML) 제공 | 완성된 View (HTML) 제공 |
| **렌더링 주체** | 클라이언트(브라우저) 측 렌더링 (CSR) | 서버 측 렌더링 (SSR) |
| **Spring 어노테이션** | `@RestController` 사용 | `@Controller` 사용 |
| **MVC View 역할** | 데이터를 담는 그릇 역할 (JSON/XML 데이터) | UI 화면을 구성하는 역할 (JSP, Thymeleaf 등 템플릿) |
| **협업 방식** | 프론트엔드/백엔드 역할 분리가 명확하여 협업 용이 | View 작업에서 백엔드 개발자와 디자이너의 협업 필요 |

---

#### CSR (Client-Side Rendering)

**정의**: 서버는 데이터만 제공하고, 클라이언트(브라우저)가 JavaScript를 사용하여 화면을 렌더링

**동작 흐름**:
```
1. 클라이언트 → 서버: HTTP 요청
2. 서버 → 클라이언트: JSON 데이터 응답
3. 클라이언트: JavaScript로 DOM 조작하여 화면 렌더링
```

**예시 (RESTful API)**:
```java
@RestController
@RequestMapping("/api/members")
public class MemberController {
    @GetMapping
    public List<MemberResponse> getMembers() {
        // JSON 데이터 반환
        return memberService.findAll();
    }
}
```

**장점**:
- ✅ 서버와 클라이언트의 역할이 명확히 분리
- ✅ 다양한 클라이언트 지원 가능 (웹, 모바일 앱, IoT)
- ✅ 초기 로딩 후 빠른 화면 전환

**단점**:
- ⚠️ 초기 로딩 속도가 느림 (JavaScript 다운로드 및 실행 필요)
- ⚠️ SEO(검색 엔진 최적화)에 불리

---

#### SSR (Server-Side Rendering)

**정의**: 서버가 완성된 HTML을 생성하여 클라이언트에게 전달

**동작 흐름**:
```
1. 클라이언트 → 서버: HTTP 요청
2. 서버: 템플릿 엔진으로 HTML 생성
3. 서버 → 클라이언트: 완성된 HTML 응답
4. 클라이언트: HTML을 바로 표시
```

**예시 (Spring MVC)**:
```java
@Controller
@RequestMapping("/members")
public class MemberController {
    @GetMapping("/list")
    public String getMembers(Model model) {
        // Model에 데이터 담기
        model.addAttribute("members", memberService.findAll());
        // View 이름 반환
        return "member-list";
    }
}
```

**장점**:
- ✅ 초기 로딩 속도가 빠름
- ✅ SEO(검색 엔진 최적화)에 유리
- ✅ JavaScript 없이도 동작 가능

**단점**:
- ⚠️ 서버 부하가 큼 (매번 HTML 생성)
- ⚠️ 화면 전환 시 전체 페이지 새로고침 필요

---

#### MVC 패턴은 CSR과 SSR 모두에서 사용

**중요한 개념**: RESTful API 서버(CSR)와 웹 애플리케이션 서버(SSR) 모두 MVC 패턴을 사용합니다!

**공통점**:
- Controller → Service → Repository 구조는 동일
- 비즈니스 로직과 데이터 처리 방식은 동일

**차이점**:
- **View의 역할**만 다름

| 구분 | RESTful API (@RestController) | 웹 애플리케이션 (@Controller) |
|-----|------------------------------|------------------------------|
| **Model** | DTO (Data Transfer Object) | DTO + Spring의 Model 객체 |
| **View** | JSON, XML (데이터 직렬화) | JSP, Thymeleaf (HTML 템플릿) |
| **Controller 반환** | DTO 객체 (자동으로 JSON 변환) | View 이름 (문자열) |

---

#### @RestController와 @Controller의 차이

**@RestController**:
```java
@RestController  // = @Controller + @ResponseBody
public class ApiController {
    @GetMapping("/api/members")
    public List<MemberResponse> getMembers() {
        return memberService.findAll();  // 자동으로 JSON 변환
    }
}
```

**작동 방식**:
1. 메서드 반환 값을 HTTP 응답 본문(Body)에 직접 쓰기
2. Jackson 라이브러리가 객체를 JSON으로 자동 변환
3. View Resolver를 거치지 않음

---

**@Controller**:
```java
@Controller
public class WebController {
    @GetMapping("/members/list")
    public String getMembers(Model model) {
        model.addAttribute("members", memberService.findAll());
        return "member-list";  // View 이름 반환
    }
}
```

**작동 방식**:
1. Model 객체에 데이터 저장
2. View 이름(문자열) 반환
3. View Resolver가 View를 찾아 렌더링
4. 완성된 HTML을 응답

---

#### 핵심 비교 표

| 항목 | @RestController (CSR) | @Controller (SSR) |
|-----|---------------------|------------------|
| **반환 값** | 데이터 객체 (DTO) | View 이름 (문자열) |
| **데이터 전달** | JSON으로 직렬화 | Model 객체에 담기 |
| **View 처리** | 없음 (JSON 응답) | View Resolver로 템플릿 찾기 |
| **최종 응답** | JSON 데이터 | 완성된 HTML |
| **클라이언트 역할** | JavaScript로 화면 렌더링 | HTML을 바로 표시 |

---

### 5.1.2 MVC 패턴의 이해

#### MVC 패턴이란?

**MVC (Model-View-Controller)**: 애플리케이션의 복잡성을 분리하고 관심사를 명확히 하기 위한 디자인 패턴

**핵심 목적**:
- 코드의 역할을 명확히 분리
- 유지보수성 향상
- 협업 효율성 증대

---

#### MVC의 세 가지 구성 요소

**1. Model (모델) - 데이터**

| 항목 | 설명 |
|-----|------|
| **역할** | 애플리케이션의 데이터와 비즈니스 로직 담당 |
| **책임** | - 데이터베이스에서 가져온 순수한 데이터<br>- View에 전달할 데이터를 담는 객체<br>- 비즈니스 규칙 처리 |
| **예시** | Entity, DTO, Service 계층 |
| **Spring 구현** | `Model` 인터페이스로 View에 데이터 전달 |

---

**2. View (뷰) - 화면**

| 항목 | 설명 |
|-----|------|
| **역할** | 사용자에게 보여줄 UI 화면 담당 |
| **책임** | - Model이 제공하는 데이터를 이용해 동적으로 HTML 생성<br>- 사용자 인터페이스 표현 |
| **예시** | JSP, Thymeleaf, HTML 템플릿 |
| **핵심 원칙** | 비즈니스 로직을 포함하지 않고 표현만 담당 |

---

**3. Controller (컨트롤러) - 로직**

| 항목 | 설명 |
|-----|------|
| **역할** | 클라이언트의 요청을 받아 처리하고 결과를 Model과 View에 전달하는 중개자 |
| **책임** | - HTTP 요청 수신<br>- Service 계층과 연동하여 비즈니스 로직 호출<br>- 처리 결과를 Model에 담아 View에 전달 |
| **예시** | `@Controller`, `@RestController` |
| **핵심 원칙** | 얇은 계층 유지 (비즈니스 로직은 Service에 위임) |

---

#### MVC 패턴의 데이터 흐름

```
클라이언트 (HTTP 요청)
    ↓
Controller (요청 수신, 흐름 제어)
    ↓
Service (비즈니스 로직 처리)
    ↓
Repository (데이터베이스 접근)
    ↓
Service (데이터 가공)
    ↓
Controller (Model에 데이터 담기)
    ↓
View (Model 데이터로 HTML 생성)
    ↓
클라이언트 (HTML 응답)
```

---

#### MVC 패턴의 장점

| 장점 | 설명 |
|-----|------|
| **관심사 분리** | 각 계층이 자신의 역할만 담당하여 코드가 명확 |
| **재사용성** | Model과 Controller는 여러 View에서 재사용 가능 |
| **유지보수성** | 한 계층의 변경이 다른 계층에 영향을 주지 않음 |
| **협업 효율** | 백엔드 개발자는 Controller와 Model, 프론트엔드 개발자는 View 담당 |
| **테스트 용이** | 각 계층을 독립적으로 테스트 가능 |

---

### 5.1.3 Model 1 vs Model 2 아키텍처

#### Model 1 아키텍처 (Java-in-HTML)

**특징**: HTML 코드 내에 Java 코드를 직접 삽입하여 데이터 처리와 화면 생성을 동시에 처리

**구조**:
```
클라이언트 → JSP (Java 코드 + HTML) → 데이터베이스
```

**예시 (fortune.jsp)**:

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>오늘의 운세</title>
</head>
<body>
<%
    // ⚠️ 비즈니스 로직이 HTML과 혼재
    String[] fortunes = {
        "오늘은 운이 아주 좋습니다",
        "무난한 하루!",
        "밤길을.. 조심하세요.",
        "컨디션 최고!"
    };
    int randomIndex = (int)(Math.random() * fortunes.length);
    String f = fortunes[randomIndex];
%>

<h2>오늘의 운세</h2>
<p><%= f %></p>
</body>
</html>
```

---

#### JSP 기본 문법

**1. 스크립틀릿 (Scriptlet): `<% Java 코드 %>`**

| 항목 | 설명 |
|-----|------|
| **형태** | `<% Java 코드 %>` |
| **역할** | 서버에서 실행할 순수한 Java 코드 블록 |
| **용도** | 변수 선언, 제어문(if, for), 객체 생성 등 |
| **출력** | 화면에 직접 출력하지 않음 |

**예시**:
```jsp
<%
    String name = "홍길동";
    int age = 30;
    
    if (age >= 20) {
        out.println("성인입니다.");
    }
%>
```

---

**2. 표현식 (Expression): `<%= 표현식 %>`**

| 항목 | 설명 |
|-----|------|
| **형태** | `<%= 표현식 %>` |
| **역할** | 결과를 웹 페이지에 출력할 Java 표현식 |
| **용도** | 변수 값, 메서드 호출 결과 출력 |
| **주의** | 세미콜론(`;`)을 붙이지 않음 |

**예시**:
```jsp
<p>이름: <%= name %></p>
<p>나이: <%= age %></p>
<p>현재 시간: <%= new java.util.Date() %></p>
```

---

#### Model 1 아키텍처의 문제점

| 문제점 | 설명 |
|-------|------|
| **관심사 혼재** | 웹 디자이너의 관심사(HTML)와 백엔드 개발자의 관심사(Java 로직)가 하나의 파일에 혼재 |
| **복잡도 증가** | Java 코드와 HTML이 뒤섞여 코드 가독성 저하 |
| **협업 어려움** | 디자이너가 Java 코드를 이해해야 하고, 개발자가 HTML 구조를 파악해야 함 |
| **유지보수 어려움** | 로직 변경 시 HTML 구조에 영향을 줄 수 있음 |
| **재사용성 낮음** | 비즈니스 로직이 JSP에 종속되어 다른 곳에서 재사용 불가 |

---

#### Model 2 아키텍처 (MVC 패턴)

**특징**: Controller와 View의 역할을 명확하게 분리하여 Model 1의 문제점 해결

**구조**:
```
클라이언트
    ↓
Controller (Java 클래스) - 로직 처리
    ↓
Model (데이터)
    ↓
View (JSP/Thymeleaf) - 화면 표현만 담당
```

---

#### Model 2 아키텍처의 장점

| 장점 | 설명 |
|-----|------|
| **역할 분리** | Controller는 데이터 처리 로직만, View는 화면 생성만 담당 |
| **협업 용이** | 백엔드 개발자는 Controller와 Model, 웹 디자이너는 View 전담 |
| **유지보수성** | 로직 변경 시 View에 영향 없음 |
| **재사용성** | 비즈니스 로직을 여러 View에서 공유 가능 |
| **테스트 편의** | Controller를 독립적으로 테스트 가능 |

---

#### Model 1 vs Model 2 비교

| 구분 | Model 1 | Model 2 (MVC) |
|-----|---------|--------------|
| **구조** | JSP (Java + HTML) | Controller (Java) + View (HTML) |
| **로직 위치** | JSP 내부 | Controller와 Service 계층 |
| **View 역할** | 로직 + 화면 | 화면 표현만 |
| **복잡도** | 높음 (혼재) | 낮음 (분리) |
| **협업** | 어려움 | 용이함 |
| **권장 여부** | ❌ 비권장 | ✅ 권장 |

---

### 5.1.4 Spring MVC의 동작 원리

#### Spring MVC 요청 처리 흐름 (7단계)

```
1. HTTP 요청
   ↓
2. DispatcherServlet (Front Controller)
   ↓
3. Controller 매핑
   ↓
4. Controller 실행 (로직 처리 + Model 준비)
   ↓
5. View Resolver (View 탐색)
   ↓
6. View 렌더링 (HTML 생성)
   ↓
7. HTTP 응답 (완성된 HTML)
```

---

#### 각 단계 상세 설명

**1단계: HTTP 요청**

```
클라이언트 (브라우저)
    ↓
GET /members/list HTTP/1.1
Host: localhost:8080
```

**설명**:
- 사용자가 브라우저에서 URL 입력 또는 링크 클릭
- HTTP 요청이 서버로 전송

---

**2단계: DispatcherServlet 처리**

```
톰캣 (서블릿 컨테이너)
    ↓
DispatcherServlet (Front Controller)
```

**DispatcherServlet의 역할**:

| 역할 | 설명 |
|-----|------|
| **Front Controller** | 모든 HTTP 요청을 가장 먼저 받는 단일 진입점 |
| **요청 분석** | URL, HTTP 메서드, 파라미터 분석 |
| **Controller 탐색** | 요청을 처리할 적절한 Controller 메서드 찾기 |
| **응답 관리** | 최종 응답을 클라이언트에게 전달 |

**핵심**: 개발자는 DispatcherServlet을 직접 다루지 않음. Spring Boot가 자동으로 설정!

---

**3단계: Controller 매핑**

```
DispatcherServlet
    ↓
HandlerMapping (요청 URL과 Controller 매핑)
    ↓
적절한 Controller 메서드 찾기
```

**동작 방식**:

| 요청 URL | HTTP 메서드 | 매핑되는 Controller 메서드 |
|---------|-----------|-------------------------|
| `/members/list` | GET | `@GetMapping("/members/list")` |
| `/members/create` | POST | `@PostMapping("/members/create")` |

---

**4단계: 로직 처리 및 Model 준비**

```java
@Controller
public class MemberController {
    @GetMapping("/members/list")
    public String memberList(Model model) {
        // 1. Service 호출
        List<Member> members = memberService.findAll();
        
        // 2. Model에 데이터 담기
        model.addAttribute("members", members);
        
        // 3. View 이름 반환
        return "member-list";
    }
}
```

**동작 순서**:

| 순서 | 동작 | 설명 |
|-----|------|------|
| 1 | Service/Repository 호출 | 비즈니스 로직 실행, 데이터베이스 조회 |
| 2 | Model에 데이터 저장 | `model.addAttribute("key", value)` |
| 3 | View 이름 반환 | 문자열로 View 이름 반환 (예: "member-list") |

---

#### Model 객체의 작동 원리

**Model 객체**: Spring이 제공하는 데이터 전달 객체

**생명주기**:

```
HTTP 요청 수신
    ↓
Spring이 새로운 Model 객체 생성
    ↓
Controller 메서드에 주입 (매개변수)
    ↓
개발자가 Model에 데이터 저장
    ↓
View로 Model 전달
    ↓
View가 Model에서 데이터 추출
    ↓
요청 종료 후 Model 객체 소멸
```

**핵심**: Model은 요청당 1개씩 생성되며, View에 데이터를 전달하는 임시 저장소 역할!

---

**Model 사용 예시**:

```java
// Controller
@GetMapping("/members/list")
public String memberList(Model model) {
    List<Member> members = memberService.findAll();
    
    // Model에 데이터 저장
    model.addAttribute("members", members);
    model.addAttribute("title", "회원 목록");
    
    return "member-list";
}
```

```jsp
<!-- View (JSP) -->
<h1>${title}</h1>  <!-- "회원 목록" 출력 -->

<table>
    <c:forEach items="${members}" var="member">
        <tr>
            <td>${member.name}</td>
        </tr>
    </c:forEach>
</table>
```

---

**5단계: View 탐색 및 Model 전달**

```
DispatcherServlet
    ↓
ViewResolver (View 이름으로 실제 파일 찾기)
    ↓
View 파일 로딩 (JSP, Thymeleaf 등)
    ↓
Model 데이터를 View에 전달
```

**ViewResolver 설정 (application.properties)**:

```properties
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

**동작 예시**:

| Controller 반환 값 | 설정 | 최종 View 경로 |
|------------------|------|--------------|
| `"member-list"` | prefix + suffix | `/WEB-INF/views/member-list.jsp` |
| `"members/detail"` | prefix + suffix | `/WEB-INF/views/members/detail.jsp` |

**핵심**: 개발자는 View 이름만 반환하면, ViewResolver가 실제 파일을 찾아줌!

---

**6단계: View 렌더링**

```
View (JSP/Thymeleaf)
    ↓
Model 데이터 추출
    ↓
동적 코드를 데이터로 치환
    ↓
최종 HTML 생성
```

**렌더링 과정 예시**:

```jsp
<!-- 렌더링 전 (JSP 템플릿) -->
<h1>${title}</h1>
<p>회원 수: ${members.size()}</p>

<!-- 렌더링 후 (순수 HTML) -->
<h1>회원 목록</h1>
<p>회원 수: 4</p>
```

**핵심**: 
- `${}` 같은 동적 코드는 서버에서 실제 데이터로 치환
- 클라이언트는 순수한 HTML만 받음

---

**7단계: 클라이언트 전달**

```
View 렌더링 완료
    ↓
DispatcherServlet이 최종 HTML 수신
    ↓
HTTP 응답으로 클라이언트에 전송
    ↓
브라우저가 HTML 표시
```

**HTTP 응답 예시**:

```
HTTP/1.1 200 OK
Content-Type: text/html;charset=UTF-8

<!DOCTYPE html>
<html>
<head><title>회원 목록</title></head>
<body>
    <h1>회원 목록</h1>
    <table>
        <tr><td>홍길동</td></tr>
        <tr><td>김철수</td></tr>
    </table>
</body>
</html>
```

---

#### Spring MVC 전체 흐름 다이어그램

```
┌─────────────┐
│ 클라이언트    │
│ (브라우저)    │
└──────┬──────┘
       │ HTTP GET /members/list
       ↓
┌─────────────────────────────────┐
│ 톰캣 (서블릿 컨테이너)             │
│  ┌───────────────────────────┐  │
│  │ DispatcherServlet         │  │
│  │ (Front Controller)        │  │
│  └───────────┬───────────────┘  │
└──────────────┼──────────────────┘
               │
               ↓
       ┌───────────────┐
       │ HandlerMapping │
       │ (Controller 찾기) │
       └───────┬───────┘
               ↓
       ┌───────────────────┐
       │ MemberController  │
       │ (로직 처리)         │
       └───────┬───────────┘
               │
               ↓
       ┌───────────────┐
       │ Service 계층   │
       └───────┬───────┘
               │
               ↓
       ┌───────────────┐
       │ Repository     │
       │ (DB 조회)      │
       └───────┬───────┘
               │
               ↓ (데이터 반환)
       ┌───────────────────┐
       │ Controller        │
       │ Model에 데이터 담기 │
       │ "member-list" 반환 │
       └───────┬───────────┘
               │
               ↓
       ┌───────────────┐
       │ ViewResolver  │
       │ (View 찾기)    │
       └───────┬───────┘
               │
               ↓
       ┌──────────────────────┐
       │ member-list.jsp      │
       │ (HTML 생성)          │
       └──────────┬───────────┘
                  │
                  ↓
┌─────────────────────────────────┐
│ DispatcherServlet               │
│ (최종 HTML 수신)                 │
└─────────────┬───────────────────┘
              │ HTML 응답
              ↓
       ┌─────────────┐
       │ 클라이언트    │
       │```
       │ (HTML 표시)  │
       └─────────────┘
```

---

### 5.1.5 JSP로 MVC 프로젝트 만들기

#### 프로젝트 생성 및 환경 설정

**1단계: Spring Initializr로 프로젝트 생성**

**중요한 설정**:

| 항목 | 설정 값 | 이유 |
|-----|---------|------|
| **Packaging** | **WAR** | JSP 사용을 위해 필수 (JAR로는 JSP 불가) |
| **Dependencies** | Spring Web, Lombok | 웹 애플리케이션 개발을 위한 최소 의존성 |

**주의**: Spring Boot 애플리케이션에서 JSP를 사용하려면 반드시 **WAR 파일**로 패키징해야 합니다!

---

#### WAR vs JAR: 패키징 방식의 이해

**JAR (Java Archive)**:

| 항목 | 설명 |
|-----|------|
| **정의** | Java 클래스, 리소스를 압축한 파일 |
| **용도** | 독립 실행형 애플리케이션 (내장 WAS 포함) |
| **실행 방식** | `java -jar app.jar` |
| **JSP 지원** | ❌ 불가능 (기술적 제약) |
| **권장 사용** | RESTful API 서버, Spring Boot 기본 |

---

**WAR (Web Application Archive)**:

| 항목 | 설명 |
|-----|------|
| **정의** | 웹 애플리케이션을 압축한 파일 |
| **용도** | 외부 WAS(Tomcat 등)에 배포 |
| **실행 방식** | 외부 Tomcat에 배포 후 실행 |
| **JSP 지원** | ✅ 가능 |
| **권장 사용** | JSP, 전통적인 MVC 웹 애플리케이션 |

---

#### 개발 환경과 배포 환경 분리

**현재 설정의 의미**:

```gradle
plugins {
    id 'java'
    id 'war'  // ← WAR 플러그인 사용
    id 'org.springframework.boot' version '3.5.7'
    id 'io.spring.dependency-management' version '1.1.7'
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'  // ← 핵심!
    // ...
}
```

---

**개발/테스트 단계 (내장 Tomcat 사용)**:

| 항목 | 상태 | 설명 |
|-----|------|------|
| **실행 방식** | 내장 Tomcat 사용 | IntelliJ에서 실행하거나 테스트 시, Spring Boot가 제공하는 내장 Tomcat을 구동 |
| **Tomcat WAS** | 포함됨 (일시적) | `spring-boot-starter-web`에 의해 내장 Tomcat이 로드됨 |
| **동작 방식** | JAR처럼 실행 | `bootRun` 또는 IDE 실행 버튼으로 즉시 실행 가능 |
| **JSP 지원** | implementation으로 추가 필요 | 내장 Tomcat에는 JSP 컴파일러가 없으므로 별도 추가 |

**핵심**: 개발 단계에서는 외부 Tomcat 설치 없이 내장 Tomcat으로 빠르게 개발/테스트 가능!

---

**최종 배포 단계 (외부 Tomcat 사용)**:

| 항목 | 상태 | 설명 |
|-----|------|------|
| **패키징** | WAR 파일 | `providedRuntime` 설정과 WAR 플러그인 사용으로 최종 아티팩트는 WAR 파일 |
| **Tomcat WAS** | 미포함 | `providedRuntime 'spring-boot-starter-tomcat'` 덕분에 내장 Tomcat은 WAR 파일에서 제외됨 |
| **JSP 지원** | 외부 Tomcat에 의존 | 외부 Tomcat은 이미 자체 JSP 엔진(Jasper)을 가지고 있음 |
| **배포 방식** | WAR 파일을 외부 Tomcat에 배포 | 서버 리소스를 효율적으로 사용 가능 |

**핵심**: 배포 시에는 서버의 Tomcat을 사용하므로 애플리케이션에 Tomcat을 포함하지 않음!

---

#### 정리: JAR vs WAR 개발 방식

```
┌─────────────────────────────────────────┐
│ 개발/테스트 단계                          │
├─────────────────────────────────────────┤
│ - 내장 Tomcat 사용 (JAR처럼 동작)         │
│ - IDE에서 즉시 실행 가능                  │
│ - JSP 기능을 위해 Jasper 의존성 추가      │
│ - 빠른 개발과 테스트                      │
└─────────────────────────────────────────┘
                   ↓
                 빌드
                   ↓
┌─────────────────────────────────────────┐
│ 배포 단계                                 │
├─────────────────────────────────────────┤
│ - WAR 파일 생성                           │
│ - 내장 Tomcat 제외 (providedRuntime)     │
│ - 외부 Tomcat에 배포                      │
│ - 서버 자원 효율적 사용                    │
└─────────────────────────────────────────┘
```

**핵심 이해**:
- "개발 단계에서는 내장 Tomcat을 사용하는 JAR 상태이고"
- "배포 시에는 외부 Tomcat을 사용하는 WAR 파일로 배포된다!"

---

#### 2단계: 필수 의존성 추가

**build.gradle에 추가할 의존성**:

```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    providedRuntime 'org.springframework.boot:spring-boot-starter-tomcat'
    
    // ✅ JSP 사용을 위한 필수 의존성 3가지
    implementation 'org.apache.tomcat.embed:tomcat-embed-jasper:10.1.40'
    implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:3.0.1'
    implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl:3.0.1'
}
```

---

#### JSP 관련 의존성 상세 설명

**1. tomcat-embed-jasper (JSP 엔진)**

```gradle
implementation 'org.apache.tomcat.embed:tomcat-embed-jasper:10.1.40'
```

**역할**: JSP 파일을 HTML로 변환하는 컴파일러

**필요한 이유**:

| 항목 | 설명 |
|-----|------|
| **Jasper란?** | JSP 파일을 서블릿(Java 클래스)으로 변환한 후 실행하여 HTML을 생성하는 Tomcat의 핵심 모듈 |
| **내장 Tomcat의 문제** | Spring Boot의 내장 Tomcat에는 Jasper 기능이 **기본적으로 빠져있음** |
| **해결 방법** | 수동으로 Jasper 의존성을 추가하여 내장 Tomcat에 JSP 처리 능력 부여 |
| **배포 시** | 외부 Tomcat에는 이미 Jasper가 있으므로 이 의존성은 무의미 (providedRuntime으로 변경 가능) |

**핵심**: "개발 단계에서 내장 Tomcat이 JSP를 실행할 수 있도록 JSP 엔진을 수동으로 주입하는 것!"

---

**2. JSTL API (표준 규격)**

```gradle
implementation 'jakarta.servlet.jsp.jstl:jakarta.servlet.jsp.jstl-api:3.0.1'
```

**역할**: JSTL 태그의 표준 규격(API) 정의

**내용**:
- JSTL 태그가 무엇인지 정의
- 어떤 메서드를 호출해야 하는지 규격 제시
- **이것만으로는 실행되지 않음** (인터페이스와 유사)

---

**3. JSTL 구현체**

```gradle
implementation 'org.glassfish.web:jakarta.servlet.jsp.jstl:3.0.1'
```

**역할**: JSTL API의 실제 구현체

**내용**:
- `<c:forEach>`, `<c:if>` 같은 태그를 실제로 Java 로직으로 변환하여 실행
- API 규격을 받아서 실제 기능을 수행하는 구현 코드

**핵심**: API(규격) + 구현체(실제 코드) 두 가지를 모두 추가해야 JSTL 사용 가능!

---

#### JSTL을 사용하는 이유

**JSTL (JSP Standard Tag Library)**: JSP에서 자바 코드 사용을 최소화하고, HTML과 유사한 태그로 로직을 표현하는 라이브러리

**목적**: Model 2 아키텍처(MVC 패턴)의 View 역할에 충실하기 위함

---

**JSP 스크립틀릿 vs JSTL 비교**:

| 구분 | JSP 스크립틀릿 (`<% %>`) | JSTL 태그 (`<c:태그>`) |
|-----|------------------------|----------------------|
| **코드 분리** | HTML과 Java 로직이 혼재되어 복잡함 | 로직을 태그 형태로 캡슐화하여 표현과 로직 분리 |
| **가독성** | Java 문법이 섞여 있어 디자인 작업이 어려움 | HTML과 유사한 형태로 가독성이 높아짐 |
| **유지보수** | 로직 수정 시 HTML 구조에 영향을 줄 수 있음 | View는 데이터만 전달받아 표현만 담당하므로 유지보수 용이 |
| **협업** | 웹 디자이너가 Java 코드를 이해해야 함 | 태그 형태로 디자이너도 쉽게 이해 가능 |

---

**예시 비교**:

**스크립틀릿 사용 (Model 1 방식)**:
```jsp
<%
    List<Member> members = (List<Member>) request.getAttribute("members");
    for (Member member : members) {
%>
    <tr>
        <td><%= member.getId() %></td>
        <td><%= member.getName() %></td>
    </tr>
<%
    }
%>
```

**JSTL 사용 (Model 2 방식)**:
```jsp
<c:forEach items="${members}" var="member">
    <tr>
        <td>${member.id}</td>
        <td>${member.name}</td>
    </tr>
</c:forEach>
```

**핵심**: JSTL을 사용하면 JSP 파일의 가독성이 높아지고, View는 순수하게 표현 역할만 담당!

---

#### 3단계: application.properties 설정

**프로젝트 루트 경로 설정**:

```properties
spring.application.name=jspSample

# ViewResolver 설정
spring.mvc.view.prefix=/WEB-INF/views/
spring.mvc.view.suffix=.jsp
```

---

**설정 의미**:

| 설정 | 값 | 의미 |
|-----|-----|------|
| **prefix** | `/WEB-INF/views/` | JSP 파일이 위치한 디렉토리의 기본 경로 |
| **suffix** | `.jsp` | View 파일의 확장자 |

**작동 방식**:

```java
// Controller
return "member-list";

// ViewResolver가 자동 변환
// "/WEB-INF/views/" + "member-list" + ".jsp"
// = /WEB-INF/views/member-list.jsp
```

---

#### webapp 폴더 생성 이유

**중요**: Spring Boot 프로젝트 생성 시 `src/main/webapp` 폴더는 **자동으로 생성되지 않습니다**!

**이유**:

| 항목 | 설명 |
|-----|------|
| **Spring Boot 기본 방향** | JSP 대신 Thymeleaf 같은 템플릿 엔진 권장 |
| **WAR 파일 구조** | 웹 애플리케이션의 루트 디렉토리(`/`)는 관행적으로 `src/main/webapp`으로 지정됨 |
| **수동 생성 필요** | JSP를 사용하려면 개발자가 직접 폴더 구조를 만들어야 함 |

---

**필요한 폴더 구조**:

```
src/
└── main/
    ├── java/
    ├── resources/
    │   └── application.properties
    └── webapp/  ← 수동으로 생성!
        └── WEB-INF/  ← 수동으로 생성!
            └── views/  ← 수동으로 생성!
                └── member-list.jsp  ← JSP 파일 위치
```

**핵심**: JSP 파일은 반드시 `src/main/webapp/WEB-INF/views/` 경로에 위치해야 함!

---

#### WEB-INF 디렉토리의 특별한 의미

**WEB-INF**: 웹 애플리케이션의 보호된 영역

**특징**:

| 항목 | 설명 |
|-----|------|
| **직접 접근 불가** | 클라이언트가 브라우저에서 직접 접근할 수 없음 |
| **보안** | JSP 파일을 외부에 노출하지 않고 Controller를 통해서만 접근 가능 |
| **WAR 표준** | Java EE 웹 애플리케이션의 표준 디렉토리 구조 |

**예시**:

```
❌ 직접 접근 불가:
http://localhost:8080/WEB-INF/views/member-list.jsp
→ 404 Not Found

✅ Controller를 통한 접근만 가능:
http://localhost:8080/members/list
→ Controller가 member-list.jsp를 렌더링하여 응답
```

**핵심**: View 파일을 WEB-INF 안에 두면 보안성이 높아짐!

---

### 5.1.6 JSP와 JSTL을 사용한 View 작성

#### member-list.jsp 파일 작성

**파일 위치**: `src/main/webapp/WEB-INF/views/member-list.jsp`

```jsp
<%@ taglib prefix="c" uri="jakarta.tags.core" %>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>회원 목록</title>
</head>
<body>
    <h1>회원 목록</h1>
    
    <table border="1">
        <thead>
            <tr>
                <th>ID</th>
                <th>이름</th>
                <th>이메일</th>
                <th>나이</th>
            </tr>
        </thead>
        <tbody>
            <c:forEach items="${members}" var="member">
                <tr>
                    <td>${member.id}</td>
                    <td>${member.name}</td>
                    <td>${member.email}</td>
                    <td>${member.age}</td>
                </tr>
            </c:forEach>
        </tbody>
    </table>
</body>
</html>
```

---

#### JSP 지시자 (Directive) 설명

**1. taglib 지시자**

```jsp
<%@ taglib prefix="c" uri="jakarta.tags.core" %>
```

**역할**: JSTL 라이브러리를 JSP 페이지에서 사용하겠다고 선언

| 속성 | 값 | 의미 |
|-----|-----|------|
| **prefix** | `"c"` | 이 라이브러리의 태그들을 `<c:태그이름>` 형태로 사용 |
| **uri** | `"jakarta.tags.core"` | 사용할 라이브러리의 종류 (Core 라이브러리) |

**핵심**: 이 선언 없이는 `<c:forEach>` 같은 JSTL 태그를 사용할 수 없음!

---

**2. page 지시자**

```jsp
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
```

**역할**: JSP 페이지의 설정 정보 지정

| 속성 | 값 | 의미 |
|-----|-----|------|
| **contentType** | `text/html;charset=UTF-8` | 응답의 콘텐츠 타입과 인코딩 지정 |
| **language** | `java` | JSP 페이지에서 사용할 스크립팅 언어 |

---

#### JSTL Core 태그 사용법

**<c:forEach> 태그**

```jsp
<c:forEach items="${members}" var="member">
    <!-- 반복할 내용 -->
</c:forEach>
```

**속성 설명**:

| 속성 | 설명 | 예시 |
|-----|------|------|
| **items** | 반복할 컬렉션 (Model에서 가져옴) | `${members}` |
| **var** | 현재 반복 요소를 담을 변수 이름 | `member` |

**동작 방식**:

```
1. Model에서 "members" 키로 저장된 List<Member> 가져오기
2. 리스트의 첫 번째 요소를 member 변수에 담기
3. <c:forEach> 블록 내부 실행
4. 다음 요소로 이동하여 2-3 반복
5. 모든 요소 처리 완료 시 종료
```

---

#### EL (Expression Language) 사용법

**${}의 역할**: Model이나 스코프에서 데이터를 읽어오는 표현식

**사용 시점**:

| 사용 목적 | 설명 | 예시 |
|---------|------|------|
| **Model 접근** | Controller가 Model에 담아준 데이터에 접근 | `${members}` |
| **속성 접근** | Java 객체의 속성(Property)에 접근 | `${member.id}` |

---

**1. Model에서 데이터 읽기**

```jsp
<c:forEach items="${members}" var="member">
```

**동작 과정**:

```
1. EL이 현재 JSP의 스코프를 탐색 (Page → Request → Session → Application)
2. "members"라는 이름의 객체를 찾음
3. 찾은 객체(List<Member>)를 items 속성에 할당
```

**핵심**: Controller가 `model.addAttribute("members", list)`로 저장한 데이터를 `${members}`로 읽어옴!

---

**2. 객체 속성 접근**

```jsp
${member.id}
${member.name}
```

**동작 원리**:

```
${member.id} 실행 시:
1. EL이 member 객체 찾기
2. .id를 만나면 자동으로 getId() 메서드 호출
3. 반환 값을 출력
```

**JavaBean 규약**:

| EL 표현식 | 실제 호출되는 메서드 | 필요한 어노테이션 |
|---------|------------------|----------------|
| `${member.id}` | `member.getId()` | `@Getter` (Lombok) |
| `${member.name}` | `member.getName()` | `@Getter` (Lombok) |
| `${member.email}` | `member.getEmail()` | `@Getter` (Lombok) |

**핵심**: 
- EL은 private 필드에 직접 접근하지 않음
- 반드시 Getter 메서드가 있어야 함
- Lombok의 `@Getter` 또는 `@Data`가 필요!

---

#### JSP 구문 요약

| 구문 | 형태 | 역할 | 예시 |
|-----|------|------|------|
| **지시자** | `<%@ ... %>` | JSP 페이지 설정 및 라이브러리 선언 | `<%@ taglib ... %>` |
| **JSTL 태그** | `<c:태그>` | 제어 구조, 반복문 등 로직 처리 | `<c:forEach ...>` |
| **EL** | `${}` | Model 데이터 또는 객체 속성 접근하여 값 출력 | `${member.name}` |

---

### 5.1.7 Model 객체 (DTO) 작성

#### Member.java 작성

**파일 위치**: `src/main/java/com/example/jspSample/model/Member.java`

```java
package com.example.jspSample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Member {
    private Long id;
    private String name;
    private String email;
    private Integer age;
}
```

---

#### Lombok 어노테이션 설명

**@Data**:

| 자동 생성 메서드 | 설명 |
|---------------|------|
| **Getter** | 모든 필드에 대한 getter 메서드 생성 |
| **Setter** | 모든 필드에 대한 setter 메서드 생성 |
| **toString()** | 객체의 문자열 표현 생성 |
| **equals()** | 객체 비교 메서드 |
| **hashCode()** | 해시코드 생성 |

**@AllArgsConstructor**: 모든 필드를 매개변수로 받는 생성자 자동 생성

```java
// 자동 생성되는 생성자
public Member(Long id, String name, String email, Integer age) {
    this.id = id;
    this.name = name;
    this.email = email;
    this.age = age;
}
```

---

#### DTO와 Entity의 관계 (중요!)

**질문**: "이 Member 객체는 DTO인가요, Entity인가요?"

**답변**: 현재는 **DTO (Data Transfer Object)** 역할을 하고 있습니다.

---

**DTO vs Entity 비교**:

| 구분 | Entity (`@Entity`) | DTO (Data Transfer Object) |
|-----|-------------------|---------------------------|
| **역할** | 데이터베이스 테이블 매핑 | 계층 간 데이터 전송 |
| **사용 계층** | Repository, Service 내부 | Controller, View |
| **의존성** | JPA에 의존 (`@Entity`, `@Id` 등) | 순수 Java 객체 (POJO) |
| **목적** | 영속성 관리 (Persistence) | 데이터 전달 |
| **민감 정보** | 포함 가능 (password, 내부 필드 등) | 필요한 정보만 선택적으로 포함 |

---

**왜 Entity를 View에 직접 사용하지 않는가?**

이전 Chapter 4에서 배운 내용과 동일합니다!

| 이유 | 설명 |
|-----|------|
| **관심사 분리** | Entity는 DB 구조와 1:1 매핑. View가 Entity를 직접 알면 DB 변경 시 View도 수정해야 하는 강한 결합 발생 |
| **보안** | Entity에는 password, 내부 감사 필드 등 View에 불필요하거나 민감한 정보가 포함될 수 있음 |
| **유연성** | View는 표시에 필요한 필드만 포함한 DTO를 사용하여 독립적으로 변경 가능 |

---

**실무 사용 방식**:

```
┌────────────────────┐
│ Controller (표현)   │ ← DTO 사용
├────────────────────┤
│ Service (비즈니스)  │ ← Entity ↔ DTO 변환
├────────────────────┤
│ Repository (영속성) │ ← Entity 사용
└────────────────────┘
         ↕
    Database
```

**핵심**: 
- RESTful API든 SSR MVC든, DTO 패턴 사용은 동일!
- 차이점은 DTO를 **JSON으로 반환**하느냐, **Model에 담아 View로 전달**하느냐!

---

### 5.1.8 Controller 작성

#### MemberController.java 작성

**파일 위치**: `src/main/java/com/example/jspSample/controller/MemberController.java`

```java
package com.example.jspSample.controller;

import com.example.jspSample.model.Member;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

import java.util.List;

@Controller
public class MemberController {
    
    // 테스트용 더미 데이터
    List<Member> members = List.of(
            new Member(1L, "홍혜창", "hyechang@spring.ac.kr", 10),
            new Member(2L, "김우현", "kim@spring.ac.kr", 20),
            new Member(3L, "김구라", "gugu@spring.ac.kr", 15),
            new Member(4L, "홍길동", "hong@spring.ac.kr", 30)
    );

    @GetMapping("/members/list")
    public String memberList(Model model) {
        // Model에 데이터 담기
        model.addAttribute("members", members);
        
        // View 이름 반환
        return "member-list";
    }
}
```

---

#### @Controller와 Model 객체

**@Controller의 역할**:

| 역할 | 설명 |
|-----|------|
| **요청 매핑** | HTTP 요청 URL을 메서드와 연결 |
| **Service 호출** | 비즈니스 로직 처리를 Service에 위임 |
| **Model 준비** | View에 전달할 데이터를 Model에 담기 |
| **View 선택** | 렌더링할 View 이름 반환 |

**핵심**: Controller는 **얇은 계층(Thin Layer)**이어야 함. 비즈니스 로직은 Service에 위임!

---

#### Model 객체의 생명주기

**Model 객체**: Spring이 제공하는 데이터 컨테이너

**생명주기**:

```
HTTP 요청 수신
    ↓
Spring이 Model 객체 자동 생성
    ↓
Controller 메서드에 주입 (매개변수)
    ↓
개발자가 Model에 데이터 저장
    model.addAttribute("key", value);
    ↓
View에 Model 전달
    ↓
View가 Model에서 데이터 추출
    ${key}↓
요청 처리 완료 후 Model 객체 소멸
```

**핵심**: 
- Model은 요청당 1개씩 생성
- View에 데이터를 전달하는 임시 저장소
- 개발자는 생성/소멸을 신경 쓸 필요 없음

---

#### model.addAttribute() 메서드

```java
model.addAttribute("members", members);
```

**메서드 시그니처**:
```java
Model addAttribute(String name, Object value)
```

| 매개변수 | 타입 | 설명 | 예시 |
|---------|------|------|------|
| **name** | String | View에서 접근할 키 이름 | "members" |
| **value** | Object | 전달할 데이터 (모든 타입 가능) | List<Member> 객체 |

**사용 예시**:

```java
// 리스트 저장
model.addAttribute("members", memberList);

// 단일 객체 저장
model.addAttribute("member", member);

// 문자열 저장
model.addAttribute("title", "회원 목록");

// 숫자 저장
model.addAttribute("count", 100);
```

---

#### Controller 메서드 반환 값

**View 이름 반환**:

```java
return "member-list";
```

**처리 과정**:

```
1. Controller가 "member-list" 문자열 반환
    ↓
2. ViewResolver가 설정 확인
    prefix: /WEB-INF/views/
    suffix: .jsp
    ↓
3. 최종 경로 생성
    /WEB-INF/views/member-list.jsp
    ↓
4. 해당 JSP 파일 로딩 및 렌더링
```

**핵심**: 개발자는 View 이름만 반환하면, ViewResolver가 실제 파일을 찾아줌!

---

### 5.1.9 애플리케이션 실행 및 테스트

#### 메인 클래스 실행

**파일 위치**: `src/main/java/com/example/jspSample/JspSampleApplication.java`

```java
package com.example.jspSample;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class JspSampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(JspSampleApplication.class, args);
    }
}
```

**실행 방법**:

| 방법 | 실행 방식 |
|-----|---------|
| **IDE** | IntelliJ의 Run 버튼 클릭 또는 `Shift + F10` |
| **Gradle** | Gradle 탭 → Tasks → application → bootRun 더블클릭 |
| **터미널** | `./gradlew bootRun` |

---

#### 브라우저에서 테스트

**접속 URL**:
```
http://localhost:8080/members/list
```

**브라우저의 동작**:
- 브라우저는 기본적으로 **GET 메서드**를 사용
- 주소창에 URL을 입력하면 자동으로 GET 요청 전송

---

**예상 결과**:

```
회원 목록

ID    이름      이메일                    나이
1     홍혜창    hyechang@spring.ac.kr    10
2     김우현    kim@spring.ac.kr         20
3     김구라    gugu@spring.ac.kr        15
4     홍길동    hong@spring.ac.kr        30
```

---

#### 전체 동작 흐름 확인

**요청부터 응답까지의 전체 과정**:

```
1. 브라우저
   GET http://localhost:8080/members/list
       ↓
2. 톰캣 (서블릿 컨테이너)
       ↓
3. DispatcherServlet (Front Controller)
       ↓
4. HandlerMapping
   "/members/list" → MemberController.memberList() 찾기
       ↓
5. MemberController.memberList(Model model) 실행
   - members 리스트 생성
   - model.addAttribute("members", members)
   - return "member-list"
       ↓
6. ViewResolver
   "member-list" → /WEB-INF/views/member-list.jsp
       ↓
7. JSP 엔진 (Jasper)
   - member-list.jsp 로딩
   - Model 데이터 전달
   - <c:forEach> 실행하여 HTML 생성
   - ${member.id} → getId() 호출
       ↓
8. 완성된 HTML
   <!DOCTYPE html>
   <html>
   <body>
       <table>
           <tr><td>1</td><td>홍혜창</td>...</tr>
           <tr><td>2</td><td>김우현</td>...</tr>
           ...
       </table>
   </body>
   </html>
       ↓
9. DispatcherServlet
   HTTP 응답으로 HTML 전송
       ↓
10. 브라우저
    HTML 렌더링 및 화면 표시
```

---

### 5.1.10 JSP의 한계와 문제점

지금까지 JSP를 사용한 MVC 패턴 구현을 학습했습니다. 하지만 JSP는 여러 가지 근본적인 한계를 가지고 있습니다.

---

#### 1. HTML과의 비호환성 (가장 큰 문제)

**문제의 본질**: JSP 파일 자체가 순수한 HTML이 아님

| 항목 | 설명 |
|-----|------|
| **JSP의 구성** | HTML + JSP 문법 (`<% %>`, `<%= %>`) + Java 코드 |
| **브라우저의 이해** | 브라우저는 오직 HTML, CSS, JavaScript만 해석 가능 |
| **결과** | JSP 파일을 로컬에서 바로 열면 브라우저가 JSP 문법을 무시하거나 텍스트로 표시 |

**예시**:

```jsp
<!-- JSP 파일 -->
<h1>회원 수: ${members.size()}</h1>

<!-- 브라우저에서 로컬 파일로 열면 -->
<h1>회원 수: ${members.size()}</h1>  ← 그대로 표시됨 (동작 안 함)
```

**핵심**: JSP는 반드시 서버를 거쳐 HTML로 변환되어야 함!

---

#### 2. 개발 및 디버깅의 비효율성

**서버 구동 필수**:

| 작업 | JSP | 순수 HTML |
|-----|-----|----------|
| **파일 수정** | 수정 | 수정 |
| **결과 확인** | 서버 재시작/리로딩 필요 | 브라우저 새로고침만으로 즉시 확인 |
| **개발 속도** | ⚠️ 느림 | ✅ 빠름 |

**문제 상황**:

```
1. CSS 색상 변경
    ↓
2. 서버 재시작 또는 리로딩
    ↓
3. 브라우저 새로고침
    ↓
4. 결과 확인
    ↓
5. 마음에 안 들면 1~4 반복
```

**핵심**: 간단한 UI 수정도 서버를 거쳐야 하므로 개발 피드백 주기가 느림!

---

#### 3. Jasper 엔진 의존성

**JSP 실행 과정**:

```
JSP 파일
    ↓
Jasper (JSP 컴파일러)
    ↓
서블릿 (Java 클래스)
    ↓
컴파일
    ↓
실행
    ↓
HTML 생성
```

**문제점**:

| 항목 | 설명 |
|-----|------|
| **복잡한 변환 과정** | JSP → 서블릿 → HTML의 다단계 변환 |
| **오버헤드** | 최초 요청 시 컴파일 시간 소요 |
| **디버깅 어려움** | 에러 발생 시 변환된 서블릿 코드를 확인해야 함 |
| **의존성** | Jasper 엔진이 없으면 JSP 실행 불가 (내장 Tomcat에 수동 추가 필요) |

---

#### 4. Model 1 문제의 잔재

**스크립틀릿의 유혹**:

JSP는 여전히 `<% %>` 스크립틀릿으로 Java 코드를 직접 작성할 수 있습니다.

```jsp
<%
    // ⚠️ View에 로직이 들어가는 안티 패턴
    if (members.size() > 10) {
        members = members.subList(0, 10);
    }
%>

<c:forEach items="${members}" var="member">
    <!-- ... -->
</c:forEach>
```

**문제점**:

| 문제 | 설명 |
|-----|------|
| **관심사 혼재** | View에 비즈니스 로직이 포함되어 MVC 원칙 위반 |
| **유지보수 어려움** | 로직이 Controller와 View에 분산 |
| **테스트 불가** | View의 로직은 단위 테스트 불가능 |

**핵심**: JSTL을 사용해도 스크립틀릿을 쓸 수 있어 개발자의 실수 가능성 존재!

---

#### 5. 현대적 프론트엔드와의 부조화

**프론트엔드 생태계**:

| 기술 | JSP와의 호환 | 이유 |
|-----|------------|------|
| **React, Vue, Angular** | ❌ 불가능 | JSP는 서버 렌더링 방식으로 JavaScript 프레임워크와 구조가 다름 |
| **npm, Webpack** | ❌ 어려움 | JSP는 Java 빌드 도구(Gradle, Maven)와 통합되어 있음 |
| **Component 기반 개발** | ❌ 불가능 | JSP는 페이지 기반 방식 |

**핵심**: 현대적 프론트엔드 기술과 함께 사용하기 어려움!

---

#### JSP 한계 요약

| 문제점 | 영향 | 대안 |
|-------|------|------|
| **HTML 비호환** | 로컬에서 확인 불가, 서버 필수 | Thymeleaf (Natural Templates) |
| **개발 속도 저하** | 피드백 주기 느림 | 핫 리로딩 지원 템플릿 엔진 |
| **Jasper 의존성** | 복잡한 변환 과정, 디버깅 어려움 | 단순한 템플릿 엔진 |
| **스크립틀릿 사용 가능** | MVC 원칙 위반 가능성 | 로직 실행 불가능한 템플릿 엔진 |
| **프론트엔드 부조화** | 현대 기술 스택과 통합 어려움 | RESTful API + SPA 또는 Thymeleaf |

---

### 5.1.11 핵심 정리

#### MVC 패턴의 핵심 개념

| 구성 요소 | 역할 | Spring 구현 |
|---------|------|-----------|
| **Model** | 데이터와 비즈니스 로직 | DTO, Entity, Service |
| **View** | 사용자 인터페이스 | JSP, Thymeleaf |
| **Controller** | 요청 처리 및 흐름 제어 | `@Controller`, `@RestController` |

**핵심**: 관심사를 명확히 분리하여 유지보수성과 협업 효율성 향상!

---

#### CSR vs SSR 비교

| 구분 | CSR (RESTful API) | SSR (Spring MVC) |
|-----|------------------|-----------------|
| **데이터 전달** | JSON | Model 객체 |
| **렌더링** | 클라이언트 (JavaScript) | 서버 (템플릿 엔진) |
| **반환 값** | 데이터 객체 (DTO) | View 이름 (문자열) |
| **어노테이션** | `@RestController` | `@Controller` |
| **최종 응답** | JSON | HTML |

**공통점**: 
- Controller → Service → Repository 구조는 동일
- DTO 패턴 사용은 동일

---

#### Model 1 vs Model 2

| 구분 | Model 1 | Model 2 (MVC) |
|-----|---------|--------------|
| **구조** | JSP (로직 + 화면) | Controller (로직) + View (화면) |
| **복잡도** | 높음 | 낮음 |
| **협업** | 어려움 | 용이함 |
| **유지보수** | 어려움 | 용이함 |
| **권장 여부** | ❌ | ✅ |

---

#### Spring MVC 요청 처리 흐름

```
클라이언트 요청
    ↓
DispatcherServlet (Front Controller)
    ↓
HandlerMapping (Controller 찾기)
    ↓
Controller (로직 처리, Model 준비)
    ↓
ViewResolver (View 찾기)
    ↓
View (HTML 생성)
    ↓
클라이언트 응답
```

---

#### JSP 프로젝트 설정 체크리스트

| 항목 | 설정 | 필수 여부 |
|-----|------|---------|
| **패키징** | WAR | ✅ 필수 |
| **Jasper 의존성** | `tomcat-embed-jasper` | ✅ 필수 |
| **JSTL 의존성** | API + 구현체 2개 | ✅ 필수 |
| **ViewResolver 설정** | prefix, suffix | ✅ 필수 |
| **webapp 폴더** | 수동 생성 | ✅ 필수 |
| **WEB-INF/views** | JSP 파일 위치 | ✅ 필수 |

---

#### JSP vs Thymeleaf 미리보기

다음 섹션(5.2)에서 학습할 Thymeleaf는 JSP의 한계를 극복한 현대적 템플릿 엔진입니다.

| 특징 | JSP | Thymeleaf |
|-----|-----|-----------|
| **HTML 호환성** | ❌ 비호환 | ✅ Natural Templates |
| **로컬 확인** | ❌ 불가능 | ✅ 가능 |
| **개발 속도** | ⚠️ 느림 | ✅ 빠름 |
| **로직 포함** | ⚠️ 가능 (스크립틀릿) | ❌ 불가능 (안전) |
| **Spring 통합** | ⚠️ 추가 설정 필요 | ✅ 기본 지원 |
| **권장 여부** | △ 레거시 | ✅ 권장 |

**핵심**: Thymeleaf는 JSP의 문제점을 해결하면서 MVC 패턴의 장점은 그대로 유지!
---


# 5.2 템플릿 엔진과 타임리프

## 5.2.1 템플릿 엔진의 이해

### 템플릿 엔진이란?

**템플릿 엔진(Template Engine)**은 미리 정의된 뼈대 파일(Template)에 동적인 데이터(Model)를 주입하여 최종 결과물을 만들어내는 소프트웨어입니다.

**템플릿 엔진의 핵심 역할**:

| 단계 | 역할 | 설명 |
|-----|------|------|
| **1. 템플릿 읽기** | View 파일 로딩 | Controller가 지정한 View 템플릿 파일을 찾아 읽기 |
| **2. 데이터 채우기** | 동적 데이터 주입 | Model에 담긴 데이터를 템플릿의 변수 영역에 삽입 |
| **3. 결과 생성** | 최종 HTML 생성 | 데이터가 채워진 완성된 HTML 문서 생성 |

---

### JSP도 템플릿 엔진인가?

네, **JSP(JavaServer Pages)**는 템플릿 엔진의 한 종류입니다.

**JSP 엔진의 작동 방식**:

| 기술 | 역할 | 처리 과정 |
|-----|------|---------|
| **JSP** | 템플릿 기술 | JSP 파일을 읽고 Model 데이터를 채워 HTML 생성 |
| **Jasper** | JSP 엔진 | JSP 문법과 Java 코드를 서블릿으로 변환(컴파일)하고 실행하여 HTML 생성 |

---

### JSP의 문제점과 타임리프의 등장

#### JSP의 근본적인 한계

**HTML과의 비호환성 문제**:

| 항목 | JSP | 문제점 |
|-----|-----|-------|
| **문법** | `<% %>`, `<%= %>` | 브라우저가 해석할 수 없는 JSP 전용 문법 |
| **로컬 실행** | 불가능 | 서버 없이 브라우저로 열면 코드가 깨지거나 의도대로 보이지 않음 |
| **개발 효율** | 낮음 | UI 확인을 위해 매번 서버 구동 필요 |
| **유지보수** | 어려움 | HTML과 Java 로직이 혼재 |

---

#### 타임리프의 해결책

**HTML 호환성 극대화**:

| 특징 | 설명 | 장점 |
|-----|------|------|
| **Natural Templates** | HTML 속성 형태의 문법 사용 | 서버 없이도 브라우저에서 View 구조 확인 가능 |
| **th: 접두사** | `th:text`, `th:each` 등 | HTML 표준을 유지하면서 동적 기능 제공 |
| **개발 효율** | 프론트엔드 독립 개발 | 백엔드 없이도 디자인 작업 가능 |

---

### 최신 웹 개발 동향

**템플릿 엔진의 선택**:

| 템플릿 엔진 | 사용 현황 | 특징 |
|-----------|----------|------|
| **JSP** | 감소 추세 | 레거시 시스템 유지보수용 |
| **Thymeleaf** | 증가 추세 | Spring Boot 공식 권장 |
| **FreeMarker** | 일부 사용 | 타임리프와 함께 사용되는 대안 |

**핵심**: 웹 개발에서 JSP 사용은 줄어들고, HTML 호환성을 극대화한 **타임리프(Thymeleaf)**로 전환되는 추세입니다.

---

### 개발자가 템플릿 엔진을 명시하는 이유

#### 1. SSR 구조를 명확히 함

"템플릿 엔진을 사용했다"는 말은 곧 **SSR (서버 측 렌더링) 방식**을 채택했다는 의미입니다.

**아키텍처 정보 전달**:

| 개발 방식 | 의미 | 특징 |
|---------|------|------|
| **템플릿 엔진 사용** | SSR 방식 | 서버가 HTML을 완성해서 전달 |
| **REST API만 개발** | CSR 방식 | 클라이언트가 JavaScript로 렌더링 |

---

#### 2. 기술 환경의 구체화

**템플릿 엔진별 전달되는 정보**:

| 템플릿 엔진 | 전달되는 기술 정보 | 의미 |
|-----------|-----------------|------|
| **Thymeleaf** | HTML 호환성 유지 | 현대적인 Spring Boot SSR 방식 |
| **JSP** | 전통적 방식 사용 | 레거시 시스템 유지보수 |
| **FreeMarker** | 대안 템플릿 엔진 | 특정 요구사항에 따른 선택 |

---

#### 3. 프론트엔드 작업 방식 예측

템플릿 엔진을 명시하면 다음을 예측할 수 있습니다:

- View 코드 작성 방식 (문법)
- 프론트엔드 개발자의 역할 범위
- 협업 방식

**결론**: Spring 개발자가 "View가 필요한 웹 애플리케이션을 만들었다"고 할 때는 어떤 템플릿 엔진을 사용했는지 명시하는 것이 기술 스택 설명의 필수 요소입니다.

---

## 5.2.2 타임리프 프로젝트 생성

### 1단계: 프로젝트 생성 및 의존성 추가

**build.gradle 설정**:

```gradle
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.5.7'
    id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(21)
    }
}

configurations {
    compileOnly {
        extendsFrom annotationProcessor
    }
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-thymeleaf'
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
    useJUnitPlatform()
}
```

---

### 템플릿 엔진 의존성 비교

**JSP vs Thymeleaf 의존성**:

| 템플릿 엔진 | 의존성 | 의미 |
|-----------|--------|------|
| **Thymeleaf** | `spring-boot-starter-thymeleaf` | 타임리프를 View 템플릿 엔진으로 사용 |
| **JSP** | `tomcat-embed-jasper`, `jakarta.servlet.jsp.jstl-api` | JSP를 View 엔진으로 사용 (수동 추가 필요) |

**핵심**: 
- **Thymeleaf**: Spring Boot가 자동으로 설정 지원
- **JSP**: 수동으로 의존성 추가 필요

---

### 2단계: View 파일 위치 설정

**JSP와 Thymeleaf의 View 위치 비교**:

| 템플릿 엔진 | View 파일 위치 | 확장자 |
|-----------|--------------|--------|
| **JSP** | `/src/main/webapp/WEB-INF/views/` | `.jsp` |
| **Thymeleaf** | `/src/main/resources/templates/` | `.html` |

**타임리프의 장점**:
- ✅ HTML 표준 확장자 사용
- ✅ `resources` 디렉토리에 위치하여 빌드 시 자동 포함
- ✅ 별도의 `webapp` 폴더 생성 불필요

---

### Controller 작성

**BasicController.java**:

```java
package com.example.thymeleafSample.controller;

import com.example.thymeleafSample.model.Member;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;

@Controller
public class BasicController {
    
    @GetMapping("/book")
    public String getBook(Model model) {
        model.addAttribute("title", "홍혜창의 이것의 스프링부트다");
        model.addAttribute("description", "예제를 통해 공부해보아용");
        
        Member hyechang = new Member("홍혜창", 20);
        model.addAttribute("member", hyechang);
        
        return "basic/book";
    }
}
```

**Controller 동작 방식**:

| 단계 | 동작 | 설명 |
|-----|------|------|
| 1 | `Model`에 데이터 담기 | `model.addAttribute()` 사용 |
| 2 | View 이름 반환 | `"basic/book"` 문자열 반환 |
| 3 | ViewResolver 작동 | `templates/basic/book.html` 파일 찾기 |
| 4 | 타임리프 엔진 실행 | Model 데이터로 HTML 생성 |

**핵심**: JSP와 Controller 사용 방식은 동일하며, View의 위치와 확장자만 다릅니다!

---

### View 템플릿 작성

**파일 위치**: `src/main/resources/templates/basic/book.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h1 th:text="${title}">책제목을 작성하는 부분!</h1>
    <p th:text="${description}">책 설명을 작성하는 부분</p>
    
    <p>
        글쓴이 : <span th:text="${member.name}">누구</span> 
        나이 : <span th:text="${member.age}">몇살</span>
    </p>
</body>
</html>
```

---

### 타임리프 선언의 의미

**xmlns:th 선언**:

```html
<html lang="en" xmlns:th="http://www.thymeleaf.org">
```

| 코드 | 역할 | 필수 여부 |
|-----|------|---------|
| `xmlns:th="..."` | 타임리프 네임스페이스 선언 | ✅ 필수 |
| **효과** | `th:` 접두사 사용 가능 | - |
| **없을 경우** | 타임리프 속성 인식 불가 | - |

**핵심**: 이 선언이 있어야만 `th:text`, `th:each` 같은 타임리프 속성을 사용할 수 있습니다!

---

### 🎯 IntelliJ 템플릿 자동 생성 설정 (팁)

매번 타임리프 기본 구조를 작성하는 것은 번거롭습니다. IntelliJ에서 자동 생성 템플릿을 설정할 수 있습니다.

**설정 방법**:

1. `Ctrl + Alt + S` (설정 열기)
2. `Editor` → `File and Code Templates` 선택
3. `+` 버튼 클릭 (새 템플릿 추가)
4. 다음 내용 입력:

**템플릿 이름**: `Thymeleaf`  
**확장자**: `html`  
**템플릿 내용**:

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
</html>
```

5. `Apply` → `OK` 클릭

**사용 방법**:
- 새 파일 생성 시 `Thymeleaf` 메뉴가 추가됨
- 선택하면 타임리프 기본 구조가 자동으로 삽입됨

---

## 5.2.3 타임리프의 핵심 원리

### 서버 구동 시 vs 서버 없이 실행

**타임리프의 두 가지 실행 모드**:

| 구분 | 서버 구동 시 (Controller 경유) | 서버 없이 (로컬 실행) |
|-----|------------------------------|---------------------|
| **타임리프 엔진** | 작동함 | 작동 안 함 |
| **th: 속성 처리** | Model 데이터로 대체됨 | 무시됨 |
| **결과** | 실제 데이터 출력 | HTML 기본값 출력 |

**실행 결과 비교**:

```
서버 구동 시 (http://localhost:8080/book):
- 홍혜창의 이것의 스프링부트다
- 예제를 통해 공부해보아용
- 글쓴이 : 홍혜창 나이 : 20

서버 없이 로컬 실행:
- 책제목을 작성하는 부분!
- 책 설명을 작성하는 부분
- 글쓴이 : 누구 나이 : 몇살
```

---

### Natural Templates의 장점

**프론트-백엔드 협업 구조**:

| 역할 | 작업 내용 | 필요 환경 |
|-----|---------|---------|
| **프론트엔드** | CSS/디자인 작업 | 서버 불필요 (로컬에서 HTML 열기) |
| **백엔드** | 데이터 준비 및 로직 | 서버 필요 (Controller 작성) |

**가상 데이터(Mock Data)의 역할**:

```html
<h1 th:text="${title}">책제목을 작성하는 부분!</h1>
```

- **"책제목을 작성하는 부분!"**: 프론트엔드가 디자인 시 참고하는 가상 데이터
- **`th:text="${title}"`**: 서버 구동 시 실제 데이터로 대체되는 부분

**핵심**: 프론트엔드와 백엔드는 **하나의 동일한 HTML 파일**을 공유하면서도, **서로 간섭 없이 독립적으로** 개발할 수 있습니다!

---

### JSP와 타임리프의 실행 방식 비교

| 항목 | JSP | Thymeleaf |
|-----|-----|-----------|
| **서버 없이 열기** | ❌ 불가능 (코드 깨짐) | ✅ 가능 (HTML로 표시) |
| **디자인 확인** | 서버 필수 | 브라우저만으로 가능 |
| **협업 효율** | 낮음 | 높음 |
| **개발 속도** | 느림 | 빠름 |

---

## 5.2.4 타임리프 기본 문법 소개

### 타임리프 핵심 속성 개요

타임리프의 주요 속성들을 간단히 소개합니다. 각 속성의 상세한 사용법은 뒤의 예제에서 자세히 다룹니다.

**핵심 속성 목록**:

| 속성 | 역할 | 간단 예시 |
|-----|------|---------|
| **th:text** | 텍스트 안전 출력 | `<p th:text="${title}">` |
| **th:utext** | HTML 태그 그대로 출력 | `<p th:utext="${html}">` |
| **th:href** | 동적 URL 생성 | `<a th:href="@{/users}">` |
| **th:if** | 조건부 렌더링 | `<p th:if="${isStudent}">` |
| **th:each** | 반복문 | `<li th:each="item : ${items}">` |
| **th:object** | 객체 선택 | `<div th:object="${member}">` |

**주의**: 이 섹션에서는 간단히 언급만 하고, 5.2.6 섹션에서 각 속성의 상세한 사용법과 예제를 다룹니다.

---

## 5.2.5 메시지 프로퍼티 (Message Properties)

### 메시지 프로퍼티란?

**정의**: 애플리케이션에서 사용하는 텍스트를 외부 파일로 분리하여 관리하는 방식

**파일 위치**: `src/main/resources/messages.properties`

**파일 이름 규칙**: 
- ⚠️ **`messages.properties`** (복수형 - 's' 필수!)
- ❌ `message.properties` (잘못된 이름)

---

### 메시지 프로퍼티 사용 목적

#### 1. 소스 코드 분리 (유지보수 용이)

**장점**:

| 항목 | 설명 |
|-----|------|
| **텍스트 수정** | 설정 파일만 수정하면 되므로 재컴파일 불필요 |
| **관리 편의성** | 모든 텍스트가 한 곳에 모여있어 관리 용이 |
| **사용 시점** | 변경 가능성이 있는 모든 고정 텍스트 |

---

#### 2. 국제화 (i18n) 지원

**장점**:

| 항목 | 설명 |
|-----|------|
| **다국어 지원** | 언어별 파일 분리 (`messages_ko.properties`, `messages_en.properties`) |
| **자동 선택** | 브라우저 언어 설정에 따라 자동으로 적절한 언어 파일 사용 |
| **유지보수** | 번역 텍스트를 코드 수정 없이 추가/변경 가능 |

---

### 메시지 프로퍼티 파일 작성

**messages.properties** (기본 파일):

```properties
welcome=(기본)홍혜창의 스프링부트에 오신 것을 환영합니다.
welcome.description=(기본)스프링부트는 <b>어렵지</b> 않아요!!!
```

**파일 규칙**:

| 항목 | 설명 | 예시 |
|-----|------|------|
| **형식** | `키=값` | `welcome=환영합니다` |
| **키 네이밍** | 점(`.`)으로 계층 구조 표현 | `welcome.description` |
| **HTML 태그** | 값에 HTML 포함 가능 | `<b>굵게</b>` |

---

### 메시지 프로퍼티 사용하기

**Controller 작성**:

```java
@GetMapping("/message")
public String getMessage() {
    return "message/message-basic";
}
```

**View 템플릿** (`message/message-basic.html`):

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h2 th:text="#{welcome}">제목</h2>
    <p th:text="#{welcome.description}"></p>
    <p th:utext="#{welcome.description}"></p>
</body>
</html>
```

**실행 결과**:

```
홍혜창의 스프링부트에 오신 것을 환영합니다.
스프링부트는 <b>어렵지</b> 않아요!!!
스프링부트는 어렵지 않아요!!!
```

---

### th:text vs th:utext

**차이점**:

| 속성 | 역할 | HTML 태그 처리 | 사용 시기 |
|-----|------|--------------|---------|
| **th:text** | 내용 안전 출력 | `<`를 `&lt;`로 치환 (Escape) | 대부분의 경우 (안전) |
| **th:utext** | 내용 그대로 출력 | HTML 태그 그대로 렌더링 | 신뢰할 수 있는 데이터만 |

**주의사항**: `th:utext`는 사용자 입력이 포함된 경우 XSS(Cross-Site Scripting) 공격에 취약할 수 있습니다!

---

### 메시지 표현식의 의미

**`#{키}` 문법**:

```html
<h2 th:text="#{welcome}">제목</h2>
```

**처리 과정**:

```
1. 타임리프 엔진이 #{welcome} 발견
    ↓
2. messages.properties 파일에서 'welcome' 키 검색
    ↓
3. 해당 값 ("홍혜창의 스프링부트에...") 가져오기
    ↓
4. <h2> 태그 내용으로 대체
```

---

## 5.2.6 메시지 파라미터 (플레이스홀더)

### 플레이스홀더란?

**정의**: 메시지 텍스트 내에서 동적 데이터가 삽입될 위치를 표시하는 자리 표시자

**문법**: `{0}`, `{1}`, `{2}` ...

---

### 플레이스홀더 사용 예제

**messages.properties**:

```properties
customer.contact={0} 고객님의 연락처는 {1}입니다.
```

**Controller**:

```java
@GetMapping("/customer")
public String getCustomer(Model model) {
    model.addAttribute("name", "홍혜창");
    model.addAttribute("phone", "010-1111-2222");
    return "message/message-customer";
}
```

**View 템플릿**:

```html
<p th:text="#{customer.contact(${name}, ${phone})}">고객정보</p>
```

**실행 결과**:

```
홍혜창 고객님의 연락처는 010-1111-2222입니다.
```

---

### 플레이스홀더 작동 원리

**매핑 규칙**:

| 메시지 파일 | 타임리프 코드 | 매핑 결과 |
|-----------|-------------|---------|
| `{0}` | `(${name}, ...` | 첫 번째 값 → {0}에 대체 |
| `{1}` | `..., ${phone})` | 두 번째 값 → {1}에 대체 |

**핵심**: 
- ✅ 플레이스홀더는 **순서 기반** (위치가 중요)
- ✅ 소괄호 `()` 안의 값들이 순서대로 매핑됨
- ⚠️ 개수가 맞지 않으면 빈 문자열 또는 에러 발생

---

### 여러 메시지 파일 사용하기

**messages.properties**:

```properties
customer.contact.long={0} 고객님 환영합니다. 오랜만에 방문하셨네요! 전화번호 {1} 맞으시죠?
customer.contact.short={0} : {1}
```

**동적 메시지 키 선택**:

```java
@GetMapping("/customer")
public String getCustomer(Model model) {
    model.addAttribute("type", "customer.contact.long");
    model.addAttribute("name", "홍혜창");
    model.addAttribute("phone", "010-1111-2222");
    return "message/message-customer";
}
```

**View 템플릿**:

```html
<p th:text="#{${type}(${name}, ${phone})}"></p>
```

---

### 중첩 표현식의 이해

**`#{${type}(...)}`의 의미**:

| 평가 순서 | 구문 | 역할 |
|---------|------|------|
| **1순위** | `${type}` | Model에서 "customer.contact.long" 문자열 가져오기 |
| **2순위** | `#{...}` | 가져온 키로 메시지 파일 검색 |
| **3순위** | `(${name}, ${phone})` | 플레이스홀더에 값 주입 |

**실행 결과**:

```
홍혜창 고객님 환영합니다. 오랜만에 방문하셨네요! 전화번호 010-1111-2222 맞으시죠?
```

**핵심**: 메시지 키 자체를 동적으로 결정할 수 있어 유연성이 극대화됩니다!

---

### 실무 활용 사례

**상황별 동적 메시지**:

| 사용 사례 | Model 데이터 | 메시지 키 |
|---------|------------|---------|
| **상품 상태** | `type = "product.status.SHIPPED"` | `#{${type}}` |
| **유효성 검증** | `type = "error.email.invalid"` | `#{${type}}` |
| **알림 메시지** | `type = "notification.order.complete"` | `#{${type}}` |

**장점**:
- ✅ 코드 중복 제거
- ✅ 유지보수 편의성 향상
- ✅ 다국어 지원 용이

---

## 5.2.7 국제화 (Internationalization, i18n)

### 국제화란?

**정의**: 사용자의 언어 설정에 따라 자동으로 해당 언어의 텍스트를 제공하는 기능

---

### 언어별 메시지 파일 분리

**파일 명명 규칙**:

```
기본 이름 + 언더바 + 로케일 코드 + .properties
```

**파일 구조**:

| 파일명 | 역할 | 로케일 |
|-------|------|--------|
| **messages.properties** | 기본값 (Fallback) | 없음 (기본) |
| **messages_ko.properties** | 한국어 | ko |
| **messages_en.properties** | 영어 | en |

---

### 언어별 메시지 파일 작성

**messages_ko.properties**:

```properties
welcome=홍혜창의 스프링부트에 오신 것을 환영합니다.
welcome.description=스프링부트는 <b>어렵지</b> 않아요!!!
```

**messages_en.properties**:

```properties
welcome=Welcome to hyechang spring!!
welcome.description=Spring boot is not <b>difficult</b>
```

---

### 국제화 자동 작동 원리

**Spring의 로케일 해결 과정**:

```
1. HTTP 요청 수신
    ↓
2. Accept-Language 헤더 확인↓
3. 로케일 감지 (예: ko, en)
    ↓
4. 해당 언어 파일 선택 (messages_ko.properties)
    ↓
5. 메시지 키로 값 검색
    ↓
6. View에 텍스트 삽입
```

**핵심**: 개발자가 언어 선택 로직을 작성할 필요 없이, Spring이 자동으로 처리합니다!

---

### Controller 작성

```java
@GetMapping("/language")
public String getLanguage(HttpServletRequest request) {
    // Accept-Language 헤더 확인 (로깅용)
    String acceptLanguage = request.getHeader("Accept-Language");
    log.info("Request Accept-Language Header: {}", acceptLanguage);
    
    return "basic/language-basic";
}
```

---

### View 템플릿

**language-basic.html**:

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <h th:text="#{welcome}"></h>
    <p th:utext="#{welcome.description}"></p>
</body>
</html>
```

---

### 브라우저 언어 설정에 따른 결과

**케이스 1: 한국어 우선순위가 높은 경우**

**브라우저 설정**:
```
1. 한국어
2. 영어(미국)
3. 영어
```

**실행 결과**:
```
홍혜창의 스프링부트에 오신 것을 환영합니다.
스프링부트는 어렵지 않아요!!!
```

---

**케이스 2: 영어 우선순위가 높은 경우**

**브라우저 설정**:
```
1. English (United States)
2. Korean
3. English
```

**실행 결과**:
```
Welcome to hyechang spring!!
Spring boot is not difficult
```

---

### Accept-Language 헤더의 역할

**HTTP 헤더 예시**:

```
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```

**구성 요소**:

| 항목 | 의미 | 우선순위 |
|-----|------|---------|
| `ko-KR` | 한국어 (한국) | 가장 높음 (1.0) |
| `ko;q=0.9` | 한국어 | 0.9 |
| `en-US;q=0.8` | 영어 (미국) | 0.8 |
| `en;q=0.7` | 영어 | 가장 낮음 (0.7) |

**Spring의 처리**:
1. 우선순위가 가장 높은 언어 확인 (`ko-KR`)
2. 해당하는 메시지 파일 찾기 (`messages_ko.properties`)
3. 파일이 없으면 다음 우선순위 언어 시도
4. 모두 없으면 기본 파일 사용 (`messages.properties`)

---

### 기본 파일(messages.properties)의 필요성

**Fallback 역할**:

| 상황 | 기본 파일 있음 | 기본 파일 없음 |
|-----|-------------|-------------|
| **지원하지 않는 언어** | 기본 텍스트 표시 | 에러 또는 `??키이름??` 표시 |
| **안정성** | 높음 | 낮음 |
| **권장 여부** | ✅ 권장 | ❌ 비권장 |

**핵심**: `messages.properties` 기본 파일은 반드시 있어야 안정적인 애플리케이션 운영이 가능합니다!

---

### 동적 데이터의 국제화

**문제**: 데이터베이스에서 가져온 동적 데이터는 어떻게 국제화하나?

**해결**: 문장 구조만 번역하고, 동적 데이터는 플레이스홀더로 처리

**messages_en.properties**:

```properties
order.summary=Your order for {0} items was placed on {1}.
```

**messages_ko.properties**:

```properties
order.summary={0}개의 상품 주문이 {1}에 완료되었습니다.
```

**View 템플릿**:

```html
<p th:text="#{order.summary(${orderCount}, ${orderDate})}">주문 요약</p>
```

**실행 결과**:

| 언어 | orderCount = 3, orderDate = "2025-10-29" |
|-----|------------------------------------------|
| **한국어** | 3개의 상품 주문이 2025-10-29에 완료되었습니다. |
| **영어** | Your order for 3 items was placed on 2025-10-29. |

**핵심**: Spring은 데이터를 번역하는 것이 아니라, **데이터를 감싸는 문장 구조**를 언어별로 준비하고 동적 데이터를 적절한 위치에 삽입합니다!

---

## 5.2.8 타임리프 표현식 상세

### Model 객체 준비

**Member.java**:

```java
package com.example.thymeleafSample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Member {
    String name;
    int age;
}
```

**Customer.java**:

```java
package com.example.thymeleafSample.model;

import lombok.AllArgsConstructor;
import lombok.Data;

@Data
@AllArgsConstructor
public class Customer {
    String name;
    String email;
    int age;
}
```

---

### Controller 작성

```java
@Controller
@Slf4j
public class BasicController {
    
    List<Customer> customers = List.of(
        new Customer("홍혜창", "hyechang@spring.ac.kr", 10),
        new Customer("김우현", "woohyun@spring.ac.kr", 10),
        new Customer("김구라", "gura@spring.ac.kr", 10)
    );

    @GetMapping("/thymeleaf")
    public String getThymeleaf(Model model) {
        model.addAttribute("firstCustomer", customers.get(0));
        
        Date date = Calendar.getInstance().getTime();
        model.addAttribute("date", date);
        model.addAttribute("number", 12.1);
        model.addAttribute("intNumber", 10);
        
        model.addAttribute("isStudent", true);
        model.addAttribute("isTeacher", false);
        model.addAttribute("grade", 4);
        
        model.addAttribute("customers", customers);
        
        return "basic/thymeleaf-basic";
    }
}
```

---

### ${} 표현식의 정확한 의미

**중요한 깨달음**: `${}`는 단순히 Model에 접근하는 것이 아니라, **Model 데이터를 사용할 수 있는 평가 공간**을 제공합니다!

**잘못된 이해**:
```
${name}으로만 접근 가능
```

**올바른 이해**:
```
${} 안에서 Model 데이터를 조합하고 연산할 수 있음
```

---

### ${} 내부에서 가능한 작업

**1. 단순 접근**:

```html
<p th:text="${name}">이름</p>
<p th:text="${age}">나이</p>
```

---

**2. 문자열 조합**:

```html
<p th:text="${'이름은 ' + name + ' 나이는 ' + age}">정보</p>
```

**주의**: 문자열 리터럴은 반드시 **작은따옴표**로 감싸야 합니다!

---

**3. 메서드 호출**:

```html
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}">날짜</p>
```

**핵심**: `date` 앞에 `$`를 붙이지 않는 이유는 이미 `${}` 평가 공간 안에 있기 때문입니다!

---

### 이중 $ 사용 금지

**잘못된 코드**:

```html
<!-- ❌ 잘못된 예시 -->
<p th:text="${#calendars.format(${date}, 'yyyy-MM-dd')}">날짜</p>
```

**올바른 코드**:

```html
<!-- ✅ 올바른 예시 -->
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}">날짜</p>
```

**이유**:

| 구문 | 의미 |
|-----|------|
| `${}` | 평가 공간 시작 |
| `date` | 평가 공간 내에서 자동으로 Model 키로 인식 |
| `${date}` | 불필요한 중복 (문법 오류) |

---

### 객체 접근 방식

**방법 1: 일반 접근**

```html
<h1>th:text 객체 사용법1</h1>
<ul>
    <li th:text="${firstCustomer.name}">이름부분</li>
    <li th:text="${firstCustomer.email}">이메일부분</li>
    <li th:text="${firstCustomer.age}">나이부분</li>
</ul>
```

**실행 결과**:
```
홍혜창
hyechang@spring.ac.kr
10
```

---

**방법 2: 선택 변수 표현식 (th:object + `*{}`)**

```html
<h1>th:text 객체 사용법2</h1>
<ul th:object="${firstCustomer}">
    <li th:text="*{name}">이름부분</li>
    <li th:text="*{email}">이메일부분</li>
    <li th:text="*{age}">나이부분</li>
</ul>
```

**실행 결과**:
```
홍혜창
hyechang@spring.ac.kr
10
```

---

### 선택 변수 표현식 (*{}) 상세

**th:object의 역할**:

| 항목 | 설명 |
|-----|------|
| **선언** | 부모 태그에서 객체 지정 |
| **효과** | 하위 태그에서 `*{}`로 간단히 접근 가능 |
| **스코프** | 가장 가까운 상위 `th:object` 태그까지 |

---

### *{} vs ${} 비교

| 방식 | 코드 | 원리 | 장점 |
|-----|------|------|------|
| **일반 접근** | `${firstCustomer.name}` | 매번 객체 이름 명시 | 직관적 |
| **선택 접근** | `*{name}` | 부모의 `th:object` 상속 | 코드 간결 |

**수식으로 표현**:
```
*{name} ≡ (부모 태그의 th:object 객체).name
```

---

### th:object 사용의 장점

**1. 코드 간결성**:

```html
<!-- 일반 접근: 긴 객체 이름 반복 -->
${veryLongObjectName.name}
${veryLongObjectName.email}
${veryLongObjectName.age}

<!-- 선택 접근: 간결함 -->
<div th:object="${veryLongObjectName}">
    *{name}
    *{email}
    *{age}
</div>
```

---

**2. 성능 최적화 (Micro-Optimization)**:

| 항목 | 설명 |
|-----|------|
| **객체 탐색** | 한 번만 수행 |
| **재사용** | 하위 요소에서 캐시된 객체 사용 |
| **효과** | 복잡한 View에서 미세한 성능 향상 |

---

**3. 폼 바인딩과의 연계**:

```html
<form th:object="${item}">
    <input th:field="*{name}">
    <input th:field="*{price}">
</form>
```

**핵심**: Spring MVC의 폼 처리 표준 방식으로, 유효성 검증과 자동 연동됩니다!

---

### 중첩된 th:object

**중첩 구조 예시**:

```html
<div th:object="${outerObject}">
    <span th:text="*{name}">Outer Name</span>
    
    <ul th:object="${innerObject}">
        <li th:text="*{title}">Inner Title</li>
    </ul>
    
    <p th:text="*{description}">Outer Description</p>
</div>
```

**작동 원리**:

| 요소 | 참조하는 객체 | 이유 |
|-----|------------|------|
| `<span>` | `outerObject` | 가장 가까운 상위 `th:object` |
| `<li>` | `innerObject` | 바로 위의 `<ul>` 태그에 새로운 객체 선언 |
| `<p>` | `outerObject` | `<ul>` 밖이므로 다시 `outerObject` 참조 |

**핵심**: `*{}`는 항상 **가장 가까운 상위 태그**의 `th:object`를 참조합니다!

---

## 5.2.9 유틸리티 객체

### # 기호의 두 가지 역할

**중요한 구분**:

| 구분 | 문법 | 역할 | 예시 |
|-----|------|------|------|
| **메시지 표현식** | `#{키}` | 외부 파일 텍스트 접근 | `#{welcome}` |
| **유틸리티 객체** | `${#객체.메서드}` | 타임리프 기본 제공 기능 | `${#calendars.format(...)}` |

**핵심**: 같은 `#` 기호지만 사용 위치와 문맥에 따라 역할이 다릅니다!

---

### 유틸리티 객체를 ${} 안에 사용하는 이유

**잘못된 사용**:

```html
<!-- ❌ 문자열로만 취급됨 -->
<p th:text="#calendars.format(date)">#calendars.format(date)</p>
```

**올바른 사용**:

```html
<!-- ✅ 실행되어 결과 반환 -->
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}">2025-10-29</p>
```

**이유**:

| 구문 | 타임리프 해석 | 결과 |
|-----|------------|------|
| `th:text="#calendars..."` | 고정된 문자열 리터럴 | 문자 그대로 출력 |
| `th:text="${#calendars...}"` | 실행 가능한 표현식 | 메서드 실행 후 결과 출력 |

---

### ${} 의 정확한 의미

**최종 정의**: `${}`는 **"평가 및 출력 지시자"**입니다.

**동작 과정**:

```
1. 평가 (Evaluation)
   - 내부 표현식을 Java 코드처럼 실행
   
2. 변환 (Conversion)
   - 실행 결과를 문자열로 변환
   
3. 출력 (Output)
   - HTML 텍스트로 삽입
```

---

### 날짜 유틸리티 (#calendars)

**사용 예시**:

```html
<h2>유틸리티 객체 사용하기 calendars</h2>
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}"></p>
```

**실행 결과**:
```
2025-10-29
```

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | `date` 변수로 Model에서 Date 객체 가져오기 |
| 2 | `#calendars.format()` 메서드 호출 |
| 3 | 지정된 형식으로 날짜 문자열 반환 |
| 4 | HTML에 문자열 삽입 |

---

### 숫자 유틸리티 (#numbers)

**formatDecimal 사용**:

```html
<h2>유틸리티 객체 사용하기 numbers</h2>
<p th:text="${'기본 : ' + number}"></p>
<p th:text="${#numbers.formatDecimal(number, 5, 3)}"></p>
```

**Model 데이터**:
```java
model.addAttribute("number", 12.1);
```

**실행 결과**:
```
기본 : 12.1
00012.100
```

---

**formatDecimal 메서드 분석**:

```
#numbers.formatDecimal(number, minIntegerDigits, decimalDigits)
```

| 매개변수 | 값 | 역할 | 결과 |
|---------|-----|------|------|
| `number` | 12.1 | 포맷팅 대상 | - |
| `minIntegerDigits` | 5 | 정수부 최소 자릿수 | 앞에 0 채움 → 00012 |
| `decimalDigits` | 3 | 소수부 자릿수 고정 | 뒤에 0 채움 → .100 |

**핵심**: 정수부는 최소 자릿수를 보장하고, 소수부는 정확히 지정된 자릿수로 고정합니다!

---

**formatInteger 사용**:

```html
<p th:text="${'기본 : ' + intNumber}"></p>
<p th:text="${#numbers.formatInteger(intNumber, 10)}"></p>
```

**Model 데이터**:
```java
model.addAttribute("intNumber", 10);
```

**실행 결과**:
```
기본 : 10
0000000010
```

**작동 원리**:

| 항목 | 값 | 설명 |
|-----|-----|------|
| **입력** | 10 (2자리) | - |
| **최소 자릿수** | 10자리 | - |
| **패딩** | 앞에 8개의 0 추가 | 0000000010 |

---

### 메서드 호출의 이해

**객체 속성 접근 시 내부 동작**:

```html
<li th:text="${member.age}">나이</li>
```

**실제 호출**:
```java
member.getAge()
```

**처리 과정**:

```
1. ${} 평가 공간 진입
    ↓
2. member 객체 찾기 (Model에서)
    ↓
3. .age 발견 → getAge() 메서드 자동 호출 (JavaBean 규약)
    ↓
4. 반환 값(int 30)을 문자열("30")로 변환
    ↓
5. HTML에 삽입
```

---

**일반 메서드 호출**:

```html
<p th:text="${member.calculateScore()}">점수</p>
<p th:text="${member.isAdult(20)}">성인 여부</p>
```

**가능한 접근 형태**:

| 접근 형태 | 예시 | 내부 호출 | 비고 |
|---------|------|----------|------|
| **속성** | `${member.name}` | `member.getName()` | 가장 일반적 |
| **일반 메서드** | `${member.calculateScore()}` | `member.calculateScore()` | 반환 값 필요 |
| **파라미터 전달** | `${member.isAdult(20)}` | `member.isAdult(20)` | 인자 전달 가능 |

**주의사항**:
- ⚠️ View에서는 **읽기 전용(Read-only)** 메서드만 호출
- ❌ 데이터 변경 또는 복잡한 로직은 Controller/Service에서 처리
- ✅ 간단한 포맷팅, 계산 메서드만 View에서 사용

---

## 5.2.10 조건문 (th:if, th:unless)

### th:if의 역할

**정의**: 조건식의 결과가 `true`일 때만 해당 HTML 요소를 렌더링

**Model 데이터**:

```java
model.addAttribute("isStudent", true);
model.addAttribute("isTeacher", false);
model.addAttribute("grade", 4);
```

---

### th:if 사용 예시

```html
<h2>th:if</h2>
<p th:if="${isStudent}">학생입니다.</p>
<p th:if="${isTeacher}">선생입니다.</p>
<p th:if="${isStudent or isTeacher}">학생 또는 선생입니다.</p>
<p th:if="${grade == 4}">4학년입니다.</p>
<p th:if="${showExtra == null}">showExtra는 없습니다.</p>
```

**실행 결과**:
```
학생입니다.
학생 또는 선생입니다.
4학년입니다.
showExtra는 없습니다.
```

---

### th:if 작동 원리

**평가 과정**:

| 타임리프 코드 | 평가식 | 불리언 결과 | 렌더링 | 출력 |
|-------------|--------|----------|-------|------|
| `th:if="${isStudent}"` | true | true | ✅ | 학생입니다. |
| `th:if="${isTeacher}"` | false | false | ❌ | (제거됨) |
| `th:if="${isStudent or isTeacher}"` | true or false | true | ✅ | 학생 또는... |
| `th:if="${grade == 4}"` | 4 == 4 | true | ✅ | 4학년입니다. |
| `th:if="${showExtra == null}"` | null == null | true | ✅ | showExtra는... |

**핵심**: `th:if`는 조건이 `false`일 때 **HTML에서 완전히 제거**합니다!

---

### th:unless의 역할

**정의**: `th:if`의 반대로, 조건이 `false`일 때만 렌더링

**영어 의미**: "~가 아니라면" (if not)

**수식 표현**:
```
th:unless(Condition) ≡ th:if(¬Condition)
```

---

### th:unless 사용 예시

```html
<p th:if="${isLoggedIn}">로그아웃</p>
<p th:unless="${isLoggedIn}">로그인</p>
```

**작동 비교**:

| 조건식 결과 | th:if="조건" | th:unless="조건" |
|-----------|------------|----------------|
| **true** | 렌더링됨 | 렌더링되지 않음 |
| **false** | 렌더링되지 않음 | 렌더링됨 |

---

### 조건문 활용 예시

**null 체크**:

```html
<div th:if="${user != null}">
    환영합니다, <span th:text="${user.name}"></span>님!
</div>

<div th:unless="${user != null}">
    <a th:href="@{/login}">로그인</a>이 필요합니다.
</div>
```

---

**컬렉션 비어있음 체크**:

```html
<div th:if="${list.size() > 0}">
    <p>항목이 있습니다.</p>
</div>

<div th:unless="${list.size() > 0}">
    <p>항목이 없습니다.</p>
</div>
```

---

### th:if vs th:unless 정리

| 조건식 | 의미 | th:unless 작동 (렌더링 여부) |
|-------|------|----------------------------|
| `${user == null}` | user가 null | user가 null이 아닐 때 (로그인 상태) |
| `${user != null}` | user가 null 아님 | user가 null일 때 (로그아웃 상태) |
| `${list.size() > 0}` | 리스트에 요소 있음 | 리스트가 비어있을 때 |
| `${status == 'ACTIVE'}` | 상태가 ACTIVE | 상태가 ACTIVE 아닐 때 |

---

## 5.2.11 반복문 (th:each)

### th:each의 역할

**정의**: 컬렉션(리스트, 배열)의 각 요소만큼 HTML 요소를 반복 생성

**문법**:
```
th:each="변수명 : ${컬렉션명}"
```

---

### 기본 사용법

```html
<h2>th:each 사용법1</h2>
<p>회원목록</p>
<table>
    <tr th:each="c : ${customers}">
        <td th:text="${c.name}"></td>
        <td th:text="${c.email}"></td>
        <td th:text="${c.age}"></td>
    </tr>
</table>
```

**실행 결과**:
```
회원목록
홍혜창  hyechang@spring.ac.kr  10
김우현  woohyun@spring.ac.kr   10
김구라  gura@spring.ac.kr      10
```

---

### th:each 작동 원리

| 코드 부분 | 역할 | 설명 |
|---------|------|------|
| `${customers}` | 컬렉션 참조 | Model에서 List<Customer> 가져오기 |
| `c` | 반복 변수 | 각 반복마다 하나의 Customer 객체 저장 |
| `${c.name}` | 객체 속성 접근 | c.getName() 호출 |

**처리 흐름**:

```
1. customers 리스트 가져오기 (3개 요소)
    ↓
2. 첫 번째 Customer → c 변수에 저장
    ↓
3. <tr> 블록 실행 (첫 번째 행 생성)
    ↓
4. 두 번째 Customer → c 변수에 저장
    ↓
5. <tr> 블록 실행 (두 번째 행 생성)
    ↓
6. 세 번째 Customer → c 변수에 저장
    ↓
7. <tr> 블록 실행 (세 번째 행 생성)
    ↓
8. 반복 종료
```

---

### 반복 상태 객체 (iteration)

**문법**:
```
th:each="요소변수, 상태변수 : ${컬렉션}"
```

**사용 예시**:

```html
<h2>th:each 사용법2 iteration 사용추가</h2>
<table>
    <tr th:each="c, iteration : ${customers}"
        th:style="${iteration.even ? 'background-color: lightgray;' : ''}">
        <td th:text="${'현재 처리중인 리스트 인덱스' + iteration.index}"></td>
        <td th:text="${'현재 반복 순번(1부터시작)' + iteration.count}"></td>
        <td th:text="${'전체 반복 사이즈 ' + iteration.size}"></td>
        <td th:text="${iteration.even == true ? '짝수' : '홀수'}"></td>
        <td th:text="${iteration.first ? '처음' : '처음아님'}"></td>
        <td th:text="${iteration.last ? '마지막' : '마지막아님'}"></td>
        <td th:text="${c.name}"></td>
        <td th:text="${c.email}"></td>
        <td th:text="${c.age}"></td></tr>
</table>
```

**실행 결과**:
```
현재 처리중인 리스트 인덱스0  현재 반복 순번(1부터시작)1  전체 반복 사이즈 3  홀수  처음  마지막아님  홍혜창  hyechang@spring.ac.kr  10

(회색배경) 현재 처리중인 리스트 인덱스1  현재 반복 순번(1부터시작)2  전체 반복 사이즈 3  짝수  처음아님  마지막아님  김우현  woohyun@spring.ac.kr  10

현재 처리중인 리스트 인덱스2  현재 반복 순번(1부터시작)3  전체 반복 사이즈 3  홀수  처음아님  마지막  김구라  gura@spring.ac.kr  10
```

---

### iteration 객체 속성 정리

**iteration은 타임리프가 자동으로 생성하는 유틸리티 객체**입니다.

| 속성 | 1번째 요소 | 2번째 요소 | 3번째 요소 | 설명 |
|-----|----------|----------|----------|------|
| **index** | 0 | 1 | 2 | 0부터 시작하는 인덱스 |
| **count** | 1 | 2 | 3 | 1부터 시작하는 순번 |
| **size** | 3 | 3 | 3 | 컬렉션 전체 크기 |
| **even** | false | true | false | 짝수 번째 여부 |
| **odd** | true | false | true | 홀수 번째 여부 |
| **first** | true | false | false | 첫 번째 여부 |
| **last** | false | false | true | 마지막 여부 |

---

### iteration의 특징

**1. 유틸리티 객체**:

| 항목 | 설명 |
|-----|------|
| **성격** | 반복 상태 확인 기능 제공 |
| **생성 시점** | 타임리프 엔진이 반복마다 자동 생성 |
| **독립성** | customers 리스트와는 별개의 객체 |

**핵심**: `#numbers`나 `#calendars`처럼 타임리프가 제공하는 **반복문 전용 유틸리티 객체**입니다!

---

**2. 스타일 적용 활용**:

```html
<tr th:each="c, iteration : ${customers}"
    th:style="${iteration.even ? 'background-color: lightgray;' : ''}">
```

**작동 원리**:

| 반복 | iteration.even | 스타일 적용 | 결과 |
|-----|---------------|-----------|------|
| 1번째 | false | 스타일 없음 | 흰색 배경 |
| 2번째 | true | `background-color: lightgray;` | 회색 배경 |
| 3번째 | false | 스타일 없음 | 흰색 배경 |

**실무 활용**: 테이블 행마다 다른 배경색을 주는 **스트라이프(Stripe) 패턴** 구현에 유용합니다!

---

## 5.2.12 th:block 태그

### th:block이란?

**정의**: HTML 구조에 영향을 주지 않으면서 타임리프 로직을 적용할 수 있는 **투명한 컨테이너**

**특징**:

| 항목 | 설명 |
|-----|------|
| **역할** | 타임리프 논리 적용을 위한 가상 컨테이너 |
| **최종 HTML** | 렌더링 후 흔적 없이 사라짐 |
| **용도** | 여러 요소를 묶어 제어하되 HTML 구조는 유지 |

---

### th:block 사용 예시

**예시 1: 여러 요소를 함께 반복**

```html
<h2>iteration, each를 block태그를 이용하여 사용하기</h2>
<th:block th:each="customer, iteration : ${customers}">
    <p th:text="${iteration.index + '인덱스 설명'}"></p>
    <p>
        이름은 <span th:text="${customer.name}"></span> 이고,
        나이는 <span th:text="${customer.age}"></span>입니다.
    </p>
</th:block>
```

**실행 결과**:
```
0인덱스 설명
이름은 홍혜창 이고, 나이는 10입니다.

1인덱스 설명
이름은 김우현 이고, 나이는 10입니다.

2인덱스 설명
이름은 김구라 이고, 나이는 10입니다.
```

**핵심**: `<th:block>` 태그는 사라지고, 그 안의 `<p>` 태그들만 3세트가 생성됩니다!

---

### div vs th:block 비교

**문제 상황**: 반복문을 적용하려면 부모 태그가 필요한데, 불필요한 `<div>`가 생성되는 문제

**예시 1: div 사용 시**

```html
<h2>th:block 태그의 중요성</h2>
<p>쓸데 없는 div 제거!</p>
<p>아래의 div 개수는 3</p>
<div th:each="c : ${customers}">
    <span th:text="${c.name}"></span> : <span th:text="${c.age}"></span>
</div>
```

**생성되는 HTML**:

```html
<div>홍혜창 : 10</div>
<div>김우현 : 10</div>
<div>김구라 : 10</div>
```

**문제점**:
- ❌ 불필요한 `<div>` 태그 3개 생성
- ❌ CSS/레이아웃에 의도치 않은 영향 가능

---

**예시 2: th:block 사용 시**

```html
<p>아래의 div 개수는 0</p>
<th:block th:each="c : ${customers}">
    <span th:text="${c.name}"></span> : <span th:text="${c.age}"></span>
</th:block>
```

**생성되는 HTML**:

```html
<span>홍혜창</span> : <span>10</span>
<span>김우현</span> : <span>10</span>
<span>김구라</span> : <span>10</span>
```

**장점**:
- ✅ `<th:block>` 태그는 완전히 제거됨
- ✅ 깨끗한 HTML 구조 유지
- ✅ CSS/레이아웃에 영향 없음

---

### th:block 사용이 필요한 경우

**케이스 1: 여러 독립된 태그를 함께 반복**

```html
<th:block th:each="item : ${items}">
    <h3 th:text="${item.title}"></h3>
    <p th:text="${item.description}"></p>
    <hr>
</th:block>
```

**효과**: `<h3>`, `<p>`, `<hr>` 세 개의 요소가 하나의 단위로 반복되지만, 부모 태그는 생성되지 않습니다.

---

**케이스 2: 조건부로 여러 요소 표시**

```html
<th:block th:if="${user.isAdmin}">
    <h2>관리자 메뉴</h2>
    <ul>
        <li>사용자 관리</li>
        <li>설정</li>
    </ul>
</th:block>
```

**효과**: 관리자일 때만 여러 요소를 표시하되, 불필요한 래퍼 태그 없이 깔끔하게 처리됩니다.

---

### th:block 정리

**핵심 원칙**:

| 항목 | 설명 |
|-----|------|
| **목적** | 여러 요소를 하나의 단위로 묶어 제어 |
| **효과** | HTML 구조는 건드리지 않음 |
| **사용 시점** | 반복/조건 로직 적용 시 부모 태그가 필요하지만 생성하고 싶지 않을 때 |

**비유**: 
- `<div>`는 실제 상자 (HTML에 남음)
- `<th:block>`은 투명한 상자 (사라짐)

---

## 5.2.13 링크 생성 (th:href)

### Context Path의 이해

링크 생성을 설명하기 전에, **Context Path** 개념을 먼저 이해해야 합니다.

---

### Context Path란?

**정의**: 웹 애플리케이션의 URL 상의 루트 경로

**역할**: 하나의 서버에서 여러 애플리케이션을 구분하는 식별자

---

### WAR vs JAR 배포 방식의 차이

#### WAR 배포 (전통적 방식)

**구조**:

```
AWS EC2 인스턴스 (가상 컴퓨터)
    ↓
외장 Tomcat 설치 (WAS 소프트웨어)
    ↓
여러 WAR 파일 배포
- app1.war
- app2.war
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **WAS** | 하나의 Tomcat 프로세스 |
| **포트** | 8080 하나만 사용 |
| **애플리케이션 구분** | Context Path로 구분 |

**접근 방식**:

```
http://서버IP:8080/app1/users  → app1.war 실행
http://서버IP:8080/app2/users  → app2.war 실행
```

**핵심**: 
- ✅ 포트는 공유 (8080)
- ✅ Context Path로 애플리케이션 구분 (`/app1`, `/app2`)

---

#### JAR 배포 (현대적 방식)

**구조**:

```
AWS EC2 인스턴스 (가상 컴퓨터)
    ↓
독립적인 JAR 파일들 (각각 내장 Tomcat 포함)
- java -jar hyechang.jar (8080 포트)
- java -jar woohyun.jar (8081 포트)
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **WAS** | 각 JAR마다 독립적인 Tomcat |
| **포트** | 각각 다른 포트 사용 |
| **애플리케이션 구분** | 포트 번호로 구분 |

**접근 방식**:

```
http://서버IP:8080/users  → hyechang.jar
http://서버IP:8081/users  → woohyun.jar
```

**핵심**: 
- ✅ 각 애플리케이션이 독립적인 프로세스
- ✅ 포트 번호로 구분

---

### AWS와 EC2의 역할

**중요한 이해**:

| 개념 | 역할 | 비유 |
|-----|------|------|
| **AWS** | IT 인프라 플랫폼 | 부동산 회사 |
| **EC2 인스턴스** | 가상 컴퓨터 (하드웨어) | 빌린 사무실 |
| **Tomcat** | WAS 소프트웨어 | 사무실 안의 가구 |

**핵심**: 
- ❌ EC2가 Tomcat 서버가 아님
- ✅ EC2는 Tomcat이 구동될 수 있는 **컴퓨터 환경**을 제공

---

### WAR 배포 과정 상세

**1단계: 서버 컴퓨터 준비**

```
요청: "AWS님, Tomcat을 구동할 수 있는 가상 컴퓨터 주세요"
    ↓
AWS: EC2 인스턴스 생성 (가상 컴퓨터)
```

---

**2단계: WAS 설치**

```
개발자: EC2에 외장 Tomcat 소프트웨어 설치
    ↓
Tomcat 프로세스 실행 (8080 포트 오픈)
```

---

**3단계: 애플리케이션 배포**

```
app1.war, app2.war 파일을 Tomcat에 배포
    ↓
하나의 Tomcat 프로세스가 여러 WAR 처리
```

---

**4단계: Context Path로 구분**

| 요청 URL | Context Path | 처리 애플리케이션 |
|---------|-------------|----------------|
| `IP:8080/app1/users` | `/app1` | app1.war |
| `IP:8080/app2/users` | `/app2` | app2.war |

**작동 원리**:

```
클라이언트 요청: IP:8080/app1/users
    ↓
Tomcat: "앞의 /app1을 보니 app1.war로 보내야겠다"
    ↓
app1.war의 /users 컨트롤러 실행
```

---

### JAR 배포 과정 상세

**1단계: 서버 컴퓨터 준비**

```
요청: "AWS님, JAR 파일을 실행할 수 있는 가상 컴퓨터 주세요"
    ↓
AWS: EC2 인스턴스 생성 (Java 설치)
```

---

**2단계: JAR 파일 실행**

```
java -jar hyechang.jar
    ↓
내장 Tomcat 프로세스 생성 (8080 포트)

java -jar woohyun.jar
    ↓
또 다른 내장 Tomcat 프로세스 생성 (8081 포트)
```

**핵심**: 각 JAR은 독립적인 프로세스로 실행됩니다!

---

**3단계: 포트로 구분**

| 요청 URL | 포트 | 처리 애플리케이션 |
|---------|------|----------------|
| `IP:8080/users` | 8080 | hyechang.jar |
| `IP:8081/users` | 8081 | woohyun.jar |

**작동 원리**:

```
클라이언트 요청: IP:8080/users
    ↓
EC2: "8080 포트로 온 요청이니 hyechang.jar로 보낸다"
    ↓
hyechang.jar의 /users 컨트롤러 실행
```

---

### Nginx와 포트 관리

**문제 상황**: 
- JAR 방식에서 사용자가 포트 번호를 알아야 함
- `http://IP:8080/users`, `http://IP:8081/users`

**해결책: Nginx 프록시 서버 사용**

---

### Nginx의 역할

**1. 80번 포트 사용 (HTTP 표준)**

| 프로토콜 | 기본 포트 | 생략 가능 |
|---------|---------|---------|
| **HTTP** | 80 | ✅ |
| **HTTPS** | 443 | ✅ |

**효과**: 사용자가 포트 번호를 입력하지 않아도 자동으로 80번 포트로 연결됩니다.

---

**2. 경로 기반 라우팅**

**Nginx 설정 예시**:

```nginx
location /hyechang/ {
    proxy_pass http://localhost:8080/;
}

location /woohyun/ {
    proxy_pass http://localhost:8081/;
}
```

**작동 방식**:

| 클라이언트 요청 | Nginx 판단 | 내부 전달 |
|--------------|-----------|---------|
| `IP/hyechang/users` | `/hyechang/` 경로 발견 | `localhost:8080/users` |
| `IP/woohyun/users` | `/woohyun/` 경로 발견 | `localhost:8081/users` |

---

**3. 포트 번호 숨기기**

**장점**:

| 항목 | Nginx 없이 | Nginx 사용 시 |
|-----|-----------|-------------|
| **클라이언트 접근** | `IP:8080/users` | `IP/hyechang/users` |
| **포트 노출** | 8080 포트 노출 | 80번 포트만 노출 |
| **보안** | 내부 구조 노출 | 내부 구조 숨김 |

---

### Nginx 작동 흐름 정리

```
1. 클라이언트: http://IP/hyechang/users 요청
   (포트 생략 = 자동으로 80번 포트)
    ↓
2. EC2의 Nginx(80번 포트): 요청 수신
    ↓
3. Nginx: "/hyechang/ 경로네? 8080 포트로 전달해야지"
    ↓
4. 내부 전달: localhost:8080/users
    ↓
5. hyechang.jar(8080 포트): 요청 처리
    ↓
6. Nginx를 통해 클라이언트에게 응답 전달
```

**핵심**: 
- ✅ 클라이언트는 80번 포트와 경로만 알면 됨
- ✅ 내부 포트(8080, 8081)는 Nginx가 관리
- ✅ 보안성과 관리 편의성 향상

---

### WAR vs JAR 배포 방식 최종 비교

| 구분 | WAR 배포 | JAR 배포 |
|-----|---------|---------|
| **WAS 설치** | 외장 Tomcat 수동 설치 필요 | 내장 Tomcat 포함 (설치 불필요) |
| **프로세스** | 하나의 Tomcat 프로세스 | 각 JAR마다 독립 프로세스 |
| **포트 사용** | 하나의 포트 공유 (8080) | 각각 다른 포트 사용 |
| **애플리케이션 구분** | Context Path로 구분 | 포트 번호로 구분 |
| **접근 URL** | `IP:8080/app1/users` | `IP:8080/users` |
| **배포 방식** | WAR 파일을 Tomcat에 배포 | `java -jar` 명령으로 실행 |
| **현대 트렌드** | 레거시 시스템 | Spring Boot 권장 방식 |

---

### Context Path 설정

**application.properties**:

```properties
spring.application.name=thymeleafSample

server.servlet.context-path=/hyechang
```

---

### Context Path 설정의 효과

**1. URL 접두사 강제**

| 설정 전 | 설정 후 (`/hyechang`) |
|--------|---------------------|
| `http://IP:8080/users` | `http://IP:8080/hyechang/users` |

**효과**: 모든 URL 앞에 `/hyechang`이 자동으로 붙습니다.

---

**2. Controller 매핑 자동 조정**

```java
@GetMapping("/users")  // Controller 코드는 그대로
```

**실제 매핑되는 URL**:
```
http://localhost:8080/hyechang/users
```

**핵심**: 
- ✅ Controller 코드는 수정 불필요
- ✅ Spring이 자동으로 Context Path 인식
- ✅ `/hyechang` 부분을 제외한 `/users`로 매핑 찾기

---

**3. 타임리프 @{} 문법의 중요성**

**문제 상황**:

```html
<!-- ❌ 하드코딩 방식 -->
<a href="/users">사용자 목록</a>
```

**문제점**:
- Context Path가 `/`에서 `/hyechang`으로 변경되면?
- 모든 HTML 파일의 링크를 수동으로 수정해야 함!

---

**해결책**:

```html
<!-- ✅ 타임리프 방식 -->
<a th:href="@{/users}">사용자 목록</a>
```

**장점**:
- ✅ Context Path 자동 포함
- ✅ 설정 변경 시에도 HTML 수정 불필요
- ✅ 유지보수성 향상

---

### th:href의 @{} 문법

**@{}의 역할**:

| 항목 | 설명 |
|-----|------|
| **의미** | Context Path 자동 포함 지시자 |
| **효과** | 타임리프가 자동으로 Context Path를 URL 앞에 붙임 |

---

**동작 예시**:

| Context Path 설정 | 타임리프 코드 | 최종 URL |
|-----------------|-------------|---------|
| `/` (기본) | `@{/users}` | `/users` |
| `/hyechang` | `@{/users}` | `/hyechang/users` |
| `/api` | `@{/users}` | `/api/users` |

**핵심**: 설정만 바꾸면 모든 링크가 자동으로 올바르게 변경됩니다!

---

## 5.2.14 링크 생성 실습

### Controller 작성

```java
@GetMapping("/link")
public String getLink(Model model) {
    model.addAttribute("firstId", 0);
    model.addAttribute("secondId", 1);
    model.addAttribute("thirdId", 2);
    return "expression/link";
}

@GetMapping("/member/{id}")
public String getMemberId(Model model, @PathVariable Integer id) {
    model.addAttribute("member", customers.get(id));
    return "expression/member";
}

@GetMapping("/member")
public String getMember(Model model, 
                        @RequestParam(value = "id", required = false) Integer id) {
    if (id == null) {
        model.addAttribute("member", customers.get(0));
    } else {
        model.addAttribute("member", customers.get(id));
    }
    return "expression/member";
}
```

---

### View 템플릿 - link.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <a th:href="@{/member}">
        <span th:text="${firstId}"></span>
    </a>
    
    <a th:href="@{/member/{id}(id=${secondId})}">
        <span th:text="${secondId}"></span>
    </a>
    
    <a th:href="@{/member(id=${thirdId})}">
        <span th:text="${thirdId}"></span>
    </a>
</body>
</html>
```

---

### View 템플릿 - member.html

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
    <p th:text="${member.name}"></p>
    <p th:text="${member.email}"></p>
    <p th:text="${member.age}"></p>
</body>
</html>
```

---

### 링크 생성 방식 비교

**실행 결과 (/link 페이지)**:

```
0  1  2  (각각 클릭 가능한 링크)
```

---

### 방식 1: 단순 경로

```html
<a th:href="@{/member}"><span th:text="${firstId}"></span></a>
```

**최종 URL**:
```
http://localhost:8080/hyechang/member
```

**설명**:

| 요소 | 역할 |
|-----|------|
| `@{/member}` | Context Path 자동 포함하여 경로 생성 |
| `th:text="${firstId}"` | 링크 텍스트로 "0" 표시 |

**클릭 시 결과**:
```
홍혜창
hyechang@spring.ac.kr
10
```

---

### 방식 2: 경로 변수 (Path Variable)

```html
<a th:href="@{/member/{id}(id=${secondId})}">
    <span th:text="${secondId}"></span>
</a>
```

**최종 URL**:
```
http://localhost:8080/hyechang/member/1
```

---

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | 경로 템플릿 `{id}` 발견 |
| 2 | 소괄호 내 `id=${secondId}` 확인 |
| 3 | 이름이 일치하므로 경로에 대체 |
| 4 | `/member/1` 생성 |

**매핑 규칙**:

```
경로 템플릿: /member/{id}
매개변수: (id=1)
    ↓
URL 경로 자체에 대체: /member/1
```

**클릭 시 결과**:
```
김우현
woohyun@spring.ac.kr
10
```

---

### 방식 3: 쿼리 파라미터 (Query Parameter)

```html
<a th:href="@{/member(id=${thirdId})}">
    <span th:text="${thirdId}"></span>
</a>
```

**최종 URL**:
```
http://localhost:8080/hyechang/member?id=2
```

---

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | 경로에 `{}` 템플릿 없음 |
| 2 | 소괄호 내 `id=${thirdId}` 확인 |
| 3 | 경로 템플릿과 매칭 안 됨 |
| 4 | 자동으로 쿼리 파라미터로 전환 |
| 5 | `?id=2` 형태로 추가 |

**매핑 규칙**:

```
경로: /member (템플릿 없음)
매개변수: (id=2)
    ↓
쿼리 파라미터로 전환: /member?id=2
```

**클릭 시 결과**:
```
김구라
gura@spring.ac.kr
10
```

---

### th:href 데이터 처리 규칙 정리

**우선순위**:

```
1. 경로 템플릿 매칭 우선
   → 이름이 일치하면 경로에 대체
   
2. 나머지는 쿼리 파라미터
   → 경로에 매칭되지 않은 모든 매개변수
```

---

**종합 비교**:

| 방식 | 타임리프 코드 | 최종 URL | Controller 매핑 |
|-----|-------------|---------|---------------|
| **단순 경로** | `@{/member}` | `/member` | `@GetMapping("/member")` |
| **경로 변수** | `@{/member/{id}(id=1)}` | `/member/1` | `@GetMapping("/member/{id}")` |
| **쿼리 파라미터** | `@{/member(id=2)}` | `/member?id=2` | `@GetMapping("/member")` + `@RequestParam` |

---

### 복수 매개변수 예시

```html
<a th:href="@{/users/{id}/{name}(id=${userId}, name=${userName}, sort='asc', language='korea')}">
    링크
</a>
```

**처리 규칙**:

| 매개변수 | 경로 템플릿 매칭 | 처리 방식 |
|---------|---------------|---------|
| `id=${userId}` | `{id}` 일치 | 경로에 대체 |
| `name=${userName}` | `{name}` 일치 | 경로에 대체 |
| `sort='asc'` | 매칭 없음 | 쿼리 파라미터 |
| `language='korea'` | 매칭 없음 | 쿼리 파라미터 |

**최종 URL** (userId=42, userName='Alice' 가정):
```
/users/42/Alice?sort=asc&language=korea
```

---

## 5.2.15 핵심 정리

### 템플릿 엔진 비교

| 항목 | JSP | Thymeleaf |
|-----|-----|-----------|
| **HTML 호환성** | ❌ 비호환 | ✅ Natural Templates |
| **로컬 실행** | ❌ 불가능 | ✅ 가능 |
| **파일 위치** | `webapp/WEB-INF/views/` | `resources/templates/` |
| **확장자** | `.jsp` | `.html` |
| **추가 설정** | 수동 의존성 추가 필요 | Spring Boot 자동 설정 |
| **개발 효율** | 낮음 (서버 필수) | 높음 (서버 없이 디자인 확인) |
| **Spring Boot 권장** | ❌ 비권장 | ✅ 권장 |

---

### 타임리프 핵심 개념

**1. xmlns 선언**:
```html
<html xmlns:th="http://www.thymeleaf.org">
```
- ✅ 필수 선언
- `th:` 접두사 사용 가능하게 함

---

**2. ${} 표현식의 정확한 의미**:

| 잘못된 이해 | 올바른 이해 |
|-----------|-----------|
| Model 접근만 가능 | Model 데이터를 사용할 수 있는 **평가 공간** |
| `${name}`만 가능 | `${'이름: ' + name}` 같은 조합 가능 |
| 문자열만 반환 | 메서드 호출, 연산 등 모든 표현식 평가 가능 |

**핵심**: `${}`는 타임리프의 **표현식 평가 및 출력 지시자**입니다!

---

**3. # 기호의 두 가지 역할**:

| 사용 위치 | 역할 | 예시 |
|---------|------|------|
| `#{}` | 메시지 프로퍼티 접근 | `#{welcome}` |
| `${#객체}` | 유틸리티 객체 접근 | `${#calendars.format(...)}` |

---

### 메시지 프로퍼티 핵심

**1. 파일 이름 규칙**:
```
messages.properties      (기본 - 필수!)
messages_ko.properties   (한국어)
messages_en.properties   (영어)
```
- ⚠️ `messages` (복수형 's' 필수)

---

**2. 플레이스홀더**:
```properties
customer.contact={0} 고객님의 연락처는 {1}입니다.
```

```html
<p th:text="#{customer.contact(${name}, ${phone})}"></p>
```

**매핑 규칙**: 순서 기반 (위치가 중요)

---

**3. 동적 메시지 키**:
```html
<p th:text="#{${type}(${name}, ${phone})}"></p>
```

**평가 순서**:
1. `${type}` → "customer.contact.long"
2. `#{...}` → 메시지 파일 검색
3. `(...)` → 플레이스홀더에 값 주입

---

### 타임리프 표현식 핵심

**1. th:text vs th:utext**:

| 속성 | HTML 처리 | 사용 시기 |
|-----|----------|---------|
| `th:text` | Escape (안전) | 대부분의 경우 |
| `th:utext` | 그대로 렌더링 | 신뢰할 수 있는 데이터만 |

---

**2. 객체 접근 방식**:

```html
<!-- 일반 접근 -->
<li th:text="${customer.name}"></li>

<!-- 선택 접근 -->
<ul th:object="${customer}">
    <li th:text="*{name}"></li>
</ul>
```

**`*{}`의 의미**: 가장 가까운 상위 `th:object`의 속성 접근

---

**3. 유틸리티 객체 사용 시 주의**:

```html
<!-- ✅ 올바름 -->
<p th:text="${#calendars.format(date, 'yyyy-MM-dd')}"></p>

<!-- ❌ 이중 $ 금지 -->
<p th:text="${#calendars.format(${date}, 'yyyy-MM-dd')}"></p>
```

**이유**: 이미 `${}` 평가 공간 안에 있음

---

### 조건문과 반복문

**1. th:if / th:unless**:

```html
<p th:if="${isStudent}">학생입니다</p>
<p th:unless="${isStudent}">학생이 아닙니다</p>
```

**효과**: 조건이 맞지 않으면 HTML에서 완전히 제거

---

**2. th:each + iteration**:

```html
<tr th:each="item, iteration : ${items}">
    <td th:text="${iteration.index}"></td>
    <td th:text="${iteration.count}"></td>
    <td th:text="${item.name}"></td>
</tr>
```

**iteration 주요 속성**:
- `index`: 0부터 시작
- `count`: 1부터 시작
- `even/odd`: 짝수/홀수 판별
- `first/last`: 첫/마지막 판별

---

**3. th:block**:

```html
<th:block th:each="item : ${items}">
    <h3 th:text="${item.title}"></h3>
    <p th:text="${item.description}"></p>
</th:block>
```

**효과**: 불필요한 래퍼 태그 없이 여러 요소를 함께 제어

---

### 링크 생성 핵심

**1. @{} 문법의 중요성**:

```html
<!-- ✅ 권장 -->
<a th:href="@{/users}">목록</a>

<!-- ❌ 비권장 -->
<a href="/users">목록</a>
```

**장점**: Context Path 자동 포함으로 유지보수성 향상

---

**2. 링크 생성 패턴**:

| 패턴 | 코드 | 결과 URL |
|-----|------|---------|
| **단순 경로** | `@{/users}` | `/users` |
| **경로 변수** | `@{/users/{id}(id=1)}` | `/users/1` |
| **쿼리 파라미터** | `@{/users(id=1)}` | `/users?id=1` |
| **복합** | `@{/users/{id}(id=1, sort='asc')}` | `/users/1?sort=asc` |

**매핑 규칙**: 
1. 경로 템플릿 `{}` 우선 매칭
2. 나머지는 쿼리 파라미터

---

### Context Path 이해

**WAR 배포**:
- 하나의 Tomcat (8080 포트)
- 여러 애플리케이션 → Context Path로 구분
- 예: `/app1/users`, `/app2/users`

**JAR 배포**:
- 각 JAR이 독립 프로세스
- 다른 포트 사용 → 포트로 구분
- 예: `8080/users`, `8081/users`

**Nginx 사용 시**:
- 80번 포트로 통일
- 경로로 내부 포트 매핑
- 예: `/hyechang/users` → `localhost:8080/users`

---

### 개발 팁

**1. IntelliJ 템플릿 설정**:
- `Ctrl + Alt + S` → `File and Code Templates`
- Thymeleaf 기본 구조 자동 생성

---

**2. 메시지 프로퍼티 디버깅**:
```java
@GetMapping("/language")
public String getLanguage(HttpServletRequest request) {
    String acceptLanguage = request.getHeader("Accept-Language");
    log.info("Accept-Language: {}", acceptLanguage);
    return "basic/language-basic";
}
```

---

**3. th:object 실무 활용**:
- 폼 바인딩과 함께 사용
- 유효성 검증 자동 연동
- Spring MVC 표준 패턴

---

### 자주 하는 실수

**1. messages.properties 파일명**:
- ❌ `message.properties`
- ✅ `messages.properties` (복수형!)

---

**2. ${} 이중 사용**:
```html
<!-- ❌ 잘못됨 -->
${#calendars.format(${date}, ...)}

<!-- ✅ 올바름 -->
${#calendars.format(date, ...)}
```

---

**3. th:text에서 문자열 조합 시 따옴표**:
```html
<!-- ❌ 잘못됨 -->
th:text="${이름: + name}"

<!-- ✅ 올바름 -->
th:text="${'이름: ' + name}"
```

---

**4. Context Path 하드코딩**:
```html
<!-- ❌ 비권장 -->
<a href="/users">목록</a>

<!-- ✅ 권장 -->
<a th:href="@{/users}">목록</a>
```

---

### 타임리프의 장점 요약

| 장점 | 설명 |
|-----|------|
| **HTML 호환** | 서버 없이 디자인 확인 가능 |
| **프론트-백엔드 분리** | 동일 파일로 독립 개발 가능 |
| **Spring 통합** | 자동 설정 및 표준 지원 |
| **유지보수성** | Context Path 자동 처리 |
| **안전성** | 기본 Escape 처리 (XSS 방지) |

---

**결론**: 타임리프는 HTML 표준을 유지하면서 강력한 동적 기능을 제공하는 현대적인 템플릿 엔진입니다. Spring Boot 환경에서 SSR 방식의 웹 애플리케이션을 개발할 때 가장 권장되는 선택입니다!


---
## 5.2.16 타임리프 레이아웃 관리

### 레이아웃 관리의 필요성

**상용 웹 서비스의 특징**:

상용으로 서비스되는 웹사이트를 살펴보면 모든 페이지가 동일한 레이아웃 구조를 가지고 있고, **콘텐츠 영역만 바뀌는** 것을 확인할 수 있습니다.

**문제점**:
- 매 페이지마다 헤더, 푸터, 네비게이션 등을 반복 작성
- 공통 영역 수정 시 모든 페이지를 수정해야 함
- 코드 중복으로 인한 유지보수 어려움

**해결책**:
타임리프는 공통으로 사용되는 영역을 **프래그먼트(Fragment)**로 지정하고, 이를 필요로 하는 페이지에 간단히 포함시킬 수 있는 방법을 제공합니다.

---

### 프래그먼트를 통한 레이아웃 관리 방법

타임리프의 프래그먼트를 활용한 레이아웃 관리는 크게 **두 가지 방식**으로 나뉩니다.

---

### 방법 1: 공통 요소 재사용 방식

**개념**: 공통 요소들(헤더, 푸터 등)을 프래그먼트로 선언하고, 필요한 곳에서 가져다 쓰는 방식

**특징**:

| 항목 | 설명 |
|-----|------|
| **대체 범위** | 일부 영역(헤더, 푸터 등) |
| **페이지 구조** | 각 페이지가 완전한 HTML 구조 보유 |
| **프래그먼트 역할** | 코드 조각 제공 |
| **사용 빈도** | 가장 기본적이고 직관적 |

---

### 방법 2: 전체 레이아웃 템플릿 방식

**개념**: 전체 레이아웃을 포함한 HTML을 프래그먼트로 만들고, 각 웹페이지에서 **HTML 전체를 교체**하되, 해당 페이지의 고유한 영역만 매개변수로 전달하는 방식

**특징**:

| 항목 | 설명 |
|-----|------|
| **대체 범위** | HTML 전체 |
| **페이지 구조** | 페이지는 콘텐츠만 정의 |
| **프래그먼트 역할** | Base Layout 제공 |
| **사용 빈도** | 실무에서 선호되는 고급 패턴 |

---

## 5.2.17 프래그먼트 구현 (방법 1: 공통 요소 재사용)

### 프래그먼트 파일 작성

**파일 위치**: `src/main/resources/templates/fragment/common.html`

---

### 프래그먼트 파일의 구성 원칙

**중요**: 프래그먼트 파일은 **완전한 HTML 문서가 아닌**, 재사용 가능한 **코드 블록**으로 만들어야 합니다.

---

### 제거해야 할 요소 ❌

다음 요소들은 프래그먼트 파일에 포함하지 **않아야** 합니다:

```html
<!-- ❌ 프래그먼트 파일에 포함하지 말 것 -->
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>...</title>
</head>
<body>
    ...
</body>
</html>
```

**이유**:

| 이유 | 설명 |
|-----|------|
| **중복 방지** | 호출하는 파일에 이미 이 태그들이 존재 |
| **문법 오류** | HTML 문서에 `<html>`, `<head>` 태그가 중복되면 오류 발생 |
| **렌더링 문제** | 브라우저가 비정상적으로 해석할 수 있음 |

---

### 정의해야 할 요소 ✅

**기본 프래그먼트 정의**:

```html
<!-- fragment/common.html -->
<div th:fragment="header">
    <p style="background-color: black; color: white; padding: 12px;">
        홍혜창 스프링 | 강의 | 책 | 대관 | 이벤트 | 자료실
    </p>
</div>

<div th:fragment="footer">
    <p style="background-color: black; color: white; padding: 12px;">
        Copyright hyechang
    </p>
</div>
```

---

### 프래그먼트 정의 문법

**th:fragment 속성**:

```
th:fragment="프래그먼트이름"
```

| 항목 | 설명 |
|-----|------|
| **속성** | `th:fragment` |
| **값** | 고유한 프래그먼트 이름 (식별자) |
| **적용 대상** | 재사용할 HTML 요소 (div, header, footer 등) |

---

### 매개변수를 받는 프래그먼트

**동적 프래그먼트 정의**:

```html
<!-- fragment/common.html -->
<div th:fragment="header(a, b, c, d, e, f)">
    <p style="background-color: black; color: white; padding: 12px;">
        <span th:text="${a}"></span> | 
        <span th:text="${b}"></span> | 
        <span th:text="${c}"></span> | 
        <span th:text="${d}"></span> | 
        <span th:text="${e}"></span> | 
        <span th:text="${f}"></span>
    </p>
</div>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **문법** | `th:fragment="이름(매개변수1, 매개변수2, ...)"` |
| **매개변수** | 호출 시 전달받을 변수 선언 |
| **사용 목적** | 동일한 구조, 다른 내용 표시 |
| **비유** | 함수처럼 동작 |

---

### 프래그먼트 호출

**파일 위치**: `src/main/resources/templates/fragment/fragment-common.html`

---

### 기본 호출 방식

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>
</head>
<body>
    <div th:replace="~{fragment/common::header}"></div>
    
    <p class="round-shadow-box">
        spring boot 공부 열심히 하자!
    </p>
    
    <div th:replace="~{fragment/common::footer}"></div>
</body>
</html>
```

**실행 결과**:
```
홍혜창 스프링 | 강의 | 책 | 대관 | 이벤트 | 자료실

spring boot 공부 열심히 하자!

Copyright hyechang
```

---

### th:replace 문법 분석

**기본 문법**:

```
th:replace="~{파일경로::프래그먼트이름}"
```

**구성 요소**:

| 요소 | 설명 | 예시 |
|-----|------|------|
| **~{}** | 템플릿 링크 표현식 | 필수 |
| **파일경로** | `templates/` 기준 경로 | `fragment/common` |
| **::** | 구분자 | 파일과 프래그먼트 구분 |
| **프래그먼트이름** | 대체할 프래그먼트 | `header` |

---

### th:replace의 정확한 의미

**핵심 이해**: `th:replace`는 단순히 "`~{파일경로::프래그먼트이름}`" 형태만 사용하는 것이 아닙니다!

**올바른 이해**:

```
th:replace = "프래그먼트로 대체하겠다"
```

**의미 분석**:

| 항목 | 설명 |
|-----|------|
| **replace** | 현재 태그를 **대체(교체)** |
| **대상** | 뒤에 오는 **프래그먼트** |
| **형태** | 프래그먼트를 가져오는 방법은 다양 |

---

### 다양한 th:replace 사용 형태

**1. 파일에서 가져오기**:

```html
<div th:replace="~{fragment/common::header}"></div>
```

**2. 변수에서 가져오기**:

```html
<div th:replace="${contentFragment}"></div>
```

**3. 현재 파일에서 가져오기**:

```html
<div th:replace="~{::localFragment}"></div>
```

**핵심**: `th:replace` 뒤에는 항상 **프래그먼트**가 오며, 그것으로 현재 태그를 대체한다는 의미입니다!

---

### th:replace 작동 원리

**처리 과정**:

```
1. 호출 태그 발견
   <div th:replace="~{fragment/common::header}"></div>
    ↓
2. 프래그먼트 파일 탐색
   templates/fragment/common.html 열기
    ↓
3. 프래그먼트 찾기
   th:fragment="header" 검색
    ↓
4. 태그 대체
   호출 <div>를 프래그먼트 내용으로 완전히 교체
    ↓
5. 최종 HTML
   <p style="...">홍혜창 스프링 | ...</p>
```

**결과 비교**:

| 단계 | 코드 |
|-----|------|
| **대체 전** | `<div th:replace="..."></div>` |
| **대체 후** | `<p style="...">홍혜창 스프링...</p>` |

**핵심**: 호출 태그인 `<div>`는 사라지고, 프래그먼트의 루트 태그인 `<p>`가 그 자리를 차지합니다!

---

### 매개변수를 전달하는 호출

```html
<div th:replace="~{fragment/common::header('목차1', '목차2', '목차3', '내용1', '내용2', '내용3')}"></div>
```

**실행 결과**:
```
목차1 | 목차2 | 목차3 | 내용1 | 내용2 | 내용3
```

---

**작동 원리**:

| 단계 | 동작 |
|-----|------|
| 1 | 프래그먼트 호출 시 6개의 값 전달 |
| 2 | 프래그먼트 정의의 매개변수 `(a, b, c, d, e, f)`에 순서대로 매핑 |
| 3 | `${a}` → '목차1', `${b}` → '목차2', ... |
| 4 | 최종 HTML 생성 |

**비유**: 함수를 호출하듯이 프래그먼트를 호출하는 방식입니다!

---

### CSS 링크와 프래그먼트의 차이

**중요한 구분**: `th:replace`와 `th:href`는 왜 `@{}`를 다르게 사용할까?

---

### th:href의 경우 (CSS/JS 링크)

```html
<link th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **성격** | 외부 HTTP 요청 |
| **@{} 사용** | ✅ 필수 |
| **이유** | Context Path 자동 포함 필요 |
| **최종 URL** | `/hyechang/css/round-shadow-box.css` |

**작동 방식**:

```
1. 브라우저가 CSS 파일 요청
    ↓
2. HTTP 프로토콜 사용
    ↓
3. URL 경로 필요
    ↓
4. Context Path 포함해야 함
    ↓
5. @{}로 자동 처리
```

---

### th:replace의 경우 (프래그먼트)

```html
<div th:replace="~{fragment/common::header}"></div>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **성격** | 서버 내부 파일 접근 |
| **@{} 사용** | ❌ 불필요 |
| **이유** | HTTP 요청이 아님 |
| **경로 기준** | `templates/` 폴더 |

**작동 방식**:

```
1. 타임리프 엔진이 처리
    ↓
2. 서버 파일 시스템 접근
    ↓
3. templates/ 폴더 기준 탐색
    ↓
4. 메모리 내에서 HTML 조립
    ↓
5. HTTP 요청 관련 없음
```

---

### 핵심 비교

| 구분 | th:href (링크) | th:replace (프래그먼트) |
|-----|--------------|----------------------|
| **목적** | 외부 리소스 요청 URL 생성 | 서버 내부 파일 참조 |
| **처리 시점** | 클라이언트 (브라우저) | 서버 (타임리프 엔진) |
| **프로토콜** | HTTP | 파일 시스템 |
| **@{} 필요** | ✅ 필수 | ❌ 불필요 |
| **Context Path** | 포함 필요 | 무관 |
| **경로 기준** | Context Path + `/static/` | `/templates/` |

**핵심**: 
- `th:href`는 **클라이언트의 인터넷 요청 경로**를 만드는 작업 → `@{}` 필수
- `th:replace`는 **서버의 내부 파일 시스템**에서 파일을 찾는 작업 → `@{}` 불필요

---

### Controller 작성

```java
@Controller
public class BasicController {
    
    @GetMapping("/fragment")
    public String getFragment() {
        return "fragment/fragment-common";
    }
}
```

---

### CSS 접근 경로의 원리

**static 폴더의 역할**:

**파일 위치**: `src/main/resources/static/css/round-shadow-box.css`

**URL 매핑**:

| 구성 요소 | 값 | 설명 |
|---------|-----|------|
| **Context Path** | `/hyechang` | 애플리케이션 식별자 |
| **static 폴더** | (생략) | Spring Boot가 자동으로 루트로 매핑 |
| **실제 경로** | `/css/round-shadow-box.css` | static 내부 경로 |
| **최종 URL** | `/hyechang/css/round-shadow-box.css` | 클라이언트 요청 경로 |

**핵심**: 
- `resources/static` 경로는 URL에 노출되지 않음
- Context Path 바로 뒤에 static 내부 경로가 붙음

---

### 프래그먼트 사용의 장점 (방법 1)

| 장점 | 설명 |
|-----|------|
| **코드 중복 제거** | 헤더, 푸터를 한 곳에서 관리 |
| **유지보수 용이** | 공통 영역 수정 시 한 파일만 변경 |
| **일관성 유지** | 모든 페이지가 동일한 헤더/푸터 사용 |
| **개발 속도 향상** | 새 페이지 추가 시 프래그먼트만 호출 |

---

## 5.2.18 프래그먼트 구현 (방법 2: 전체 레이아웃 템플릿)

### Base Layout 패턴이란?

**개념**: 전체 페이지 구조를 포함한 레이아웃을 프래그먼트로 정의하고, 개별 페이지는 **콘텐츠만 정의**하여 전달하는 방식

**핵심 원리**:
- 레이아웃 = 큰 틀 (뼈대)
- 개별 페이지 = 내용물
- 조립 = 매개변수 전달

---

### Base Layout 파일 작성

**파일 위치**: `src/main/resources/templates/fragment/allcommon.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      th:fragment="allfragment(title, links, content, menu)">
<head>
    <meta charset="UTF-8">
    <title th:text="${title}">Title</title>
    <link th:replace="${links}"/>
</head>
<body>
    <p style="background-color: black; color: white; padding: 12px;">
        홍혜창 스프링 | 강의 | 책 | 
        <span th:text="${menu}"></span> | 
        이벤트 | 자료실
    </p>
    
    <th:block th:replace="${content}"></th:block>
</body>
</html>
```

---

### Base Layout 구조 분석

**1. 최상위 태그에 프래그먼트 선언**:

```html
<html ... th:fragment="allfragment(title, links, content, menu)">
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **선언 위치** | `<html>` 태그 |
| **의미** | HTML 전체가 프래그먼트 |
| **매개변수** | 4개 (title, links, content, menu) |

---

**2. 매개변수 역할**:

| 매개변수 | 타입 | 사용 위치 | 역할 |
|---------|------|---------|------|
| **title** | String | `<title>` 태그 | 페이지 제목 |
| **links** | Fragment | `<head>` 내부 | CSS/JS 링크 |
| **content** | Fragment | `<body>` 내부 | 메인 콘텐츠 |
| **menu** | String | 헤더 영역 | 메뉴 항목 |

---

**3. 프래그먼트 삽입 구문**:

```html
<link th:replace="${links}"/>
```

**작동 원리**:

| 구문 | 의미 |
|-----|------|
| `th:replace="${links}"` | 매개변수로 받은 프래그먼트를 현재 위치에 삽입 |
| `${links}` | 변수에 저장된 프래그먼트 객체 |

**핵심**: `th:replace`는 `~{파일::이름}` 형태만 사용하는 것이 아니라, **변수에 저장된 프래그먼트**도 사용할 수 있습니다!

---

### 개별 페이지 작성

**파일 위치**: `src/main/resources/templates/fragment/fragment-allcommon.html`

```html
<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org"
      th:replace="~{fragment/allcommon::allfragment('스프링부트', ~{::link}, ~{::section}, '뉴메뉴')}">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link th:fragment="link" th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>
</head>
<body>
    <section th:fragment="section">
        프래그먼트 어렵다.. ㅠㅠ
    </section>
</body>
</html>
```

**실행 결과**:
```
홍혜창 스프링 | 강의 | 책 | 뉴메뉴 | 이벤트 | 자료실

프래그먼트 어렵다.. ㅠㅠ
```

---

### 개별 페이지 구조 분석

**1. 최상위 태그에서 전체 대체**:

```html
<html ... th:replace="~{fragment/allcommon::allfragment(...)}">
```

**의미**:

| 항목 | 설명 |
|-----|------|
| **위치** | `<html>` 태그 |
| **동작** | 현재 HTML 전체를 Base Layout으로 대체 |
| **효과** | 이 파일의 HTML 구조는 최종 결과에서 사라짐 |

---

**2. 매개변수 전달**:

```html
allfragment('스프링부트', ~{::link}, ~{::section}, '뉴메뉴')
```

**매개변수 분석**:

| 순서 | 전달 값 | 타입 | Base Layout 매개변수 |
|-----|--------|------|-------------------|
| 1 | `'스프링부트'` | String | `title` |
| 2 | `~{::link}` | Fragment | `links` |
| 3 | `~{::section}` | Fragment | `content` |
| 4 | `'뉴메뉴'` | String | `menu` |

---

**3. ~{::태그명}의 의미**:

```html
~{::link}
~{::section}
```

**구문 분석**:

| 구성 요소 | 의미 |
|---------|------|
| **~{}** | 프래그먼트 참조 표현식 |
| **::** | 구분자 (파일 생략 시 현재 파일) |
| **태그명** | 찾을 프래그먼트 또는 태그 |

**작동 원리**:

```
~{::link} 실행 시:
1. 현재 파일에서 th:fragment="link" 또는 <link> 태그 탐색
2. 해당 태그와 내용을 프래그먼트 객체로 변환
3. 매개변수로 전달
```

---

**4. 콘텐츠 프래그먼트 정의**:

```html
<link th:fragment="link" th:href="@{/css/round-shadow-box.css}" rel="stylesheet"/>

<section th:fragment="section">
    프래그먼트 어렵다.. ㅠㅠ
</section>
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **th:fragment** | 명시적으로 프래그먼트 이름 지정 |
| **목적** | 이 코드 블록을 Base Layout에 전달 |
| **최종 HTML** | 이 내용이 Base Layout의 해당 위치에 삽입됨 |

---

### Base Layout 패턴 작동 흐름

**전체 처리 과정**:

```
1. Controller
   return "fragment/fragment-allcommon"
    ↓
2. ViewResolver
   fragment-allcommon.html 열기
    ↓
3. 전체 대체 명령 발견
   <html th:replace="~{fragment/allcommon::allfragment(...)}">
    ↓
4. 현재 파일에서 프래그먼트 추출
   ~{::link} → <link> 태그 추출
   ~{::section} → <section> 태그 추출
    ↓
5. Base Layout 호출
   fragment/allcommon.html의 allfragment 실행
    ↓
6. 매개변수 주입
   title = '스프링부트'
   links = <link> 프래그먼트
   content = <section> 프래그먼트
   menu = '뉴메뉴'
    ↓
7. Base Layout에서 조립
   <title th:text="${title}"> → <title>스프링부트</title>
   <link th:replace="${links}"/> → <link th:href="..."/>
   <span th:text="${menu}"> → <span>뉴메뉴</span>
   <th:block th:replace="${content}"> → <section>...</section>
    ↓
8. 최종 HTML 생성
   완성된 HTML을 클라이언트에게 전달
```

---

### Controller 작성

```java
@Controller
public class BasicController {
    
    @GetMapping("/allfragment")
    public String getAllFragment() {
        return "fragment/fragment-allcommon";
    }
}
```

---

### 핵심 개념: View의 역할 변화

**전통적인 방식**:

```
Controller → View (완전한 HTML 파일) → 클라이언트
```

**Base Layout 방식**:

```
Controller → View (콘텐츠만 정의)
                ↓
            Base Layout (전체 구조)
                ↓
            최종 HTML → 클라이언트
```

**핵심 차이**:

| 항목 | 전통적 방식 | Base Layout 방식 |
|-----|-----------|----------------|
| **View 역할** | 완성된 HTML 생성 | 콘텐츠만 제공 |
| **HTML 구조** | 각 페이지에 포함 | Base Layout에만 존재 |
| **프래그먼트 사용** | 일부 영역 대체 | HTML 전체 대체 |
| **유지보수** | 각 파일 수정 필요 | Base Layout만 수정 |

---

### 프래그먼트 참조 시 주의사항

#### 문제점: 태그 이름 참조의 모호성

**문제 상황**:

```html
<section>첫 번째 섹션</section>
<section>두 번째 섹션</section>

<!-- ❌ 어떤 section을 참조? -->
<div th:replace="~{::section}"></div>
```

**오류 발생**:
- 동일한 태그가 여러 개 있으면 모호성 발생
- `TemplateProcessingException` 오류
- 렌더링 실패

---

#### 해결책: th:fragment로 고유 이름 지정 (권장)

**안전한 방식**:

```html
<!-- ✅ 프래그먼트 정의 -->
<link th:fragment="pageCss" th:href="@{/css/style.css}"/>
<section th:fragment="mainContent">메인 콘텐츠</section>

<!-- ✅ 명확한 참조 -->
<div th:replace="~{::pageCss}"></div>
<div th:replace="~{::mainContent}"></div>
```

**장점**:

| 장점 | 설명 |
|-----|------|
| **명확성** | 고유한 이름으로 정확히 식별 |
| **유지보수** | 태그 종류 변경 시에도 참조 코드 수정 불필요 |
| **가독성** | 코드의 목적이 명확함 |
| **안전성** | 모호성 오류 방지 |

---

### Base Layout 패턴의 장점

#### 1. 구조적 일관성

| 항목 | 설명 |
|-----|------|
| **레이아웃 통일** | 모든 페이지가 동일한구조 보장 |
| **디자인 일관성** | 헤더, 푸터가 항상 동일하게 표시 |
| **표준화** | 웹사이트 전체의 UI/UX 통일 |

---

#### 2. 유지보수 효율성

**변경 사항 발생 시**:

| 구분 | 방법 1 (부분 대체) | 방법 2 (Base Layout) |
|-----|-----------------|-------------------|
| **헤더 수정** | 모든 페이지 수정 필요 | allcommon.html 한 곳만 수정 |
| **레이아웃 변경** | 각 페이지 구조 수정 | Base Layout만 수정 |
| **CSS 추가** | 모든 페이지에 링크 추가 | Base Layout에 한 번만 추가 |

**효과**: 수백 개의 페이지가 있어도 한 파일만 수정하면 전체 반영!

---

#### 3. 개발 속도 향상

**새 페이지 추가 시**:

```html
<!-- 필요한 작업: 콘텐츠만 작성 -->
<html th:replace="~{fragment/allcommon::allfragment('제목', ~{::link}, ~{::section}, '메뉴')}">
<head>
    <link th:fragment="link" th:href="@{/css/new-page.css}"/>
</head>
<body>
    <section th:fragment="section">
        <!-- 이 페이지만의 콘텐츠 작성 -->
        새로운 페이지 내용
    </section>
</body>
</html>
```

**장점**:

| 항목 | 설명 |
|-----|------|
| **간단한 구조** | `<html>`, `<head>`, `<body>`의 복잡한 설정 불필요 |
| **빠른 개발** | 콘텐츠에만 집중 가능 |
| **실수 방지** | 레이아웃 구조를 잘못 작성할 위험 없음 |

---

#### 4. 프로젝트 구조 개선

**디렉토리 구조**:

```
templates/
├── fragment/
│   └── allcommon.html          (Base Layout - 1개)
├── home.html                    (콘텐츠만)
├── about.html                   (콘텐츠만)
├── products/
│   ├── list.html                (콘텐츠만)
│   └── detail.html              (콘텐츠만)
└── admin/
    ├── dashboard.html           (콘텐츠만)
    └── users.html               (콘텐츠만)
```

**특징**:

| 항목 | 설명 |
|-----|------|
| **명확한 분리** | 레이아웃과 콘텐츠의 역할 분리 |
| **파일 크기** | 각 페이지 파일이 간결해짐 |
| **관리 용이** | 구조를 한눈에 파악 가능 |

---

### 방법 1 vs 방법 2 비교

**최종 비교표**:

| 구분 | 방법 1 (부분 대체) | 방법 2 (Base Layout) |
|-----|-----------------|-------------------|
| **대체 범위** | 일부 영역 (헤더, 푸터) | HTML 전체 |
| **페이지 구조** | 완전한 HTML 포함 | 콘텐츠만 정의 |
| **유지보수** | 공통 영역만 중앙 관리 | 전체 구조 중앙 관리 |
| **개발 속도** | 보통 | 빠름 |
| **복잡도** | 낮음 (직관적) | 높음 (고급) |
| **사용 시점** | 간단한 공통 요소 재사용 | 대규모 프로젝트, 일관된 레이아웃 필요 |
| **실무 선호도** | 기본적인 사용 | 실무에서 더 선호 |

---

### 실무 사용 패턴

#### 방법 1 사용 케이스

**적합한 상황**:

| 상황 | 설명 |
|-----|------|
| **부분 공통화** | 헤더, 푸터만 공통으로 사용 |
| **간단한 프로젝트** | 페이지 수가 적음 |
| **빠른 프로토타입** | 개념 검증용 개발 |
| **학습 단계** | 프래그먼트 개념 학습 |

---

#### 방법 2 사용 케이스

**적합한 상황**:

| 상황 | 설명 |
|-----|------|
| **대규모 프로젝트** | 수십~수백 개의 페이지 |
| **일관된 레이아웃** | 전체 사이트의 구조 통일 필수 |
| **관리자 페이지** | 동일한 사이드바, 헤더 구조 |
| **실무 프로젝트** | 유지보수성이 중요한 경우 |

---

### 프래그먼트 패턴의 현대적 의미

**타임리프 프래그먼트의 개념은 현대 프론트엔드 프레임워크와 유사합니다**:

| 프레임워크 | 유사 개념 | 설명 |
|-----------|---------|------|
| **React** | Component | 재사용 가능한 UI 조각 |
| **Vue** | Component + Slot | 컴포넌트와 슬롯 시스템 |
| **Angular** | Component | 컴포넌트 기반 구조 |
| **Thymeleaf** | Fragment | 재사용 가능한 HTML 조각 |

**핵심**: Base Layout 패턴은 React의 `children` props나 Vue의 `<slot>`과 동일한 개념입니다!

---

### 실무 개발 워크플로우

**Base Layout 방식 개발 순서**:

```
1단계: Base Layout 설계
    ↓
fragment/allcommon.html 작성
- 전체 구조 정의
- 매개변수 선언 (title, links, content)
    ↓
2단계: 개별 페이지 개발
    ↓
각 페이지에서:
- 콘텐츠만 작성 (<section th:fragment="section">)
- 필요한 CSS만 정의 (<link th:fragment="link">)
- Base Layout 호출
    ↓
3단계: 유지보수
    ↓
레이아웃 변경 시:
- allcommon.html만 수정
- 모든 페이지에 자동 반영
```

---

### 프래그먼트 사용 모범 사례

#### 1. 명확한 네이밍

```html
<!-- ✅ 좋은 예 -->
<header th:fragment="mainHeader">...</header>
<nav th:fragment="sideNavigation">...</nav>
<footer th:fragment="mainFooter">...</footer>

<!-- ❌ 나쁜 예 -->
<div th:fragment="div1">...</div>
<div th:fragment="d2">...</div>
```

---

#### 2. 프래그먼트 파일 분리

**권장 구조**:

```
templates/fragment/
├── allcommon.html      (Base Layout)
├── common.html         (헤더, 푸터)
├── navigation.html     (네비게이션)
└── forms.html          (폼 요소들)
```

---

#### 3. 매개변수 문서화

```html
<!--
Base Layout Fragment: allfragment
매개변수:
- title (String): 페이지 제목
- links (Fragment): CSS/JS 링크
- content (Fragment): 메인 콘텐츠
- menu (String): 활성 메뉴 이름
-->
<html th:fragment="allfragment(title, links, content, menu)">
```

---

### 핵심 정리

**프래그먼트의 본질**:

| 개념 | 설명 |
|-----|------|
| **코드 재사용** | 중복 제거 |
| **관심사 분리** | 레이아웃과 콘텐츠 분리 |
| **유지보수성** | 중앙 집중식 관리 |
| **개발 효율** | 빠른 페이지 추가 |

---

**th:replace의 핵심**:

```
th:replace = "프래그먼트로 대체"
```

**다양한 형태**:
- `~{파일::이름}` : 파일에서 가져오기
- `${변수}` : 변수에서 가져오기
- `~{::이름}` : 현재 파일에서 가져오기

**공통점**: 모두 **프래그먼트**를 대상으로 함!

---

**@{} 사용 구분**:

| 속성 | @{} 사용 | 이유 |
|-----|---------|------|
| `th:href` | ✅ 필수 | HTTP 요청 URL 생성 |
| `th:src` | ✅ 필수 | 외부 리소스 경로 |
| `th:replace` | ❌ 불필요 | 서버 내부 파일 접근 |

---

**레이아웃 관리 권장사항**:

| 프로젝트 규모 | 권장 방법 |
|------------|---------|
| **소규모** | 방법 1 (부분 대체) |
| **중규모** | 방법 1 + 방법 2 혼용 |
| **대규모** | 방법 2 (Base Layout) |

---

**결론**: 

타임리프의 프래그먼트 시스템은 효율적인 레이아웃 관리를 위한 강력한 도구입니다. 

특히 **Base Layout 패턴(방법 2)**은 대규모 웹 애플리케이션에서 구조적 일관성과 유지보수성을 극대화하는 현대적인 접근 방식으로, 실무에서 널리 사용되는 표준 패턴입니다.

프래그먼트를 이해하고 활용하면, JSP의 `<jsp:include>`나 현대 프론트엔드 프레임워크의 컴포넌트 시스템과 유사한 수준의 모듈화된 개발이 가능하며, 이는 Spring Boot 기반 SSR 웹 애플리케이션 개발의 핵심 기술입니다.



